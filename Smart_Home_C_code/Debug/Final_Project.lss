
Final_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000052d0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000c8  00800060  000052d0  00005364  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000570  00800128  00800128  0000542c  2**0
                  ALLOC
  3 .stab         00006b34  00000000  00000000  0000542c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000037a1  00000000  00000000  0000bf60  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000f701  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000f841  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000f9b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  000115fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  000124e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00013294  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  000133f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00013681  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00013e4f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 9c 0f 	jmp	0x1f38	; 0x1f38 <__vector_1>
       8:	0c 94 c9 0f 	jmp	0x1f92	; 0x1f92 <__vector_2>
       c:	0c 94 f6 0f 	jmp	0x1fec	; 0x1fec <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 a1 1d 	jmp	0x3b42	; 0x3b42 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 ed       	ldi	r30, 0xD0	; 208
      68:	f2 e5       	ldi	r31, 0x52	; 82
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 32       	cpi	r26, 0x28	; 40
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a8 e2       	ldi	r26, 0x28	; 40
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 39       	cpi	r26, 0x98	; 152
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 28 1a 	call	0x3450	; 0x3450 <main>
      8a:	0c 94 66 29 	jmp	0x52cc	; 0x52cc <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 10 29 	jmp	0x5220	; 0x5220 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	aa e0       	ldi	r26, 0x0A	; 10
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 2c 29 	jmp	0x5258	; 0x5258 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 1c 29 	jmp	0x5238	; 0x5238 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 38 29 	jmp	0x5270	; 0x5270 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 1c 29 	jmp	0x5238	; 0x5238 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 38 29 	jmp	0x5270	; 0x5270 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 10 29 	jmp	0x5220	; 0x5220 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8a e0       	ldi	r24, 0x0A	; 10
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 2c 29 	jmp	0x5258	; 0x5258 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 1c 29 	jmp	0x5238	; 0x5238 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 38 29 	jmp	0x5270	; 0x5270 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 1c 29 	jmp	0x5238	; 0x5238 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 38 29 	jmp	0x5270	; 0x5270 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 1c 29 	jmp	0x5238	; 0x5238 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 38 29 	jmp	0x5270	; 0x5270 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 20 29 	jmp	0x5240	; 0x5240 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 3c 29 	jmp	0x5278	; 0x5278 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <CLCD_voidSendData>:
#include "CLCD_config.h"

#include <util/delay.h>


static void CLCD_voidSendData(u8 Copy_u8Data){
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
     b4e:	2f 97       	sbiw	r28, 0x0f	; 15
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	de bf       	out	0x3e, r29	; 62
     b56:	0f be       	out	0x3f, r0	; 63
     b58:	cd bf       	out	0x3d, r28	; 61
     b5a:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_voidSetPinValue(CTRL_PORT,RS,PIN_HIGH);
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	63 e0       	ldi	r22, 0x03	; 3
     b60:	41 e0       	ldi	r20, 0x01	; 1
     b62:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(CTRL_PORT,RW,PIN_LOW);
     b66:	83 e0       	ldi	r24, 0x03	; 3
     b68:	64 e0       	ldi	r22, 0x04	; 4
     b6a:	40 e0       	ldi	r20, 0x00	; 0
     b6c:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
	DIO_voidSetPortValue(DATA_PORT,Copy_u8Data);
     b70:	82 e0       	ldi	r24, 0x02	; 2
     b72:	6f 85       	ldd	r22, Y+15	; 0x0f
     b74:	0e 94 a2 09 	call	0x1344	; 0x1344 <DIO_voidSetPortValue>
	DIO_voidSetPinValue(CTRL_PORT,EN, PIN_HIGH);
     b78:	83 e0       	ldi	r24, 0x03	; 3
     b7a:	62 e0       	ldi	r22, 0x02	; 2
     b7c:	41 e0       	ldi	r20, 0x01	; 1
     b7e:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	90 e0       	ldi	r25, 0x00	; 0
     b86:	a0 e8       	ldi	r26, 0x80	; 128
     b88:	bf e3       	ldi	r27, 0x3F	; 63
     b8a:	8b 87       	std	Y+11, r24	; 0x0b
     b8c:	9c 87       	std	Y+12, r25	; 0x0c
     b8e:	ad 87       	std	Y+13, r26	; 0x0d
     b90:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     b92:	6b 85       	ldd	r22, Y+11	; 0x0b
     b94:	7c 85       	ldd	r23, Y+12	; 0x0c
     b96:	8d 85       	ldd	r24, Y+13	; 0x0d
     b98:	9e 85       	ldd	r25, Y+14	; 0x0e
     b9a:	20 e0       	ldi	r18, 0x00	; 0
     b9c:	30 e0       	ldi	r19, 0x00	; 0
     b9e:	4a ef       	ldi	r20, 0xFA	; 250
     ba0:	54 e4       	ldi	r21, 0x44	; 68
     ba2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ba6:	dc 01       	movw	r26, r24
     ba8:	cb 01       	movw	r24, r22
     baa:	8f 83       	std	Y+7, r24	; 0x07
     bac:	98 87       	std	Y+8, r25	; 0x08
     bae:	a9 87       	std	Y+9, r26	; 0x09
     bb0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     bb2:	6f 81       	ldd	r22, Y+7	; 0x07
     bb4:	78 85       	ldd	r23, Y+8	; 0x08
     bb6:	89 85       	ldd	r24, Y+9	; 0x09
     bb8:	9a 85       	ldd	r25, Y+10	; 0x0a
     bba:	20 e0       	ldi	r18, 0x00	; 0
     bbc:	30 e0       	ldi	r19, 0x00	; 0
     bbe:	40 e8       	ldi	r20, 0x80	; 128
     bc0:	5f e3       	ldi	r21, 0x3F	; 63
     bc2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     bc6:	88 23       	and	r24, r24
     bc8:	2c f4       	brge	.+10     	; 0xbd4 <CLCD_voidSendData+0x8e>
		__ticks = 1;
     bca:	81 e0       	ldi	r24, 0x01	; 1
     bcc:	90 e0       	ldi	r25, 0x00	; 0
     bce:	9e 83       	std	Y+6, r25	; 0x06
     bd0:	8d 83       	std	Y+5, r24	; 0x05
     bd2:	3f c0       	rjmp	.+126    	; 0xc52 <CLCD_voidSendData+0x10c>
	else if (__tmp > 65535)
     bd4:	6f 81       	ldd	r22, Y+7	; 0x07
     bd6:	78 85       	ldd	r23, Y+8	; 0x08
     bd8:	89 85       	ldd	r24, Y+9	; 0x09
     bda:	9a 85       	ldd	r25, Y+10	; 0x0a
     bdc:	20 e0       	ldi	r18, 0x00	; 0
     bde:	3f ef       	ldi	r19, 0xFF	; 255
     be0:	4f e7       	ldi	r20, 0x7F	; 127
     be2:	57 e4       	ldi	r21, 0x47	; 71
     be4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     be8:	18 16       	cp	r1, r24
     bea:	4c f5       	brge	.+82     	; 0xc3e <CLCD_voidSendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     bec:	6b 85       	ldd	r22, Y+11	; 0x0b
     bee:	7c 85       	ldd	r23, Y+12	; 0x0c
     bf0:	8d 85       	ldd	r24, Y+13	; 0x0d
     bf2:	9e 85       	ldd	r25, Y+14	; 0x0e
     bf4:	20 e0       	ldi	r18, 0x00	; 0
     bf6:	30 e0       	ldi	r19, 0x00	; 0
     bf8:	40 e2       	ldi	r20, 0x20	; 32
     bfa:	51 e4       	ldi	r21, 0x41	; 65
     bfc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     c00:	dc 01       	movw	r26, r24
     c02:	cb 01       	movw	r24, r22
     c04:	bc 01       	movw	r22, r24
     c06:	cd 01       	movw	r24, r26
     c08:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     c0c:	dc 01       	movw	r26, r24
     c0e:	cb 01       	movw	r24, r22
     c10:	9e 83       	std	Y+6, r25	; 0x06
     c12:	8d 83       	std	Y+5, r24	; 0x05
     c14:	0f c0       	rjmp	.+30     	; 0xc34 <CLCD_voidSendData+0xee>
     c16:	88 ec       	ldi	r24, 0xC8	; 200
     c18:	90 e0       	ldi	r25, 0x00	; 0
     c1a:	9c 83       	std	Y+4, r25	; 0x04
     c1c:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c1e:	8b 81       	ldd	r24, Y+3	; 0x03
     c20:	9c 81       	ldd	r25, Y+4	; 0x04
     c22:	01 97       	sbiw	r24, 0x01	; 1
     c24:	f1 f7       	brne	.-4      	; 0xc22 <CLCD_voidSendData+0xdc>
     c26:	9c 83       	std	Y+4, r25	; 0x04
     c28:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     c2a:	8d 81       	ldd	r24, Y+5	; 0x05
     c2c:	9e 81       	ldd	r25, Y+6	; 0x06
     c2e:	01 97       	sbiw	r24, 0x01	; 1
     c30:	9e 83       	std	Y+6, r25	; 0x06
     c32:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     c34:	8d 81       	ldd	r24, Y+5	; 0x05
     c36:	9e 81       	ldd	r25, Y+6	; 0x06
     c38:	00 97       	sbiw	r24, 0x00	; 0
     c3a:	69 f7       	brne	.-38     	; 0xc16 <CLCD_voidSendData+0xd0>
     c3c:	14 c0       	rjmp	.+40     	; 0xc66 <CLCD_voidSendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     c3e:	6f 81       	ldd	r22, Y+7	; 0x07
     c40:	78 85       	ldd	r23, Y+8	; 0x08
     c42:	89 85       	ldd	r24, Y+9	; 0x09
     c44:	9a 85       	ldd	r25, Y+10	; 0x0a
     c46:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     c4a:	dc 01       	movw	r26, r24
     c4c:	cb 01       	movw	r24, r22
     c4e:	9e 83       	std	Y+6, r25	; 0x06
     c50:	8d 83       	std	Y+5, r24	; 0x05
     c52:	8d 81       	ldd	r24, Y+5	; 0x05
     c54:	9e 81       	ldd	r25, Y+6	; 0x06
     c56:	9a 83       	std	Y+2, r25	; 0x02
     c58:	89 83       	std	Y+1, r24	; 0x01
     c5a:	89 81       	ldd	r24, Y+1	; 0x01
     c5c:	9a 81       	ldd	r25, Y+2	; 0x02
     c5e:	01 97       	sbiw	r24, 0x01	; 1
     c60:	f1 f7       	brne	.-4      	; 0xc5e <CLCD_voidSendData+0x118>
     c62:	9a 83       	std	Y+2, r25	; 0x02
     c64:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
	DIO_voidSetPinValue(CTRL_PORT,EN,PIN_LOW);
     c66:	83 e0       	ldi	r24, 0x03	; 3
     c68:	62 e0       	ldi	r22, 0x02	; 2
     c6a:	40 e0       	ldi	r20, 0x00	; 0
     c6c:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
}
     c70:	2f 96       	adiw	r28, 0x0f	; 15
     c72:	0f b6       	in	r0, 0x3f	; 63
     c74:	f8 94       	cli
     c76:	de bf       	out	0x3e, r29	; 62
     c78:	0f be       	out	0x3f, r0	; 63
     c7a:	cd bf       	out	0x3d, r28	; 61
     c7c:	cf 91       	pop	r28
     c7e:	df 91       	pop	r29
     c80:	08 95       	ret

00000c82 <CLCD_voidSendCmd>:
static void CLCD_voidSendCmd(u8 Copy_u8Cmd){
     c82:	df 93       	push	r29
     c84:	cf 93       	push	r28
     c86:	cd b7       	in	r28, 0x3d	; 61
     c88:	de b7       	in	r29, 0x3e	; 62
     c8a:	2f 97       	sbiw	r28, 0x0f	; 15
     c8c:	0f b6       	in	r0, 0x3f	; 63
     c8e:	f8 94       	cli
     c90:	de bf       	out	0x3e, r29	; 62
     c92:	0f be       	out	0x3f, r0	; 63
     c94:	cd bf       	out	0x3d, r28	; 61
     c96:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_voidSetPinValue(CTRL_PORT,RS,PIN_LOW);
     c98:	83 e0       	ldi	r24, 0x03	; 3
     c9a:	63 e0       	ldi	r22, 0x03	; 3
     c9c:	40 e0       	ldi	r20, 0x00	; 0
     c9e:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(CTRL_PORT,RW,PIN_LOW);
     ca2:	83 e0       	ldi	r24, 0x03	; 3
     ca4:	64 e0       	ldi	r22, 0x04	; 4
     ca6:	40 e0       	ldi	r20, 0x00	; 0
     ca8:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
	DIO_voidSetPortValue(DATA_PORT,Copy_u8Cmd);
     cac:	82 e0       	ldi	r24, 0x02	; 2
     cae:	6f 85       	ldd	r22, Y+15	; 0x0f
     cb0:	0e 94 a2 09 	call	0x1344	; 0x1344 <DIO_voidSetPortValue>
	DIO_voidSetPinValue(CTRL_PORT,EN, PIN_HIGH);
     cb4:	83 e0       	ldi	r24, 0x03	; 3
     cb6:	62 e0       	ldi	r22, 0x02	; 2
     cb8:	41 e0       	ldi	r20, 0x01	; 1
     cba:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
     cbe:	80 e0       	ldi	r24, 0x00	; 0
     cc0:	90 e0       	ldi	r25, 0x00	; 0
     cc2:	a0 e8       	ldi	r26, 0x80	; 128
     cc4:	bf e3       	ldi	r27, 0x3F	; 63
     cc6:	8b 87       	std	Y+11, r24	; 0x0b
     cc8:	9c 87       	std	Y+12, r25	; 0x0c
     cca:	ad 87       	std	Y+13, r26	; 0x0d
     ccc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     cce:	6b 85       	ldd	r22, Y+11	; 0x0b
     cd0:	7c 85       	ldd	r23, Y+12	; 0x0c
     cd2:	8d 85       	ldd	r24, Y+13	; 0x0d
     cd4:	9e 85       	ldd	r25, Y+14	; 0x0e
     cd6:	20 e0       	ldi	r18, 0x00	; 0
     cd8:	30 e0       	ldi	r19, 0x00	; 0
     cda:	4a ef       	ldi	r20, 0xFA	; 250
     cdc:	54 e4       	ldi	r21, 0x44	; 68
     cde:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ce2:	dc 01       	movw	r26, r24
     ce4:	cb 01       	movw	r24, r22
     ce6:	8f 83       	std	Y+7, r24	; 0x07
     ce8:	98 87       	std	Y+8, r25	; 0x08
     cea:	a9 87       	std	Y+9, r26	; 0x09
     cec:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     cee:	6f 81       	ldd	r22, Y+7	; 0x07
     cf0:	78 85       	ldd	r23, Y+8	; 0x08
     cf2:	89 85       	ldd	r24, Y+9	; 0x09
     cf4:	9a 85       	ldd	r25, Y+10	; 0x0a
     cf6:	20 e0       	ldi	r18, 0x00	; 0
     cf8:	30 e0       	ldi	r19, 0x00	; 0
     cfa:	40 e8       	ldi	r20, 0x80	; 128
     cfc:	5f e3       	ldi	r21, 0x3F	; 63
     cfe:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     d02:	88 23       	and	r24, r24
     d04:	2c f4       	brge	.+10     	; 0xd10 <CLCD_voidSendCmd+0x8e>
		__ticks = 1;
     d06:	81 e0       	ldi	r24, 0x01	; 1
     d08:	90 e0       	ldi	r25, 0x00	; 0
     d0a:	9e 83       	std	Y+6, r25	; 0x06
     d0c:	8d 83       	std	Y+5, r24	; 0x05
     d0e:	3f c0       	rjmp	.+126    	; 0xd8e <CLCD_voidSendCmd+0x10c>
	else if (__tmp > 65535)
     d10:	6f 81       	ldd	r22, Y+7	; 0x07
     d12:	78 85       	ldd	r23, Y+8	; 0x08
     d14:	89 85       	ldd	r24, Y+9	; 0x09
     d16:	9a 85       	ldd	r25, Y+10	; 0x0a
     d18:	20 e0       	ldi	r18, 0x00	; 0
     d1a:	3f ef       	ldi	r19, 0xFF	; 255
     d1c:	4f e7       	ldi	r20, 0x7F	; 127
     d1e:	57 e4       	ldi	r21, 0x47	; 71
     d20:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     d24:	18 16       	cp	r1, r24
     d26:	4c f5       	brge	.+82     	; 0xd7a <CLCD_voidSendCmd+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d28:	6b 85       	ldd	r22, Y+11	; 0x0b
     d2a:	7c 85       	ldd	r23, Y+12	; 0x0c
     d2c:	8d 85       	ldd	r24, Y+13	; 0x0d
     d2e:	9e 85       	ldd	r25, Y+14	; 0x0e
     d30:	20 e0       	ldi	r18, 0x00	; 0
     d32:	30 e0       	ldi	r19, 0x00	; 0
     d34:	40 e2       	ldi	r20, 0x20	; 32
     d36:	51 e4       	ldi	r21, 0x41	; 65
     d38:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     d3c:	dc 01       	movw	r26, r24
     d3e:	cb 01       	movw	r24, r22
     d40:	bc 01       	movw	r22, r24
     d42:	cd 01       	movw	r24, r26
     d44:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     d48:	dc 01       	movw	r26, r24
     d4a:	cb 01       	movw	r24, r22
     d4c:	9e 83       	std	Y+6, r25	; 0x06
     d4e:	8d 83       	std	Y+5, r24	; 0x05
     d50:	0f c0       	rjmp	.+30     	; 0xd70 <CLCD_voidSendCmd+0xee>
     d52:	88 ec       	ldi	r24, 0xC8	; 200
     d54:	90 e0       	ldi	r25, 0x00	; 0
     d56:	9c 83       	std	Y+4, r25	; 0x04
     d58:	8b 83       	std	Y+3, r24	; 0x03
     d5a:	8b 81       	ldd	r24, Y+3	; 0x03
     d5c:	9c 81       	ldd	r25, Y+4	; 0x04
     d5e:	01 97       	sbiw	r24, 0x01	; 1
     d60:	f1 f7       	brne	.-4      	; 0xd5e <CLCD_voidSendCmd+0xdc>
     d62:	9c 83       	std	Y+4, r25	; 0x04
     d64:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d66:	8d 81       	ldd	r24, Y+5	; 0x05
     d68:	9e 81       	ldd	r25, Y+6	; 0x06
     d6a:	01 97       	sbiw	r24, 0x01	; 1
     d6c:	9e 83       	std	Y+6, r25	; 0x06
     d6e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d70:	8d 81       	ldd	r24, Y+5	; 0x05
     d72:	9e 81       	ldd	r25, Y+6	; 0x06
     d74:	00 97       	sbiw	r24, 0x00	; 0
     d76:	69 f7       	brne	.-38     	; 0xd52 <CLCD_voidSendCmd+0xd0>
     d78:	14 c0       	rjmp	.+40     	; 0xda2 <CLCD_voidSendCmd+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d7a:	6f 81       	ldd	r22, Y+7	; 0x07
     d7c:	78 85       	ldd	r23, Y+8	; 0x08
     d7e:	89 85       	ldd	r24, Y+9	; 0x09
     d80:	9a 85       	ldd	r25, Y+10	; 0x0a
     d82:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     d86:	dc 01       	movw	r26, r24
     d88:	cb 01       	movw	r24, r22
     d8a:	9e 83       	std	Y+6, r25	; 0x06
     d8c:	8d 83       	std	Y+5, r24	; 0x05
     d8e:	8d 81       	ldd	r24, Y+5	; 0x05
     d90:	9e 81       	ldd	r25, Y+6	; 0x06
     d92:	9a 83       	std	Y+2, r25	; 0x02
     d94:	89 83       	std	Y+1, r24	; 0x01
     d96:	89 81       	ldd	r24, Y+1	; 0x01
     d98:	9a 81       	ldd	r25, Y+2	; 0x02
     d9a:	01 97       	sbiw	r24, 0x01	; 1
     d9c:	f1 f7       	brne	.-4      	; 0xd9a <CLCD_voidSendCmd+0x118>
     d9e:	9a 83       	std	Y+2, r25	; 0x02
     da0:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
	DIO_voidSetPinValue(CTRL_PORT,EN,PIN_LOW);
     da2:	83 e0       	ldi	r24, 0x03	; 3
     da4:	62 e0       	ldi	r22, 0x02	; 2
     da6:	40 e0       	ldi	r20, 0x00	; 0
     da8:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
}
     dac:	2f 96       	adiw	r28, 0x0f	; 15
     dae:	0f b6       	in	r0, 0x3f	; 63
     db0:	f8 94       	cli
     db2:	de bf       	out	0x3e, r29	; 62
     db4:	0f be       	out	0x3f, r0	; 63
     db6:	cd bf       	out	0x3d, r28	; 61
     db8:	cf 91       	pop	r28
     dba:	df 91       	pop	r29
     dbc:	08 95       	ret

00000dbe <CLCD_voidInit>:
void CLCD_voidInit(void){
     dbe:	df 93       	push	r29
     dc0:	cf 93       	push	r28
     dc2:	cd b7       	in	r28, 0x3d	; 61
     dc4:	de b7       	in	r29, 0x3e	; 62
     dc6:	e8 97       	sbiw	r28, 0x38	; 56
     dc8:	0f b6       	in	r0, 0x3f	; 63
     dca:	f8 94       	cli
     dcc:	de bf       	out	0x3e, r29	; 62
     dce:	0f be       	out	0x3f, r0	; 63
     dd0:	cd bf       	out	0x3d, r28	; 61
     dd2:	80 e0       	ldi	r24, 0x00	; 0
     dd4:	90 e0       	ldi	r25, 0x00	; 0
     dd6:	a0 e2       	ldi	r26, 0x20	; 32
     dd8:	b2 e4       	ldi	r27, 0x42	; 66
     dda:	8d ab       	std	Y+53, r24	; 0x35
     ddc:	9e ab       	std	Y+54, r25	; 0x36
     dde:	af ab       	std	Y+55, r26	; 0x37
     de0:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     de2:	6d a9       	ldd	r22, Y+53	; 0x35
     de4:	7e a9       	ldd	r23, Y+54	; 0x36
     de6:	8f a9       	ldd	r24, Y+55	; 0x37
     de8:	98 ad       	ldd	r25, Y+56	; 0x38
     dea:	20 e0       	ldi	r18, 0x00	; 0
     dec:	30 e0       	ldi	r19, 0x00	; 0
     dee:	4a ef       	ldi	r20, 0xFA	; 250
     df0:	54 e4       	ldi	r21, 0x44	; 68
     df2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     df6:	dc 01       	movw	r26, r24
     df8:	cb 01       	movw	r24, r22
     dfa:	89 ab       	std	Y+49, r24	; 0x31
     dfc:	9a ab       	std	Y+50, r25	; 0x32
     dfe:	ab ab       	std	Y+51, r26	; 0x33
     e00:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
     e02:	69 a9       	ldd	r22, Y+49	; 0x31
     e04:	7a a9       	ldd	r23, Y+50	; 0x32
     e06:	8b a9       	ldd	r24, Y+51	; 0x33
     e08:	9c a9       	ldd	r25, Y+52	; 0x34
     e0a:	20 e0       	ldi	r18, 0x00	; 0
     e0c:	30 e0       	ldi	r19, 0x00	; 0
     e0e:	40 e8       	ldi	r20, 0x80	; 128
     e10:	5f e3       	ldi	r21, 0x3F	; 63
     e12:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     e16:	88 23       	and	r24, r24
     e18:	2c f4       	brge	.+10     	; 0xe24 <CLCD_voidInit+0x66>
		__ticks = 1;
     e1a:	81 e0       	ldi	r24, 0x01	; 1
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	98 ab       	std	Y+48, r25	; 0x30
     e20:	8f a7       	std	Y+47, r24	; 0x2f
     e22:	3f c0       	rjmp	.+126    	; 0xea2 <CLCD_voidInit+0xe4>
	else if (__tmp > 65535)
     e24:	69 a9       	ldd	r22, Y+49	; 0x31
     e26:	7a a9       	ldd	r23, Y+50	; 0x32
     e28:	8b a9       	ldd	r24, Y+51	; 0x33
     e2a:	9c a9       	ldd	r25, Y+52	; 0x34
     e2c:	20 e0       	ldi	r18, 0x00	; 0
     e2e:	3f ef       	ldi	r19, 0xFF	; 255
     e30:	4f e7       	ldi	r20, 0x7F	; 127
     e32:	57 e4       	ldi	r21, 0x47	; 71
     e34:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     e38:	18 16       	cp	r1, r24
     e3a:	4c f5       	brge	.+82     	; 0xe8e <CLCD_voidInit+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     e3c:	6d a9       	ldd	r22, Y+53	; 0x35
     e3e:	7e a9       	ldd	r23, Y+54	; 0x36
     e40:	8f a9       	ldd	r24, Y+55	; 0x37
     e42:	98 ad       	ldd	r25, Y+56	; 0x38
     e44:	20 e0       	ldi	r18, 0x00	; 0
     e46:	30 e0       	ldi	r19, 0x00	; 0
     e48:	40 e2       	ldi	r20, 0x20	; 32
     e4a:	51 e4       	ldi	r21, 0x41	; 65
     e4c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     e50:	dc 01       	movw	r26, r24
     e52:	cb 01       	movw	r24, r22
     e54:	bc 01       	movw	r22, r24
     e56:	cd 01       	movw	r24, r26
     e58:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e5c:	dc 01       	movw	r26, r24
     e5e:	cb 01       	movw	r24, r22
     e60:	98 ab       	std	Y+48, r25	; 0x30
     e62:	8f a7       	std	Y+47, r24	; 0x2f
     e64:	0f c0       	rjmp	.+30     	; 0xe84 <CLCD_voidInit+0xc6>
     e66:	88 ec       	ldi	r24, 0xC8	; 200
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	9e a7       	std	Y+46, r25	; 0x2e
     e6c:	8d a7       	std	Y+45, r24	; 0x2d
     e6e:	8d a5       	ldd	r24, Y+45	; 0x2d
     e70:	9e a5       	ldd	r25, Y+46	; 0x2e
     e72:	01 97       	sbiw	r24, 0x01	; 1
     e74:	f1 f7       	brne	.-4      	; 0xe72 <CLCD_voidInit+0xb4>
     e76:	9e a7       	std	Y+46, r25	; 0x2e
     e78:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     e7a:	8f a5       	ldd	r24, Y+47	; 0x2f
     e7c:	98 a9       	ldd	r25, Y+48	; 0x30
     e7e:	01 97       	sbiw	r24, 0x01	; 1
     e80:	98 ab       	std	Y+48, r25	; 0x30
     e82:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     e84:	8f a5       	ldd	r24, Y+47	; 0x2f
     e86:	98 a9       	ldd	r25, Y+48	; 0x30
     e88:	00 97       	sbiw	r24, 0x00	; 0
     e8a:	69 f7       	brne	.-38     	; 0xe66 <CLCD_voidInit+0xa8>
     e8c:	14 c0       	rjmp	.+40     	; 0xeb6 <CLCD_voidInit+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     e8e:	69 a9       	ldd	r22, Y+49	; 0x31
     e90:	7a a9       	ldd	r23, Y+50	; 0x32
     e92:	8b a9       	ldd	r24, Y+51	; 0x33
     e94:	9c a9       	ldd	r25, Y+52	; 0x34
     e96:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e9a:	dc 01       	movw	r26, r24
     e9c:	cb 01       	movw	r24, r22
     e9e:	98 ab       	std	Y+48, r25	; 0x30
     ea0:	8f a7       	std	Y+47, r24	; 0x2f
     ea2:	8f a5       	ldd	r24, Y+47	; 0x2f
     ea4:	98 a9       	ldd	r25, Y+48	; 0x30
     ea6:	9c a7       	std	Y+44, r25	; 0x2c
     ea8:	8b a7       	std	Y+43, r24	; 0x2b
     eaa:	8b a5       	ldd	r24, Y+43	; 0x2b
     eac:	9c a5       	ldd	r25, Y+44	; 0x2c
     eae:	01 97       	sbiw	r24, 0x01	; 1
     eb0:	f1 f7       	brne	.-4      	; 0xeae <CLCD_voidInit+0xf0>
     eb2:	9c a7       	std	Y+44, r25	; 0x2c
     eb4:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(40);
	CLCD_voidSendCmd(0b00111000);
     eb6:	88 e3       	ldi	r24, 0x38	; 56
     eb8:	0e 94 41 06 	call	0xc82	; 0xc82 <CLCD_voidSendCmd>
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	90 e0       	ldi	r25, 0x00	; 0
     ec0:	a0 e8       	ldi	r26, 0x80	; 128
     ec2:	bf e3       	ldi	r27, 0x3F	; 63
     ec4:	8f a3       	std	Y+39, r24	; 0x27
     ec6:	98 a7       	std	Y+40, r25	; 0x28
     ec8:	a9 a7       	std	Y+41, r26	; 0x29
     eca:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     ecc:	6f a1       	ldd	r22, Y+39	; 0x27
     ece:	78 a5       	ldd	r23, Y+40	; 0x28
     ed0:	89 a5       	ldd	r24, Y+41	; 0x29
     ed2:	9a a5       	ldd	r25, Y+42	; 0x2a
     ed4:	20 e0       	ldi	r18, 0x00	; 0
     ed6:	30 e0       	ldi	r19, 0x00	; 0
     ed8:	4a ef       	ldi	r20, 0xFA	; 250
     eda:	54 e4       	ldi	r21, 0x44	; 68
     edc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ee0:	dc 01       	movw	r26, r24
     ee2:	cb 01       	movw	r24, r22
     ee4:	8b a3       	std	Y+35, r24	; 0x23
     ee6:	9c a3       	std	Y+36, r25	; 0x24
     ee8:	ad a3       	std	Y+37, r26	; 0x25
     eea:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
     eec:	6b a1       	ldd	r22, Y+35	; 0x23
     eee:	7c a1       	ldd	r23, Y+36	; 0x24
     ef0:	8d a1       	ldd	r24, Y+37	; 0x25
     ef2:	9e a1       	ldd	r25, Y+38	; 0x26
     ef4:	20 e0       	ldi	r18, 0x00	; 0
     ef6:	30 e0       	ldi	r19, 0x00	; 0
     ef8:	40 e8       	ldi	r20, 0x80	; 128
     efa:	5f e3       	ldi	r21, 0x3F	; 63
     efc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     f00:	88 23       	and	r24, r24
     f02:	2c f4       	brge	.+10     	; 0xf0e <CLCD_voidInit+0x150>
		__ticks = 1;
     f04:	81 e0       	ldi	r24, 0x01	; 1
     f06:	90 e0       	ldi	r25, 0x00	; 0
     f08:	9a a3       	std	Y+34, r25	; 0x22
     f0a:	89 a3       	std	Y+33, r24	; 0x21
     f0c:	3f c0       	rjmp	.+126    	; 0xf8c <CLCD_voidInit+0x1ce>
	else if (__tmp > 65535)
     f0e:	6b a1       	ldd	r22, Y+35	; 0x23
     f10:	7c a1       	ldd	r23, Y+36	; 0x24
     f12:	8d a1       	ldd	r24, Y+37	; 0x25
     f14:	9e a1       	ldd	r25, Y+38	; 0x26
     f16:	20 e0       	ldi	r18, 0x00	; 0
     f18:	3f ef       	ldi	r19, 0xFF	; 255
     f1a:	4f e7       	ldi	r20, 0x7F	; 127
     f1c:	57 e4       	ldi	r21, 0x47	; 71
     f1e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     f22:	18 16       	cp	r1, r24
     f24:	4c f5       	brge	.+82     	; 0xf78 <CLCD_voidInit+0x1ba>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f26:	6f a1       	ldd	r22, Y+39	; 0x27
     f28:	78 a5       	ldd	r23, Y+40	; 0x28
     f2a:	89 a5       	ldd	r24, Y+41	; 0x29
     f2c:	9a a5       	ldd	r25, Y+42	; 0x2a
     f2e:	20 e0       	ldi	r18, 0x00	; 0
     f30:	30 e0       	ldi	r19, 0x00	; 0
     f32:	40 e2       	ldi	r20, 0x20	; 32
     f34:	51 e4       	ldi	r21, 0x41	; 65
     f36:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     f3a:	dc 01       	movw	r26, r24
     f3c:	cb 01       	movw	r24, r22
     f3e:	bc 01       	movw	r22, r24
     f40:	cd 01       	movw	r24, r26
     f42:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f46:	dc 01       	movw	r26, r24
     f48:	cb 01       	movw	r24, r22
     f4a:	9a a3       	std	Y+34, r25	; 0x22
     f4c:	89 a3       	std	Y+33, r24	; 0x21
     f4e:	0f c0       	rjmp	.+30     	; 0xf6e <CLCD_voidInit+0x1b0>
     f50:	88 ec       	ldi	r24, 0xC8	; 200
     f52:	90 e0       	ldi	r25, 0x00	; 0
     f54:	98 a3       	std	Y+32, r25	; 0x20
     f56:	8f 8f       	std	Y+31, r24	; 0x1f
     f58:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f5a:	98 a1       	ldd	r25, Y+32	; 0x20
     f5c:	01 97       	sbiw	r24, 0x01	; 1
     f5e:	f1 f7       	brne	.-4      	; 0xf5c <CLCD_voidInit+0x19e>
     f60:	98 a3       	std	Y+32, r25	; 0x20
     f62:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f64:	89 a1       	ldd	r24, Y+33	; 0x21
     f66:	9a a1       	ldd	r25, Y+34	; 0x22
     f68:	01 97       	sbiw	r24, 0x01	; 1
     f6a:	9a a3       	std	Y+34, r25	; 0x22
     f6c:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f6e:	89 a1       	ldd	r24, Y+33	; 0x21
     f70:	9a a1       	ldd	r25, Y+34	; 0x22
     f72:	00 97       	sbiw	r24, 0x00	; 0
     f74:	69 f7       	brne	.-38     	; 0xf50 <CLCD_voidInit+0x192>
     f76:	14 c0       	rjmp	.+40     	; 0xfa0 <CLCD_voidInit+0x1e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f78:	6b a1       	ldd	r22, Y+35	; 0x23
     f7a:	7c a1       	ldd	r23, Y+36	; 0x24
     f7c:	8d a1       	ldd	r24, Y+37	; 0x25
     f7e:	9e a1       	ldd	r25, Y+38	; 0x26
     f80:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f84:	dc 01       	movw	r26, r24
     f86:	cb 01       	movw	r24, r22
     f88:	9a a3       	std	Y+34, r25	; 0x22
     f8a:	89 a3       	std	Y+33, r24	; 0x21
     f8c:	89 a1       	ldd	r24, Y+33	; 0x21
     f8e:	9a a1       	ldd	r25, Y+34	; 0x22
     f90:	9e 8f       	std	Y+30, r25	; 0x1e
     f92:	8d 8f       	std	Y+29, r24	; 0x1d
     f94:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f96:	9e 8d       	ldd	r25, Y+30	; 0x1e
     f98:	01 97       	sbiw	r24, 0x01	; 1
     f9a:	f1 f7       	brne	.-4      	; 0xf98 <CLCD_voidInit+0x1da>
     f9c:	9e 8f       	std	Y+30, r25	; 0x1e
     f9e:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
		CLCD_voidSendCmd(0b00001100);
     fa0:	8c e0       	ldi	r24, 0x0C	; 12
     fa2:	0e 94 41 06 	call	0xc82	; 0xc82 <CLCD_voidSendCmd>
     fa6:	80 e0       	ldi	r24, 0x00	; 0
     fa8:	90 e0       	ldi	r25, 0x00	; 0
     faa:	a0 e8       	ldi	r26, 0x80	; 128
     fac:	bf e3       	ldi	r27, 0x3F	; 63
     fae:	89 8f       	std	Y+25, r24	; 0x19
     fb0:	9a 8f       	std	Y+26, r25	; 0x1a
     fb2:	ab 8f       	std	Y+27, r26	; 0x1b
     fb4:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     fb6:	69 8d       	ldd	r22, Y+25	; 0x19
     fb8:	7a 8d       	ldd	r23, Y+26	; 0x1a
     fba:	8b 8d       	ldd	r24, Y+27	; 0x1b
     fbc:	9c 8d       	ldd	r25, Y+28	; 0x1c
     fbe:	20 e0       	ldi	r18, 0x00	; 0
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	4a ef       	ldi	r20, 0xFA	; 250
     fc4:	54 e4       	ldi	r21, 0x44	; 68
     fc6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     fca:	dc 01       	movw	r26, r24
     fcc:	cb 01       	movw	r24, r22
     fce:	8d 8b       	std	Y+21, r24	; 0x15
     fd0:	9e 8b       	std	Y+22, r25	; 0x16
     fd2:	af 8b       	std	Y+23, r26	; 0x17
     fd4:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     fd6:	6d 89       	ldd	r22, Y+21	; 0x15
     fd8:	7e 89       	ldd	r23, Y+22	; 0x16
     fda:	8f 89       	ldd	r24, Y+23	; 0x17
     fdc:	98 8d       	ldd	r25, Y+24	; 0x18
     fde:	20 e0       	ldi	r18, 0x00	; 0
     fe0:	30 e0       	ldi	r19, 0x00	; 0
     fe2:	40 e8       	ldi	r20, 0x80	; 128
     fe4:	5f e3       	ldi	r21, 0x3F	; 63
     fe6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     fea:	88 23       	and	r24, r24
     fec:	2c f4       	brge	.+10     	; 0xff8 <CLCD_voidInit+0x23a>
		__ticks = 1;
     fee:	81 e0       	ldi	r24, 0x01	; 1
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	9c 8b       	std	Y+20, r25	; 0x14
     ff4:	8b 8b       	std	Y+19, r24	; 0x13
     ff6:	3f c0       	rjmp	.+126    	; 0x1076 <CLCD_voidInit+0x2b8>
	else if (__tmp > 65535)
     ff8:	6d 89       	ldd	r22, Y+21	; 0x15
     ffa:	7e 89       	ldd	r23, Y+22	; 0x16
     ffc:	8f 89       	ldd	r24, Y+23	; 0x17
     ffe:	98 8d       	ldd	r25, Y+24	; 0x18
    1000:	20 e0       	ldi	r18, 0x00	; 0
    1002:	3f ef       	ldi	r19, 0xFF	; 255
    1004:	4f e7       	ldi	r20, 0x7F	; 127
    1006:	57 e4       	ldi	r21, 0x47	; 71
    1008:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    100c:	18 16       	cp	r1, r24
    100e:	4c f5       	brge	.+82     	; 0x1062 <CLCD_voidInit+0x2a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1010:	69 8d       	ldd	r22, Y+25	; 0x19
    1012:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1014:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1016:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1018:	20 e0       	ldi	r18, 0x00	; 0
    101a:	30 e0       	ldi	r19, 0x00	; 0
    101c:	40 e2       	ldi	r20, 0x20	; 32
    101e:	51 e4       	ldi	r21, 0x41	; 65
    1020:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1024:	dc 01       	movw	r26, r24
    1026:	cb 01       	movw	r24, r22
    1028:	bc 01       	movw	r22, r24
    102a:	cd 01       	movw	r24, r26
    102c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1030:	dc 01       	movw	r26, r24
    1032:	cb 01       	movw	r24, r22
    1034:	9c 8b       	std	Y+20, r25	; 0x14
    1036:	8b 8b       	std	Y+19, r24	; 0x13
    1038:	0f c0       	rjmp	.+30     	; 0x1058 <CLCD_voidInit+0x29a>
    103a:	88 ec       	ldi	r24, 0xC8	; 200
    103c:	90 e0       	ldi	r25, 0x00	; 0
    103e:	9a 8b       	std	Y+18, r25	; 0x12
    1040:	89 8b       	std	Y+17, r24	; 0x11
    1042:	89 89       	ldd	r24, Y+17	; 0x11
    1044:	9a 89       	ldd	r25, Y+18	; 0x12
    1046:	01 97       	sbiw	r24, 0x01	; 1
    1048:	f1 f7       	brne	.-4      	; 0x1046 <CLCD_voidInit+0x288>
    104a:	9a 8b       	std	Y+18, r25	; 0x12
    104c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    104e:	8b 89       	ldd	r24, Y+19	; 0x13
    1050:	9c 89       	ldd	r25, Y+20	; 0x14
    1052:	01 97       	sbiw	r24, 0x01	; 1
    1054:	9c 8b       	std	Y+20, r25	; 0x14
    1056:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1058:	8b 89       	ldd	r24, Y+19	; 0x13
    105a:	9c 89       	ldd	r25, Y+20	; 0x14
    105c:	00 97       	sbiw	r24, 0x00	; 0
    105e:	69 f7       	brne	.-38     	; 0x103a <CLCD_voidInit+0x27c>
    1060:	14 c0       	rjmp	.+40     	; 0x108a <CLCD_voidInit+0x2cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1062:	6d 89       	ldd	r22, Y+21	; 0x15
    1064:	7e 89       	ldd	r23, Y+22	; 0x16
    1066:	8f 89       	ldd	r24, Y+23	; 0x17
    1068:	98 8d       	ldd	r25, Y+24	; 0x18
    106a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    106e:	dc 01       	movw	r26, r24
    1070:	cb 01       	movw	r24, r22
    1072:	9c 8b       	std	Y+20, r25	; 0x14
    1074:	8b 8b       	std	Y+19, r24	; 0x13
    1076:	8b 89       	ldd	r24, Y+19	; 0x13
    1078:	9c 89       	ldd	r25, Y+20	; 0x14
    107a:	98 8b       	std	Y+16, r25	; 0x10
    107c:	8f 87       	std	Y+15, r24	; 0x0f
    107e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1080:	98 89       	ldd	r25, Y+16	; 0x10
    1082:	01 97       	sbiw	r24, 0x01	; 1
    1084:	f1 f7       	brne	.-4      	; 0x1082 <CLCD_voidInit+0x2c4>
    1086:	98 8b       	std	Y+16, r25	; 0x10
    1088:	8f 87       	std	Y+15, r24	; 0x0f
		_delay_ms(1);
			CLCD_voidSendCmd(1);
    108a:	81 e0       	ldi	r24, 0x01	; 1
    108c:	0e 94 41 06 	call	0xc82	; 0xc82 <CLCD_voidSendCmd>
    1090:	80 e0       	ldi	r24, 0x00	; 0
    1092:	90 e0       	ldi	r25, 0x00	; 0
    1094:	a0 e0       	ldi	r26, 0x00	; 0
    1096:	b0 e4       	ldi	r27, 0x40	; 64
    1098:	8b 87       	std	Y+11, r24	; 0x0b
    109a:	9c 87       	std	Y+12, r25	; 0x0c
    109c:	ad 87       	std	Y+13, r26	; 0x0d
    109e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    10a0:	6b 85       	ldd	r22, Y+11	; 0x0b
    10a2:	7c 85       	ldd	r23, Y+12	; 0x0c
    10a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    10a6:	9e 85       	ldd	r25, Y+14	; 0x0e
    10a8:	20 e0       	ldi	r18, 0x00	; 0
    10aa:	30 e0       	ldi	r19, 0x00	; 0
    10ac:	4a ef       	ldi	r20, 0xFA	; 250
    10ae:	54 e4       	ldi	r21, 0x44	; 68
    10b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    10b4:	dc 01       	movw	r26, r24
    10b6:	cb 01       	movw	r24, r22
    10b8:	8f 83       	std	Y+7, r24	; 0x07
    10ba:	98 87       	std	Y+8, r25	; 0x08
    10bc:	a9 87       	std	Y+9, r26	; 0x09
    10be:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    10c0:	6f 81       	ldd	r22, Y+7	; 0x07
    10c2:	78 85       	ldd	r23, Y+8	; 0x08
    10c4:	89 85       	ldd	r24, Y+9	; 0x09
    10c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    10c8:	20 e0       	ldi	r18, 0x00	; 0
    10ca:	30 e0       	ldi	r19, 0x00	; 0
    10cc:	40 e8       	ldi	r20, 0x80	; 128
    10ce:	5f e3       	ldi	r21, 0x3F	; 63
    10d0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    10d4:	88 23       	and	r24, r24
    10d6:	2c f4       	brge	.+10     	; 0x10e2 <CLCD_voidInit+0x324>
		__ticks = 1;
    10d8:	81 e0       	ldi	r24, 0x01	; 1
    10da:	90 e0       	ldi	r25, 0x00	; 0
    10dc:	9e 83       	std	Y+6, r25	; 0x06
    10de:	8d 83       	std	Y+5, r24	; 0x05
    10e0:	3f c0       	rjmp	.+126    	; 0x1160 <CLCD_voidInit+0x3a2>
	else if (__tmp > 65535)
    10e2:	6f 81       	ldd	r22, Y+7	; 0x07
    10e4:	78 85       	ldd	r23, Y+8	; 0x08
    10e6:	89 85       	ldd	r24, Y+9	; 0x09
    10e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    10ea:	20 e0       	ldi	r18, 0x00	; 0
    10ec:	3f ef       	ldi	r19, 0xFF	; 255
    10ee:	4f e7       	ldi	r20, 0x7F	; 127
    10f0:	57 e4       	ldi	r21, 0x47	; 71
    10f2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    10f6:	18 16       	cp	r1, r24
    10f8:	4c f5       	brge	.+82     	; 0x114c <CLCD_voidInit+0x38e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    10fa:	6b 85       	ldd	r22, Y+11	; 0x0b
    10fc:	7c 85       	ldd	r23, Y+12	; 0x0c
    10fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1100:	9e 85       	ldd	r25, Y+14	; 0x0e
    1102:	20 e0       	ldi	r18, 0x00	; 0
    1104:	30 e0       	ldi	r19, 0x00	; 0
    1106:	40 e2       	ldi	r20, 0x20	; 32
    1108:	51 e4       	ldi	r21, 0x41	; 65
    110a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    110e:	dc 01       	movw	r26, r24
    1110:	cb 01       	movw	r24, r22
    1112:	bc 01       	movw	r22, r24
    1114:	cd 01       	movw	r24, r26
    1116:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    111a:	dc 01       	movw	r26, r24
    111c:	cb 01       	movw	r24, r22
    111e:	9e 83       	std	Y+6, r25	; 0x06
    1120:	8d 83       	std	Y+5, r24	; 0x05
    1122:	0f c0       	rjmp	.+30     	; 0x1142 <CLCD_voidInit+0x384>
    1124:	88 ec       	ldi	r24, 0xC8	; 200
    1126:	90 e0       	ldi	r25, 0x00	; 0
    1128:	9c 83       	std	Y+4, r25	; 0x04
    112a:	8b 83       	std	Y+3, r24	; 0x03
    112c:	8b 81       	ldd	r24, Y+3	; 0x03
    112e:	9c 81       	ldd	r25, Y+4	; 0x04
    1130:	01 97       	sbiw	r24, 0x01	; 1
    1132:	f1 f7       	brne	.-4      	; 0x1130 <CLCD_voidInit+0x372>
    1134:	9c 83       	std	Y+4, r25	; 0x04
    1136:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1138:	8d 81       	ldd	r24, Y+5	; 0x05
    113a:	9e 81       	ldd	r25, Y+6	; 0x06
    113c:	01 97       	sbiw	r24, 0x01	; 1
    113e:	9e 83       	std	Y+6, r25	; 0x06
    1140:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1142:	8d 81       	ldd	r24, Y+5	; 0x05
    1144:	9e 81       	ldd	r25, Y+6	; 0x06
    1146:	00 97       	sbiw	r24, 0x00	; 0
    1148:	69 f7       	brne	.-38     	; 0x1124 <CLCD_voidInit+0x366>
    114a:	14 c0       	rjmp	.+40     	; 0x1174 <CLCD_voidInit+0x3b6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    114c:	6f 81       	ldd	r22, Y+7	; 0x07
    114e:	78 85       	ldd	r23, Y+8	; 0x08
    1150:	89 85       	ldd	r24, Y+9	; 0x09
    1152:	9a 85       	ldd	r25, Y+10	; 0x0a
    1154:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1158:	dc 01       	movw	r26, r24
    115a:	cb 01       	movw	r24, r22
    115c:	9e 83       	std	Y+6, r25	; 0x06
    115e:	8d 83       	std	Y+5, r24	; 0x05
    1160:	8d 81       	ldd	r24, Y+5	; 0x05
    1162:	9e 81       	ldd	r25, Y+6	; 0x06
    1164:	9a 83       	std	Y+2, r25	; 0x02
    1166:	89 83       	std	Y+1, r24	; 0x01
    1168:	89 81       	ldd	r24, Y+1	; 0x01
    116a:	9a 81       	ldd	r25, Y+2	; 0x02
    116c:	01 97       	sbiw	r24, 0x01	; 1
    116e:	f1 f7       	brne	.-4      	; 0x116c <CLCD_voidInit+0x3ae>
    1170:	9a 83       	std	Y+2, r25	; 0x02
    1172:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(2);



}
    1174:	e8 96       	adiw	r28, 0x38	; 56
    1176:	0f b6       	in	r0, 0x3f	; 63
    1178:	f8 94       	cli
    117a:	de bf       	out	0x3e, r29	; 62
    117c:	0f be       	out	0x3f, r0	; 63
    117e:	cd bf       	out	0x3d, r28	; 61
    1180:	cf 91       	pop	r28
    1182:	df 91       	pop	r29
    1184:	08 95       	ret

00001186 <CLCD_voidSendString>:
void CLCD_voidSendString(const char *PcString ){
    1186:	df 93       	push	r29
    1188:	cf 93       	push	r28
    118a:	00 d0       	rcall	.+0      	; 0x118c <CLCD_voidSendString+0x6>
    118c:	0f 92       	push	r0
    118e:	cd b7       	in	r28, 0x3d	; 61
    1190:	de b7       	in	r29, 0x3e	; 62
    1192:	9b 83       	std	Y+3, r25	; 0x03
    1194:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_iterator=0;
    1196:	19 82       	std	Y+1, r1	; 0x01
    1198:	0e c0       	rjmp	.+28     	; 0x11b6 <CLCD_voidSendString+0x30>
	while(PcString[Local_iterator]!='\0'){
		CLCD_voidSendData(PcString[Local_iterator]);
    119a:	89 81       	ldd	r24, Y+1	; 0x01
    119c:	28 2f       	mov	r18, r24
    119e:	30 e0       	ldi	r19, 0x00	; 0
    11a0:	8a 81       	ldd	r24, Y+2	; 0x02
    11a2:	9b 81       	ldd	r25, Y+3	; 0x03
    11a4:	fc 01       	movw	r30, r24
    11a6:	e2 0f       	add	r30, r18
    11a8:	f3 1f       	adc	r31, r19
    11aa:	80 81       	ld	r24, Z
    11ac:	0e 94 a3 05 	call	0xb46	; 0xb46 <CLCD_voidSendData>
		Local_iterator++;
    11b0:	89 81       	ldd	r24, Y+1	; 0x01
    11b2:	8f 5f       	subi	r24, 0xFF	; 255
    11b4:	89 83       	std	Y+1, r24	; 0x01


}
void CLCD_voidSendString(const char *PcString ){
	u8 Local_iterator=0;
	while(PcString[Local_iterator]!='\0'){
    11b6:	89 81       	ldd	r24, Y+1	; 0x01
    11b8:	28 2f       	mov	r18, r24
    11ba:	30 e0       	ldi	r19, 0x00	; 0
    11bc:	8a 81       	ldd	r24, Y+2	; 0x02
    11be:	9b 81       	ldd	r25, Y+3	; 0x03
    11c0:	fc 01       	movw	r30, r24
    11c2:	e2 0f       	add	r30, r18
    11c4:	f3 1f       	adc	r31, r19
    11c6:	80 81       	ld	r24, Z
    11c8:	88 23       	and	r24, r24
    11ca:	39 f7       	brne	.-50     	; 0x119a <CLCD_voidSendString+0x14>


	}


}
    11cc:	0f 90       	pop	r0
    11ce:	0f 90       	pop	r0
    11d0:	0f 90       	pop	r0
    11d2:	cf 91       	pop	r28
    11d4:	df 91       	pop	r29
    11d6:	08 95       	ret

000011d8 <CLCD_voidSitPosition>:
void CLCD_voidSitPosition(u8 Copy_u8x,u8 Copy_u8y ){
    11d8:	df 93       	push	r29
    11da:	cf 93       	push	r28
    11dc:	00 d0       	rcall	.+0      	; 0x11de <CLCD_voidSitPosition+0x6>
    11de:	00 d0       	rcall	.+0      	; 0x11e0 <CLCD_voidSitPosition+0x8>
    11e0:	0f 92       	push	r0
    11e2:	cd b7       	in	r28, 0x3d	; 61
    11e4:	de b7       	in	r29, 0x3e	; 62
    11e6:	8a 83       	std	Y+2, r24	; 0x02
    11e8:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8Position;
	switch(Copy_u8x){
    11ea:	8a 81       	ldd	r24, Y+2	; 0x02
    11ec:	28 2f       	mov	r18, r24
    11ee:	30 e0       	ldi	r19, 0x00	; 0
    11f0:	3d 83       	std	Y+5, r19	; 0x05
    11f2:	2c 83       	std	Y+4, r18	; 0x04
    11f4:	8c 81       	ldd	r24, Y+4	; 0x04
    11f6:	9d 81       	ldd	r25, Y+5	; 0x05
    11f8:	00 97       	sbiw	r24, 0x00	; 0
    11fa:	31 f0       	breq	.+12     	; 0x1208 <CLCD_voidSitPosition+0x30>
    11fc:	2c 81       	ldd	r18, Y+4	; 0x04
    11fe:	3d 81       	ldd	r19, Y+5	; 0x05
    1200:	21 30       	cpi	r18, 0x01	; 1
    1202:	31 05       	cpc	r19, r1
    1204:	21 f0       	breq	.+8      	; 0x120e <CLCD_voidSitPosition+0x36>
    1206:	06 c0       	rjmp	.+12     	; 0x1214 <CLCD_voidSitPosition+0x3c>
	case 0:Local_u8Position=Copy_u8y;break;
    1208:	8b 81       	ldd	r24, Y+3	; 0x03
    120a:	89 83       	std	Y+1, r24	; 0x01
    120c:	03 c0       	rjmp	.+6      	; 0x1214 <CLCD_voidSitPosition+0x3c>
	case 1:Local_u8Position=Copy_u8y+LINE1_BASE;break;
    120e:	8b 81       	ldd	r24, Y+3	; 0x03
    1210:	80 5c       	subi	r24, 0xC0	; 192
    1212:	89 83       	std	Y+1, r24	; 0x01


	}
	CLCD_voidSendCmd(Local_u8Position+MSB);
    1214:	89 81       	ldd	r24, Y+1	; 0x01
    1216:	80 58       	subi	r24, 0x80	; 128
    1218:	0e 94 41 06 	call	0xc82	; 0xc82 <CLCD_voidSendCmd>
}
    121c:	0f 90       	pop	r0
    121e:	0f 90       	pop	r0
    1220:	0f 90       	pop	r0
    1222:	0f 90       	pop	r0
    1224:	0f 90       	pop	r0
    1226:	cf 91       	pop	r28
    1228:	df 91       	pop	r29
    122a:	08 95       	ret

0000122c <CLCD_voidSendSpecialChar>:

void CLCD_voidSendSpecialChar(u8 *Pu8_arr,u8 Copy_u8BlockNum, u8 Copy_u8x,u8 Copy_u8y){
    122c:	df 93       	push	r29
    122e:	cf 93       	push	r28
    1230:	cd b7       	in	r28, 0x3d	; 61
    1232:	de b7       	in	r29, 0x3e	; 62
    1234:	27 97       	sbiw	r28, 0x07	; 7
    1236:	0f b6       	in	r0, 0x3f	; 63
    1238:	f8 94       	cli
    123a:	de bf       	out	0x3e, r29	; 62
    123c:	0f be       	out	0x3f, r0	; 63
    123e:	cd bf       	out	0x3d, r28	; 61
    1240:	9c 83       	std	Y+4, r25	; 0x04
    1242:	8b 83       	std	Y+3, r24	; 0x03
    1244:	6d 83       	std	Y+5, r22	; 0x05
    1246:	4e 83       	std	Y+6, r20	; 0x06
    1248:	2f 83       	std	Y+7, r18	; 0x07

	u8 Local_u8StartingAddress =Copy_u8BlockNum*8;
    124a:	8d 81       	ldd	r24, Y+5	; 0x05
    124c:	88 2f       	mov	r24, r24
    124e:	90 e0       	ldi	r25, 0x00	; 0
    1250:	88 0f       	add	r24, r24
    1252:	99 1f       	adc	r25, r25
    1254:	88 0f       	add	r24, r24
    1256:	99 1f       	adc	r25, r25
    1258:	88 0f       	add	r24, r24
    125a:	99 1f       	adc	r25, r25
    125c:	8a 83       	std	Y+2, r24	; 0x02
	CLCD_voidSendCmd(Local_u8StartingAddress+CGRAM_CONS);
    125e:	8a 81       	ldd	r24, Y+2	; 0x02
    1260:	80 5c       	subi	r24, 0xC0	; 192
    1262:	0e 94 41 06 	call	0xc82	; 0xc82 <CLCD_voidSendCmd>

	for(u8 Localu8Iterator=0;Localu8Iterator<8;Localu8Iterator++){
    1266:	19 82       	std	Y+1, r1	; 0x01
    1268:	0e c0       	rjmp	.+28     	; 0x1286 <CLCD_voidSendSpecialChar+0x5a>
		CLCD_voidSendData(Pu8_arr[Localu8Iterator]);
    126a:	89 81       	ldd	r24, Y+1	; 0x01
    126c:	28 2f       	mov	r18, r24
    126e:	30 e0       	ldi	r19, 0x00	; 0
    1270:	8b 81       	ldd	r24, Y+3	; 0x03
    1272:	9c 81       	ldd	r25, Y+4	; 0x04
    1274:	fc 01       	movw	r30, r24
    1276:	e2 0f       	add	r30, r18
    1278:	f3 1f       	adc	r31, r19
    127a:	80 81       	ld	r24, Z
    127c:	0e 94 a3 05 	call	0xb46	; 0xb46 <CLCD_voidSendData>
void CLCD_voidSendSpecialChar(u8 *Pu8_arr,u8 Copy_u8BlockNum, u8 Copy_u8x,u8 Copy_u8y){

	u8 Local_u8StartingAddress =Copy_u8BlockNum*8;
	CLCD_voidSendCmd(Local_u8StartingAddress+CGRAM_CONS);

	for(u8 Localu8Iterator=0;Localu8Iterator<8;Localu8Iterator++){
    1280:	89 81       	ldd	r24, Y+1	; 0x01
    1282:	8f 5f       	subi	r24, 0xFF	; 255
    1284:	89 83       	std	Y+1, r24	; 0x01
    1286:	89 81       	ldd	r24, Y+1	; 0x01
    1288:	88 30       	cpi	r24, 0x08	; 8
    128a:	78 f3       	brcs	.-34     	; 0x126a <CLCD_voidSendSpecialChar+0x3e>
		CLCD_voidSendData(Pu8_arr[Localu8Iterator]);
	}

	CLCD_voidSitPosition(Copy_u8x,Copy_u8y);
    128c:	8e 81       	ldd	r24, Y+6	; 0x06
    128e:	6f 81       	ldd	r22, Y+7	; 0x07
    1290:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>

	CLCD_voidSendData(Copy_u8BlockNum);
    1294:	8d 81       	ldd	r24, Y+5	; 0x05
    1296:	0e 94 a3 05 	call	0xb46	; 0xb46 <CLCD_voidSendData>


}
    129a:	27 96       	adiw	r28, 0x07	; 7
    129c:	0f b6       	in	r0, 0x3f	; 63
    129e:	f8 94       	cli
    12a0:	de bf       	out	0x3e, r29	; 62
    12a2:	0f be       	out	0x3f, r0	; 63
    12a4:	cd bf       	out	0x3d, r28	; 61
    12a6:	cf 91       	pop	r28
    12a8:	df 91       	pop	r29
    12aa:	08 95       	ret

000012ac <CLCD_voidClearDisplay>:

void CLCD_voidClearDisplay(void){
    12ac:	df 93       	push	r29
    12ae:	cf 93       	push	r28
    12b0:	cd b7       	in	r28, 0x3d	; 61
    12b2:	de b7       	in	r29, 0x3e	; 62

	CLCD_voidSendCmd(1);
    12b4:	81 e0       	ldi	r24, 0x01	; 1
    12b6:	0e 94 41 06 	call	0xc82	; 0xc82 <CLCD_voidSendCmd>
}
    12ba:	cf 91       	pop	r28
    12bc:	df 91       	pop	r29
    12be:	08 95       	ret

000012c0 <DIO_voidSetPortDirection>:




void DIO_voidSetPortDirection(u8 Copy_u8PortNum,u8 Copy_u8PortDir)
{
    12c0:	df 93       	push	r29
    12c2:	cf 93       	push	r28
    12c4:	00 d0       	rcall	.+0      	; 0x12c6 <DIO_voidSetPortDirection+0x6>
    12c6:	00 d0       	rcall	.+0      	; 0x12c8 <DIO_voidSetPortDirection+0x8>
    12c8:	cd b7       	in	r28, 0x3d	; 61
    12ca:	de b7       	in	r29, 0x3e	; 62
    12cc:	89 83       	std	Y+1, r24	; 0x01
    12ce:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8PortNum)
    12d0:	89 81       	ldd	r24, Y+1	; 0x01
    12d2:	28 2f       	mov	r18, r24
    12d4:	30 e0       	ldi	r19, 0x00	; 0
    12d6:	3c 83       	std	Y+4, r19	; 0x04
    12d8:	2b 83       	std	Y+3, r18	; 0x03
    12da:	8b 81       	ldd	r24, Y+3	; 0x03
    12dc:	9c 81       	ldd	r25, Y+4	; 0x04
    12de:	82 30       	cpi	r24, 0x02	; 2
    12e0:	91 05       	cpc	r25, r1
    12e2:	d9 f0       	breq	.+54     	; 0x131a <DIO_voidSetPortDirection+0x5a>
    12e4:	2b 81       	ldd	r18, Y+3	; 0x03
    12e6:	3c 81       	ldd	r19, Y+4	; 0x04
    12e8:	23 30       	cpi	r18, 0x03	; 3
    12ea:	31 05       	cpc	r19, r1
    12ec:	34 f4       	brge	.+12     	; 0x12fa <DIO_voidSetPortDirection+0x3a>
    12ee:	8b 81       	ldd	r24, Y+3	; 0x03
    12f0:	9c 81       	ldd	r25, Y+4	; 0x04
    12f2:	81 30       	cpi	r24, 0x01	; 1
    12f4:	91 05       	cpc	r25, r1
    12f6:	61 f0       	breq	.+24     	; 0x1310 <DIO_voidSetPortDirection+0x50>
    12f8:	1e c0       	rjmp	.+60     	; 0x1336 <DIO_voidSetPortDirection+0x76>
    12fa:	2b 81       	ldd	r18, Y+3	; 0x03
    12fc:	3c 81       	ldd	r19, Y+4	; 0x04
    12fe:	23 30       	cpi	r18, 0x03	; 3
    1300:	31 05       	cpc	r19, r1
    1302:	81 f0       	breq	.+32     	; 0x1324 <DIO_voidSetPortDirection+0x64>
    1304:	8b 81       	ldd	r24, Y+3	; 0x03
    1306:	9c 81       	ldd	r25, Y+4	; 0x04
    1308:	84 30       	cpi	r24, 0x04	; 4
    130a:	91 05       	cpc	r25, r1
    130c:	81 f0       	breq	.+32     	; 0x132e <DIO_voidSetPortDirection+0x6e>
    130e:	13 c0       	rjmp	.+38     	; 0x1336 <DIO_voidSetPortDirection+0x76>
	{
		case PORT_u8A : DDRA=Copy_u8PortDir;break;
    1310:	ea e3       	ldi	r30, 0x3A	; 58
    1312:	f0 e0       	ldi	r31, 0x00	; 0
    1314:	8a 81       	ldd	r24, Y+2	; 0x02
    1316:	80 83       	st	Z, r24
    1318:	0e c0       	rjmp	.+28     	; 0x1336 <DIO_voidSetPortDirection+0x76>
		case PORT_u8B : DDRB=Copy_u8PortDir;break;
    131a:	e7 e3       	ldi	r30, 0x37	; 55
    131c:	f0 e0       	ldi	r31, 0x00	; 0
    131e:	8a 81       	ldd	r24, Y+2	; 0x02
    1320:	80 83       	st	Z, r24
    1322:	09 c0       	rjmp	.+18     	; 0x1336 <DIO_voidSetPortDirection+0x76>
		case PORT_u8C : DDRC=Copy_u8PortDir;break;
    1324:	e4 e3       	ldi	r30, 0x34	; 52
    1326:	f0 e0       	ldi	r31, 0x00	; 0
    1328:	8a 81       	ldd	r24, Y+2	; 0x02
    132a:	80 83       	st	Z, r24
    132c:	04 c0       	rjmp	.+8      	; 0x1336 <DIO_voidSetPortDirection+0x76>
		case PORT_u8D : DDRD=Copy_u8PortDir;break;
    132e:	e1 e3       	ldi	r30, 0x31	; 49
    1330:	f0 e0       	ldi	r31, 0x00	; 0
    1332:	8a 81       	ldd	r24, Y+2	; 0x02
    1334:	80 83       	st	Z, r24
	}
	
}
    1336:	0f 90       	pop	r0
    1338:	0f 90       	pop	r0
    133a:	0f 90       	pop	r0
    133c:	0f 90       	pop	r0
    133e:	cf 91       	pop	r28
    1340:	df 91       	pop	r29
    1342:	08 95       	ret

00001344 <DIO_voidSetPortValue>:
void DIO_voidSetPortValue(u8 Copy_u8PortNum,u8 Copy_u8PortValue)
{
    1344:	df 93       	push	r29
    1346:	cf 93       	push	r28
    1348:	00 d0       	rcall	.+0      	; 0x134a <DIO_voidSetPortValue+0x6>
    134a:	00 d0       	rcall	.+0      	; 0x134c <DIO_voidSetPortValue+0x8>
    134c:	cd b7       	in	r28, 0x3d	; 61
    134e:	de b7       	in	r29, 0x3e	; 62
    1350:	89 83       	std	Y+1, r24	; 0x01
    1352:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8PortNum)
    1354:	89 81       	ldd	r24, Y+1	; 0x01
    1356:	28 2f       	mov	r18, r24
    1358:	30 e0       	ldi	r19, 0x00	; 0
    135a:	3c 83       	std	Y+4, r19	; 0x04
    135c:	2b 83       	std	Y+3, r18	; 0x03
    135e:	8b 81       	ldd	r24, Y+3	; 0x03
    1360:	9c 81       	ldd	r25, Y+4	; 0x04
    1362:	82 30       	cpi	r24, 0x02	; 2
    1364:	91 05       	cpc	r25, r1
    1366:	d9 f0       	breq	.+54     	; 0x139e <DIO_voidSetPortValue+0x5a>
    1368:	2b 81       	ldd	r18, Y+3	; 0x03
    136a:	3c 81       	ldd	r19, Y+4	; 0x04
    136c:	23 30       	cpi	r18, 0x03	; 3
    136e:	31 05       	cpc	r19, r1
    1370:	34 f4       	brge	.+12     	; 0x137e <DIO_voidSetPortValue+0x3a>
    1372:	8b 81       	ldd	r24, Y+3	; 0x03
    1374:	9c 81       	ldd	r25, Y+4	; 0x04
    1376:	81 30       	cpi	r24, 0x01	; 1
    1378:	91 05       	cpc	r25, r1
    137a:	61 f0       	breq	.+24     	; 0x1394 <DIO_voidSetPortValue+0x50>
    137c:	1e c0       	rjmp	.+60     	; 0x13ba <DIO_voidSetPortValue+0x76>
    137e:	2b 81       	ldd	r18, Y+3	; 0x03
    1380:	3c 81       	ldd	r19, Y+4	; 0x04
    1382:	23 30       	cpi	r18, 0x03	; 3
    1384:	31 05       	cpc	r19, r1
    1386:	81 f0       	breq	.+32     	; 0x13a8 <DIO_voidSetPortValue+0x64>
    1388:	8b 81       	ldd	r24, Y+3	; 0x03
    138a:	9c 81       	ldd	r25, Y+4	; 0x04
    138c:	84 30       	cpi	r24, 0x04	; 4
    138e:	91 05       	cpc	r25, r1
    1390:	81 f0       	breq	.+32     	; 0x13b2 <DIO_voidSetPortValue+0x6e>
    1392:	13 c0       	rjmp	.+38     	; 0x13ba <DIO_voidSetPortValue+0x76>
	{
		case PORT_u8A : PORTA=Copy_u8PortValue;break;
    1394:	eb e3       	ldi	r30, 0x3B	; 59
    1396:	f0 e0       	ldi	r31, 0x00	; 0
    1398:	8a 81       	ldd	r24, Y+2	; 0x02
    139a:	80 83       	st	Z, r24
    139c:	0e c0       	rjmp	.+28     	; 0x13ba <DIO_voidSetPortValue+0x76>
		case PORT_u8B : PORTB=Copy_u8PortValue;break;
    139e:	e8 e3       	ldi	r30, 0x38	; 56
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	8a 81       	ldd	r24, Y+2	; 0x02
    13a4:	80 83       	st	Z, r24
    13a6:	09 c0       	rjmp	.+18     	; 0x13ba <DIO_voidSetPortValue+0x76>
		case PORT_u8C : PORTC=Copy_u8PortValue;break;
    13a8:	e5 e3       	ldi	r30, 0x35	; 53
    13aa:	f0 e0       	ldi	r31, 0x00	; 0
    13ac:	8a 81       	ldd	r24, Y+2	; 0x02
    13ae:	80 83       	st	Z, r24
    13b0:	04 c0       	rjmp	.+8      	; 0x13ba <DIO_voidSetPortValue+0x76>
		case PORT_u8D : PORTD=Copy_u8PortValue;break;
    13b2:	e2 e3       	ldi	r30, 0x32	; 50
    13b4:	f0 e0       	ldi	r31, 0x00	; 0
    13b6:	8a 81       	ldd	r24, Y+2	; 0x02
    13b8:	80 83       	st	Z, r24
	}
}
    13ba:	0f 90       	pop	r0
    13bc:	0f 90       	pop	r0
    13be:	0f 90       	pop	r0
    13c0:	0f 90       	pop	r0
    13c2:	cf 91       	pop	r28
    13c4:	df 91       	pop	r29
    13c6:	08 95       	ret

000013c8 <DIO_voidSetPinDirection>:

void DIO_voidSetPinDirection(u8 Copy_u8PortNum,u8 Copy_u8PinNum,u8 Copy_u8PinDir)
{
    13c8:	df 93       	push	r29
    13ca:	cf 93       	push	r28
    13cc:	cd b7       	in	r28, 0x3d	; 61
    13ce:	de b7       	in	r29, 0x3e	; 62
    13d0:	27 97       	sbiw	r28, 0x07	; 7
    13d2:	0f b6       	in	r0, 0x3f	; 63
    13d4:	f8 94       	cli
    13d6:	de bf       	out	0x3e, r29	; 62
    13d8:	0f be       	out	0x3f, r0	; 63
    13da:	cd bf       	out	0x3d, r28	; 61
    13dc:	89 83       	std	Y+1, r24	; 0x01
    13de:	6a 83       	std	Y+2, r22	; 0x02
    13e0:	4b 83       	std	Y+3, r20	; 0x03
	if(Copy_u8PinNum <= MAX_PIN_NUM)
    13e2:	8a 81       	ldd	r24, Y+2	; 0x02
    13e4:	88 30       	cpi	r24, 0x08	; 8
    13e6:	08 f0       	brcs	.+2      	; 0x13ea <DIO_voidSetPinDirection+0x22>
    13e8:	ec c0       	rjmp	.+472    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
	{
		if(Copy_u8PinDir == PIN_OUT)
    13ea:	8b 81       	ldd	r24, Y+3	; 0x03
    13ec:	81 30       	cpi	r24, 0x01	; 1
    13ee:	09 f0       	breq	.+2      	; 0x13f2 <DIO_voidSetPinDirection+0x2a>
    13f0:	70 c0       	rjmp	.+224    	; 0x14d2 <DIO_voidSetPinDirection+0x10a>
		{
			switch(Copy_u8PortNum)
    13f2:	89 81       	ldd	r24, Y+1	; 0x01
    13f4:	28 2f       	mov	r18, r24
    13f6:	30 e0       	ldi	r19, 0x00	; 0
    13f8:	3f 83       	std	Y+7, r19	; 0x07
    13fa:	2e 83       	std	Y+6, r18	; 0x06
    13fc:	8e 81       	ldd	r24, Y+6	; 0x06
    13fe:	9f 81       	ldd	r25, Y+7	; 0x07
    1400:	82 30       	cpi	r24, 0x02	; 2
    1402:	91 05       	cpc	r25, r1
    1404:	51 f1       	breq	.+84     	; 0x145a <DIO_voidSetPinDirection+0x92>
    1406:	2e 81       	ldd	r18, Y+6	; 0x06
    1408:	3f 81       	ldd	r19, Y+7	; 0x07
    140a:	23 30       	cpi	r18, 0x03	; 3
    140c:	31 05       	cpc	r19, r1
    140e:	34 f4       	brge	.+12     	; 0x141c <DIO_voidSetPinDirection+0x54>
    1410:	8e 81       	ldd	r24, Y+6	; 0x06
    1412:	9f 81       	ldd	r25, Y+7	; 0x07
    1414:	81 30       	cpi	r24, 0x01	; 1
    1416:	91 05       	cpc	r25, r1
    1418:	61 f0       	breq	.+24     	; 0x1432 <DIO_voidSetPinDirection+0x6a>
    141a:	d3 c0       	rjmp	.+422    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
    141c:	2e 81       	ldd	r18, Y+6	; 0x06
    141e:	3f 81       	ldd	r19, Y+7	; 0x07
    1420:	23 30       	cpi	r18, 0x03	; 3
    1422:	31 05       	cpc	r19, r1
    1424:	71 f1       	breq	.+92     	; 0x1482 <DIO_voidSetPinDirection+0xba>
    1426:	8e 81       	ldd	r24, Y+6	; 0x06
    1428:	9f 81       	ldd	r25, Y+7	; 0x07
    142a:	84 30       	cpi	r24, 0x04	; 4
    142c:	91 05       	cpc	r25, r1
    142e:	e9 f1       	breq	.+122    	; 0x14aa <DIO_voidSetPinDirection+0xe2>
    1430:	c8 c0       	rjmp	.+400    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
			{
				case PORT_u8A:SET_BIT(DDRA,Copy_u8PinNum);break;
    1432:	aa e3       	ldi	r26, 0x3A	; 58
    1434:	b0 e0       	ldi	r27, 0x00	; 0
    1436:	ea e3       	ldi	r30, 0x3A	; 58
    1438:	f0 e0       	ldi	r31, 0x00	; 0
    143a:	80 81       	ld	r24, Z
    143c:	48 2f       	mov	r20, r24
    143e:	8a 81       	ldd	r24, Y+2	; 0x02
    1440:	28 2f       	mov	r18, r24
    1442:	30 e0       	ldi	r19, 0x00	; 0
    1444:	81 e0       	ldi	r24, 0x01	; 1
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	02 2e       	mov	r0, r18
    144a:	02 c0       	rjmp	.+4      	; 0x1450 <DIO_voidSetPinDirection+0x88>
    144c:	88 0f       	add	r24, r24
    144e:	99 1f       	adc	r25, r25
    1450:	0a 94       	dec	r0
    1452:	e2 f7       	brpl	.-8      	; 0x144c <DIO_voidSetPinDirection+0x84>
    1454:	84 2b       	or	r24, r20
    1456:	8c 93       	st	X, r24
    1458:	b4 c0       	rjmp	.+360    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
				case PORT_u8B:SET_BIT(DDRB,Copy_u8PinNum);break;
    145a:	a7 e3       	ldi	r26, 0x37	; 55
    145c:	b0 e0       	ldi	r27, 0x00	; 0
    145e:	e7 e3       	ldi	r30, 0x37	; 55
    1460:	f0 e0       	ldi	r31, 0x00	; 0
    1462:	80 81       	ld	r24, Z
    1464:	48 2f       	mov	r20, r24
    1466:	8a 81       	ldd	r24, Y+2	; 0x02
    1468:	28 2f       	mov	r18, r24
    146a:	30 e0       	ldi	r19, 0x00	; 0
    146c:	81 e0       	ldi	r24, 0x01	; 1
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	02 2e       	mov	r0, r18
    1472:	02 c0       	rjmp	.+4      	; 0x1478 <DIO_voidSetPinDirection+0xb0>
    1474:	88 0f       	add	r24, r24
    1476:	99 1f       	adc	r25, r25
    1478:	0a 94       	dec	r0
    147a:	e2 f7       	brpl	.-8      	; 0x1474 <DIO_voidSetPinDirection+0xac>
    147c:	84 2b       	or	r24, r20
    147e:	8c 93       	st	X, r24
    1480:	a0 c0       	rjmp	.+320    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
				case PORT_u8C:SET_BIT(DDRC,Copy_u8PinNum);break;
    1482:	a4 e3       	ldi	r26, 0x34	; 52
    1484:	b0 e0       	ldi	r27, 0x00	; 0
    1486:	e4 e3       	ldi	r30, 0x34	; 52
    1488:	f0 e0       	ldi	r31, 0x00	; 0
    148a:	80 81       	ld	r24, Z
    148c:	48 2f       	mov	r20, r24
    148e:	8a 81       	ldd	r24, Y+2	; 0x02
    1490:	28 2f       	mov	r18, r24
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	81 e0       	ldi	r24, 0x01	; 1
    1496:	90 e0       	ldi	r25, 0x00	; 0
    1498:	02 2e       	mov	r0, r18
    149a:	02 c0       	rjmp	.+4      	; 0x14a0 <DIO_voidSetPinDirection+0xd8>
    149c:	88 0f       	add	r24, r24
    149e:	99 1f       	adc	r25, r25
    14a0:	0a 94       	dec	r0
    14a2:	e2 f7       	brpl	.-8      	; 0x149c <DIO_voidSetPinDirection+0xd4>
    14a4:	84 2b       	or	r24, r20
    14a6:	8c 93       	st	X, r24
    14a8:	8c c0       	rjmp	.+280    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
				case PORT_u8D:SET_BIT(DDRD,Copy_u8PinNum);break;
    14aa:	a1 e3       	ldi	r26, 0x31	; 49
    14ac:	b0 e0       	ldi	r27, 0x00	; 0
    14ae:	e1 e3       	ldi	r30, 0x31	; 49
    14b0:	f0 e0       	ldi	r31, 0x00	; 0
    14b2:	80 81       	ld	r24, Z
    14b4:	48 2f       	mov	r20, r24
    14b6:	8a 81       	ldd	r24, Y+2	; 0x02
    14b8:	28 2f       	mov	r18, r24
    14ba:	30 e0       	ldi	r19, 0x00	; 0
    14bc:	81 e0       	ldi	r24, 0x01	; 1
    14be:	90 e0       	ldi	r25, 0x00	; 0
    14c0:	02 2e       	mov	r0, r18
    14c2:	02 c0       	rjmp	.+4      	; 0x14c8 <DIO_voidSetPinDirection+0x100>
    14c4:	88 0f       	add	r24, r24
    14c6:	99 1f       	adc	r25, r25
    14c8:	0a 94       	dec	r0
    14ca:	e2 f7       	brpl	.-8      	; 0x14c4 <DIO_voidSetPinDirection+0xfc>
    14cc:	84 2b       	or	r24, r20
    14ce:	8c 93       	st	X, r24
    14d0:	78 c0       	rjmp	.+240    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
			}
		}
		else if(Copy_u8PinDir == PIN_IN)
    14d2:	8b 81       	ldd	r24, Y+3	; 0x03
    14d4:	88 23       	and	r24, r24
    14d6:	09 f0       	breq	.+2      	; 0x14da <DIO_voidSetPinDirection+0x112>
    14d8:	74 c0       	rjmp	.+232    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
		{
			switch(Copy_u8PortNum)
    14da:	89 81       	ldd	r24, Y+1	; 0x01
    14dc:	28 2f       	mov	r18, r24
    14de:	30 e0       	ldi	r19, 0x00	; 0
    14e0:	3d 83       	std	Y+5, r19	; 0x05
    14e2:	2c 83       	std	Y+4, r18	; 0x04
    14e4:	8c 81       	ldd	r24, Y+4	; 0x04
    14e6:	9d 81       	ldd	r25, Y+5	; 0x05
    14e8:	82 30       	cpi	r24, 0x02	; 2
    14ea:	91 05       	cpc	r25, r1
    14ec:	61 f1       	breq	.+88     	; 0x1546 <DIO_voidSetPinDirection+0x17e>
    14ee:	2c 81       	ldd	r18, Y+4	; 0x04
    14f0:	3d 81       	ldd	r19, Y+5	; 0x05
    14f2:	23 30       	cpi	r18, 0x03	; 3
    14f4:	31 05       	cpc	r19, r1
    14f6:	34 f4       	brge	.+12     	; 0x1504 <DIO_voidSetPinDirection+0x13c>
    14f8:	8c 81       	ldd	r24, Y+4	; 0x04
    14fa:	9d 81       	ldd	r25, Y+5	; 0x05
    14fc:	81 30       	cpi	r24, 0x01	; 1
    14fe:	91 05       	cpc	r25, r1
    1500:	69 f0       	breq	.+26     	; 0x151c <DIO_voidSetPinDirection+0x154>
    1502:	5f c0       	rjmp	.+190    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
    1504:	2c 81       	ldd	r18, Y+4	; 0x04
    1506:	3d 81       	ldd	r19, Y+5	; 0x05
    1508:	23 30       	cpi	r18, 0x03	; 3
    150a:	31 05       	cpc	r19, r1
    150c:	89 f1       	breq	.+98     	; 0x1570 <DIO_voidSetPinDirection+0x1a8>
    150e:	8c 81       	ldd	r24, Y+4	; 0x04
    1510:	9d 81       	ldd	r25, Y+5	; 0x05
    1512:	84 30       	cpi	r24, 0x04	; 4
    1514:	91 05       	cpc	r25, r1
    1516:	09 f4       	brne	.+2      	; 0x151a <DIO_voidSetPinDirection+0x152>
    1518:	40 c0       	rjmp	.+128    	; 0x159a <DIO_voidSetPinDirection+0x1d2>
    151a:	53 c0       	rjmp	.+166    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
			{
				case PORT_u8A:CLR_BIT(DDRA,Copy_u8PinNum);break;
    151c:	aa e3       	ldi	r26, 0x3A	; 58
    151e:	b0 e0       	ldi	r27, 0x00	; 0
    1520:	ea e3       	ldi	r30, 0x3A	; 58
    1522:	f0 e0       	ldi	r31, 0x00	; 0
    1524:	80 81       	ld	r24, Z
    1526:	48 2f       	mov	r20, r24
    1528:	8a 81       	ldd	r24, Y+2	; 0x02
    152a:	28 2f       	mov	r18, r24
    152c:	30 e0       	ldi	r19, 0x00	; 0
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	02 2e       	mov	r0, r18
    1534:	02 c0       	rjmp	.+4      	; 0x153a <DIO_voidSetPinDirection+0x172>
    1536:	88 0f       	add	r24, r24
    1538:	99 1f       	adc	r25, r25
    153a:	0a 94       	dec	r0
    153c:	e2 f7       	brpl	.-8      	; 0x1536 <DIO_voidSetPinDirection+0x16e>
    153e:	80 95       	com	r24
    1540:	84 23       	and	r24, r20
    1542:	8c 93       	st	X, r24
    1544:	3e c0       	rjmp	.+124    	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
				case PORT_u8B:CLR_BIT(DDRB,Copy_u8PinNum);break;
    1546:	a7 e3       	ldi	r26, 0x37	; 55
    1548:	b0 e0       	ldi	r27, 0x00	; 0
    154a:	e7 e3       	ldi	r30, 0x37	; 55
    154c:	f0 e0       	ldi	r31, 0x00	; 0
    154e:	80 81       	ld	r24, Z
    1550:	48 2f       	mov	r20, r24
    1552:	8a 81       	ldd	r24, Y+2	; 0x02
    1554:	28 2f       	mov	r18, r24
    1556:	30 e0       	ldi	r19, 0x00	; 0
    1558:	81 e0       	ldi	r24, 0x01	; 1
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	02 2e       	mov	r0, r18
    155e:	02 c0       	rjmp	.+4      	; 0x1564 <DIO_voidSetPinDirection+0x19c>
    1560:	88 0f       	add	r24, r24
    1562:	99 1f       	adc	r25, r25
    1564:	0a 94       	dec	r0
    1566:	e2 f7       	brpl	.-8      	; 0x1560 <DIO_voidSetPinDirection+0x198>
    1568:	80 95       	com	r24
    156a:	84 23       	and	r24, r20
    156c:	8c 93       	st	X, r24
    156e:	29 c0       	rjmp	.+82     	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
				case PORT_u8C:CLR_BIT(DDRC,Copy_u8PinNum);break;
    1570:	a4 e3       	ldi	r26, 0x34	; 52
    1572:	b0 e0       	ldi	r27, 0x00	; 0
    1574:	e4 e3       	ldi	r30, 0x34	; 52
    1576:	f0 e0       	ldi	r31, 0x00	; 0
    1578:	80 81       	ld	r24, Z
    157a:	48 2f       	mov	r20, r24
    157c:	8a 81       	ldd	r24, Y+2	; 0x02
    157e:	28 2f       	mov	r18, r24
    1580:	30 e0       	ldi	r19, 0x00	; 0
    1582:	81 e0       	ldi	r24, 0x01	; 1
    1584:	90 e0       	ldi	r25, 0x00	; 0
    1586:	02 2e       	mov	r0, r18
    1588:	02 c0       	rjmp	.+4      	; 0x158e <DIO_voidSetPinDirection+0x1c6>
    158a:	88 0f       	add	r24, r24
    158c:	99 1f       	adc	r25, r25
    158e:	0a 94       	dec	r0
    1590:	e2 f7       	brpl	.-8      	; 0x158a <DIO_voidSetPinDirection+0x1c2>
    1592:	80 95       	com	r24
    1594:	84 23       	and	r24, r20
    1596:	8c 93       	st	X, r24
    1598:	14 c0       	rjmp	.+40     	; 0x15c2 <DIO_voidSetPinDirection+0x1fa>
				case PORT_u8D:CLR_BIT(DDRD,Copy_u8PinNum);break;
    159a:	a1 e3       	ldi	r26, 0x31	; 49
    159c:	b0 e0       	ldi	r27, 0x00	; 0
    159e:	e1 e3       	ldi	r30, 0x31	; 49
    15a0:	f0 e0       	ldi	r31, 0x00	; 0
    15a2:	80 81       	ld	r24, Z
    15a4:	48 2f       	mov	r20, r24
    15a6:	8a 81       	ldd	r24, Y+2	; 0x02
    15a8:	28 2f       	mov	r18, r24
    15aa:	30 e0       	ldi	r19, 0x00	; 0
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	90 e0       	ldi	r25, 0x00	; 0
    15b0:	02 2e       	mov	r0, r18
    15b2:	02 c0       	rjmp	.+4      	; 0x15b8 <DIO_voidSetPinDirection+0x1f0>
    15b4:	88 0f       	add	r24, r24
    15b6:	99 1f       	adc	r25, r25
    15b8:	0a 94       	dec	r0
    15ba:	e2 f7       	brpl	.-8      	; 0x15b4 <DIO_voidSetPinDirection+0x1ec>
    15bc:	80 95       	com	r24
    15be:	84 23       	and	r24, r20
    15c0:	8c 93       	st	X, r24
			}
		}
	}	
}
    15c2:	27 96       	adiw	r28, 0x07	; 7
    15c4:	0f b6       	in	r0, 0x3f	; 63
    15c6:	f8 94       	cli
    15c8:	de bf       	out	0x3e, r29	; 62
    15ca:	0f be       	out	0x3f, r0	; 63
    15cc:	cd bf       	out	0x3d, r28	; 61
    15ce:	cf 91       	pop	r28
    15d0:	df 91       	pop	r29
    15d2:	08 95       	ret

000015d4 <DIO_voidSetPinValue>:
void DIO_voidSetPinValue(u8 Copy_u8PortNum,u8 Copy_u8PinNum,u8 Copy_u8PinValue)
{
    15d4:	df 93       	push	r29
    15d6:	cf 93       	push	r28
    15d8:	cd b7       	in	r28, 0x3d	; 61
    15da:	de b7       	in	r29, 0x3e	; 62
    15dc:	27 97       	sbiw	r28, 0x07	; 7
    15de:	0f b6       	in	r0, 0x3f	; 63
    15e0:	f8 94       	cli
    15e2:	de bf       	out	0x3e, r29	; 62
    15e4:	0f be       	out	0x3f, r0	; 63
    15e6:	cd bf       	out	0x3d, r28	; 61
    15e8:	89 83       	std	Y+1, r24	; 0x01
    15ea:	6a 83       	std	Y+2, r22	; 0x02
    15ec:	4b 83       	std	Y+3, r20	; 0x03
	if(Copy_u8PinNum <= MAX_PIN_NUM)
    15ee:	8a 81       	ldd	r24, Y+2	; 0x02
    15f0:	88 30       	cpi	r24, 0x08	; 8
    15f2:	08 f0       	brcs	.+2      	; 0x15f6 <DIO_voidSetPinValue+0x22>
    15f4:	ec c0       	rjmp	.+472    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
	{
		if(Copy_u8PinValue == PIN_HIGH)
    15f6:	8b 81       	ldd	r24, Y+3	; 0x03
    15f8:	81 30       	cpi	r24, 0x01	; 1
    15fa:	09 f0       	breq	.+2      	; 0x15fe <DIO_voidSetPinValue+0x2a>
    15fc:	70 c0       	rjmp	.+224    	; 0x16de <DIO_voidSetPinValue+0x10a>
		{
			switch(Copy_u8PortNum)
    15fe:	89 81       	ldd	r24, Y+1	; 0x01
    1600:	28 2f       	mov	r18, r24
    1602:	30 e0       	ldi	r19, 0x00	; 0
    1604:	3f 83       	std	Y+7, r19	; 0x07
    1606:	2e 83       	std	Y+6, r18	; 0x06
    1608:	8e 81       	ldd	r24, Y+6	; 0x06
    160a:	9f 81       	ldd	r25, Y+7	; 0x07
    160c:	82 30       	cpi	r24, 0x02	; 2
    160e:	91 05       	cpc	r25, r1
    1610:	51 f1       	breq	.+84     	; 0x1666 <DIO_voidSetPinValue+0x92>
    1612:	2e 81       	ldd	r18, Y+6	; 0x06
    1614:	3f 81       	ldd	r19, Y+7	; 0x07
    1616:	23 30       	cpi	r18, 0x03	; 3
    1618:	31 05       	cpc	r19, r1
    161a:	34 f4       	brge	.+12     	; 0x1628 <DIO_voidSetPinValue+0x54>
    161c:	8e 81       	ldd	r24, Y+6	; 0x06
    161e:	9f 81       	ldd	r25, Y+7	; 0x07
    1620:	81 30       	cpi	r24, 0x01	; 1
    1622:	91 05       	cpc	r25, r1
    1624:	61 f0       	breq	.+24     	; 0x163e <DIO_voidSetPinValue+0x6a>
    1626:	d3 c0       	rjmp	.+422    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
    1628:	2e 81       	ldd	r18, Y+6	; 0x06
    162a:	3f 81       	ldd	r19, Y+7	; 0x07
    162c:	23 30       	cpi	r18, 0x03	; 3
    162e:	31 05       	cpc	r19, r1
    1630:	71 f1       	breq	.+92     	; 0x168e <DIO_voidSetPinValue+0xba>
    1632:	8e 81       	ldd	r24, Y+6	; 0x06
    1634:	9f 81       	ldd	r25, Y+7	; 0x07
    1636:	84 30       	cpi	r24, 0x04	; 4
    1638:	91 05       	cpc	r25, r1
    163a:	e9 f1       	breq	.+122    	; 0x16b6 <DIO_voidSetPinValue+0xe2>
    163c:	c8 c0       	rjmp	.+400    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
			{
				case PORT_u8A:SET_BIT(PORTA,Copy_u8PinNum);break;
    163e:	ab e3       	ldi	r26, 0x3B	; 59
    1640:	b0 e0       	ldi	r27, 0x00	; 0
    1642:	eb e3       	ldi	r30, 0x3B	; 59
    1644:	f0 e0       	ldi	r31, 0x00	; 0
    1646:	80 81       	ld	r24, Z
    1648:	48 2f       	mov	r20, r24
    164a:	8a 81       	ldd	r24, Y+2	; 0x02
    164c:	28 2f       	mov	r18, r24
    164e:	30 e0       	ldi	r19, 0x00	; 0
    1650:	81 e0       	ldi	r24, 0x01	; 1
    1652:	90 e0       	ldi	r25, 0x00	; 0
    1654:	02 2e       	mov	r0, r18
    1656:	02 c0       	rjmp	.+4      	; 0x165c <DIO_voidSetPinValue+0x88>
    1658:	88 0f       	add	r24, r24
    165a:	99 1f       	adc	r25, r25
    165c:	0a 94       	dec	r0
    165e:	e2 f7       	brpl	.-8      	; 0x1658 <DIO_voidSetPinValue+0x84>
    1660:	84 2b       	or	r24, r20
    1662:	8c 93       	st	X, r24
    1664:	b4 c0       	rjmp	.+360    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
				case PORT_u8B:SET_BIT(PORTB,Copy_u8PinNum);break;
    1666:	a8 e3       	ldi	r26, 0x38	; 56
    1668:	b0 e0       	ldi	r27, 0x00	; 0
    166a:	e8 e3       	ldi	r30, 0x38	; 56
    166c:	f0 e0       	ldi	r31, 0x00	; 0
    166e:	80 81       	ld	r24, Z
    1670:	48 2f       	mov	r20, r24
    1672:	8a 81       	ldd	r24, Y+2	; 0x02
    1674:	28 2f       	mov	r18, r24
    1676:	30 e0       	ldi	r19, 0x00	; 0
    1678:	81 e0       	ldi	r24, 0x01	; 1
    167a:	90 e0       	ldi	r25, 0x00	; 0
    167c:	02 2e       	mov	r0, r18
    167e:	02 c0       	rjmp	.+4      	; 0x1684 <DIO_voidSetPinValue+0xb0>
    1680:	88 0f       	add	r24, r24
    1682:	99 1f       	adc	r25, r25
    1684:	0a 94       	dec	r0
    1686:	e2 f7       	brpl	.-8      	; 0x1680 <DIO_voidSetPinValue+0xac>
    1688:	84 2b       	or	r24, r20
    168a:	8c 93       	st	X, r24
    168c:	a0 c0       	rjmp	.+320    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
				case PORT_u8C:SET_BIT(PORTC,Copy_u8PinNum);break;
    168e:	a5 e3       	ldi	r26, 0x35	; 53
    1690:	b0 e0       	ldi	r27, 0x00	; 0
    1692:	e5 e3       	ldi	r30, 0x35	; 53
    1694:	f0 e0       	ldi	r31, 0x00	; 0
    1696:	80 81       	ld	r24, Z
    1698:	48 2f       	mov	r20, r24
    169a:	8a 81       	ldd	r24, Y+2	; 0x02
    169c:	28 2f       	mov	r18, r24
    169e:	30 e0       	ldi	r19, 0x00	; 0
    16a0:	81 e0       	ldi	r24, 0x01	; 1
    16a2:	90 e0       	ldi	r25, 0x00	; 0
    16a4:	02 2e       	mov	r0, r18
    16a6:	02 c0       	rjmp	.+4      	; 0x16ac <DIO_voidSetPinValue+0xd8>
    16a8:	88 0f       	add	r24, r24
    16aa:	99 1f       	adc	r25, r25
    16ac:	0a 94       	dec	r0
    16ae:	e2 f7       	brpl	.-8      	; 0x16a8 <DIO_voidSetPinValue+0xd4>
    16b0:	84 2b       	or	r24, r20
    16b2:	8c 93       	st	X, r24
    16b4:	8c c0       	rjmp	.+280    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
				case PORT_u8D:SET_BIT(PORTD,Copy_u8PinNum);break;
    16b6:	a2 e3       	ldi	r26, 0x32	; 50
    16b8:	b0 e0       	ldi	r27, 0x00	; 0
    16ba:	e2 e3       	ldi	r30, 0x32	; 50
    16bc:	f0 e0       	ldi	r31, 0x00	; 0
    16be:	80 81       	ld	r24, Z
    16c0:	48 2f       	mov	r20, r24
    16c2:	8a 81       	ldd	r24, Y+2	; 0x02
    16c4:	28 2f       	mov	r18, r24
    16c6:	30 e0       	ldi	r19, 0x00	; 0
    16c8:	81 e0       	ldi	r24, 0x01	; 1
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	02 2e       	mov	r0, r18
    16ce:	02 c0       	rjmp	.+4      	; 0x16d4 <DIO_voidSetPinValue+0x100>
    16d0:	88 0f       	add	r24, r24
    16d2:	99 1f       	adc	r25, r25
    16d4:	0a 94       	dec	r0
    16d6:	e2 f7       	brpl	.-8      	; 0x16d0 <DIO_voidSetPinValue+0xfc>
    16d8:	84 2b       	or	r24, r20
    16da:	8c 93       	st	X, r24
    16dc:	78 c0       	rjmp	.+240    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
			}
		}
		else if(Copy_u8PinValue == PIN_LOW)
    16de:	8b 81       	ldd	r24, Y+3	; 0x03
    16e0:	88 23       	and	r24, r24
    16e2:	09 f0       	breq	.+2      	; 0x16e6 <DIO_voidSetPinValue+0x112>
    16e4:	74 c0       	rjmp	.+232    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
		{
			switch(Copy_u8PortNum)
    16e6:	89 81       	ldd	r24, Y+1	; 0x01
    16e8:	28 2f       	mov	r18, r24
    16ea:	30 e0       	ldi	r19, 0x00	; 0
    16ec:	3d 83       	std	Y+5, r19	; 0x05
    16ee:	2c 83       	std	Y+4, r18	; 0x04
    16f0:	8c 81       	ldd	r24, Y+4	; 0x04
    16f2:	9d 81       	ldd	r25, Y+5	; 0x05
    16f4:	82 30       	cpi	r24, 0x02	; 2
    16f6:	91 05       	cpc	r25, r1
    16f8:	61 f1       	breq	.+88     	; 0x1752 <DIO_voidSetPinValue+0x17e>
    16fa:	2c 81       	ldd	r18, Y+4	; 0x04
    16fc:	3d 81       	ldd	r19, Y+5	; 0x05
    16fe:	23 30       	cpi	r18, 0x03	; 3
    1700:	31 05       	cpc	r19, r1
    1702:	34 f4       	brge	.+12     	; 0x1710 <DIO_voidSetPinValue+0x13c>
    1704:	8c 81       	ldd	r24, Y+4	; 0x04
    1706:	9d 81       	ldd	r25, Y+5	; 0x05
    1708:	81 30       	cpi	r24, 0x01	; 1
    170a:	91 05       	cpc	r25, r1
    170c:	69 f0       	breq	.+26     	; 0x1728 <DIO_voidSetPinValue+0x154>
    170e:	5f c0       	rjmp	.+190    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
    1710:	2c 81       	ldd	r18, Y+4	; 0x04
    1712:	3d 81       	ldd	r19, Y+5	; 0x05
    1714:	23 30       	cpi	r18, 0x03	; 3
    1716:	31 05       	cpc	r19, r1
    1718:	89 f1       	breq	.+98     	; 0x177c <DIO_voidSetPinValue+0x1a8>
    171a:	8c 81       	ldd	r24, Y+4	; 0x04
    171c:	9d 81       	ldd	r25, Y+5	; 0x05
    171e:	84 30       	cpi	r24, 0x04	; 4
    1720:	91 05       	cpc	r25, r1
    1722:	09 f4       	brne	.+2      	; 0x1726 <DIO_voidSetPinValue+0x152>
    1724:	40 c0       	rjmp	.+128    	; 0x17a6 <DIO_voidSetPinValue+0x1d2>
    1726:	53 c0       	rjmp	.+166    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
			{
				case PORT_u8A:CLR_BIT(PORTA,Copy_u8PinNum);break;
    1728:	ab e3       	ldi	r26, 0x3B	; 59
    172a:	b0 e0       	ldi	r27, 0x00	; 0
    172c:	eb e3       	ldi	r30, 0x3B	; 59
    172e:	f0 e0       	ldi	r31, 0x00	; 0
    1730:	80 81       	ld	r24, Z
    1732:	48 2f       	mov	r20, r24
    1734:	8a 81       	ldd	r24, Y+2	; 0x02
    1736:	28 2f       	mov	r18, r24
    1738:	30 e0       	ldi	r19, 0x00	; 0
    173a:	81 e0       	ldi	r24, 0x01	; 1
    173c:	90 e0       	ldi	r25, 0x00	; 0
    173e:	02 2e       	mov	r0, r18
    1740:	02 c0       	rjmp	.+4      	; 0x1746 <DIO_voidSetPinValue+0x172>
    1742:	88 0f       	add	r24, r24
    1744:	99 1f       	adc	r25, r25
    1746:	0a 94       	dec	r0
    1748:	e2 f7       	brpl	.-8      	; 0x1742 <DIO_voidSetPinValue+0x16e>
    174a:	80 95       	com	r24
    174c:	84 23       	and	r24, r20
    174e:	8c 93       	st	X, r24
    1750:	3e c0       	rjmp	.+124    	; 0x17ce <DIO_voidSetPinValue+0x1fa>
				case PORT_u8B:CLR_BIT(PORTB,Copy_u8PinNum);break;
    1752:	a8 e3       	ldi	r26, 0x38	; 56
    1754:	b0 e0       	ldi	r27, 0x00	; 0
    1756:	e8 e3       	ldi	r30, 0x38	; 56
    1758:	f0 e0       	ldi	r31, 0x00	; 0
    175a:	80 81       	ld	r24, Z
    175c:	48 2f       	mov	r20, r24
    175e:	8a 81       	ldd	r24, Y+2	; 0x02
    1760:	28 2f       	mov	r18, r24
    1762:	30 e0       	ldi	r19, 0x00	; 0
    1764:	81 e0       	ldi	r24, 0x01	; 1
    1766:	90 e0       	ldi	r25, 0x00	; 0
    1768:	02 2e       	mov	r0, r18
    176a:	02 c0       	rjmp	.+4      	; 0x1770 <DIO_voidSetPinValue+0x19c>
    176c:	88 0f       	add	r24, r24
    176e:	99 1f       	adc	r25, r25
    1770:	0a 94       	dec	r0
    1772:	e2 f7       	brpl	.-8      	; 0x176c <DIO_voidSetPinValue+0x198>
    1774:	80 95       	com	r24
    1776:	84 23       	and	r24, r20
    1778:	8c 93       	st	X, r24
    177a:	29 c0       	rjmp	.+82     	; 0x17ce <DIO_voidSetPinValue+0x1fa>
				case PORT_u8C:CLR_BIT(PORTC,Copy_u8PinNum);break;
    177c:	a5 e3       	ldi	r26, 0x35	; 53
    177e:	b0 e0       	ldi	r27, 0x00	; 0
    1780:	e5 e3       	ldi	r30, 0x35	; 53
    1782:	f0 e0       	ldi	r31, 0x00	; 0
    1784:	80 81       	ld	r24, Z
    1786:	48 2f       	mov	r20, r24
    1788:	8a 81       	ldd	r24, Y+2	; 0x02
    178a:	28 2f       	mov	r18, r24
    178c:	30 e0       	ldi	r19, 0x00	; 0
    178e:	81 e0       	ldi	r24, 0x01	; 1
    1790:	90 e0       	ldi	r25, 0x00	; 0
    1792:	02 2e       	mov	r0, r18
    1794:	02 c0       	rjmp	.+4      	; 0x179a <DIO_voidSetPinValue+0x1c6>
    1796:	88 0f       	add	r24, r24
    1798:	99 1f       	adc	r25, r25
    179a:	0a 94       	dec	r0
    179c:	e2 f7       	brpl	.-8      	; 0x1796 <DIO_voidSetPinValue+0x1c2>
    179e:	80 95       	com	r24
    17a0:	84 23       	and	r24, r20
    17a2:	8c 93       	st	X, r24
    17a4:	14 c0       	rjmp	.+40     	; 0x17ce <DIO_voidSetPinValue+0x1fa>
				case PORT_u8D:CLR_BIT(PORTD,Copy_u8PinNum);break;
    17a6:	a2 e3       	ldi	r26, 0x32	; 50
    17a8:	b0 e0       	ldi	r27, 0x00	; 0
    17aa:	e2 e3       	ldi	r30, 0x32	; 50
    17ac:	f0 e0       	ldi	r31, 0x00	; 0
    17ae:	80 81       	ld	r24, Z
    17b0:	48 2f       	mov	r20, r24
    17b2:	8a 81       	ldd	r24, Y+2	; 0x02
    17b4:	28 2f       	mov	r18, r24
    17b6:	30 e0       	ldi	r19, 0x00	; 0
    17b8:	81 e0       	ldi	r24, 0x01	; 1
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	02 2e       	mov	r0, r18
    17be:	02 c0       	rjmp	.+4      	; 0x17c4 <DIO_voidSetPinValue+0x1f0>
    17c0:	88 0f       	add	r24, r24
    17c2:	99 1f       	adc	r25, r25
    17c4:	0a 94       	dec	r0
    17c6:	e2 f7       	brpl	.-8      	; 0x17c0 <DIO_voidSetPinValue+0x1ec>
    17c8:	80 95       	com	r24
    17ca:	84 23       	and	r24, r20
    17cc:	8c 93       	st	X, r24
			}
		}
	}	
}
    17ce:	27 96       	adiw	r28, 0x07	; 7
    17d0:	0f b6       	in	r0, 0x3f	; 63
    17d2:	f8 94       	cli
    17d4:	de bf       	out	0x3e, r29	; 62
    17d6:	0f be       	out	0x3f, r0	; 63
    17d8:	cd bf       	out	0x3d, r28	; 61
    17da:	cf 91       	pop	r28
    17dc:	df 91       	pop	r29
    17de:	08 95       	ret

000017e0 <DIO_u8GetPinValue>:


u8 DIO_u8GetPinValue(u8 Copy_u8PortNum,u8 Copy_u8PinNum)
{
    17e0:	df 93       	push	r29
    17e2:	cf 93       	push	r28
    17e4:	00 d0       	rcall	.+0      	; 0x17e6 <DIO_u8GetPinValue+0x6>
    17e6:	00 d0       	rcall	.+0      	; 0x17e8 <DIO_u8GetPinValue+0x8>
    17e8:	0f 92       	push	r0
    17ea:	cd b7       	in	r28, 0x3d	; 61
    17ec:	de b7       	in	r29, 0x3e	; 62
    17ee:	8a 83       	std	Y+2, r24	; 0x02
    17f0:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8PinState=0;
    17f2:	19 82       	std	Y+1, r1	; 0x01
	switch(Copy_u8PortNum)
    17f4:	8a 81       	ldd	r24, Y+2	; 0x02
    17f6:	28 2f       	mov	r18, r24
    17f8:	30 e0       	ldi	r19, 0x00	; 0
    17fa:	3d 83       	std	Y+5, r19	; 0x05
    17fc:	2c 83       	std	Y+4, r18	; 0x04
    17fe:	4c 81       	ldd	r20, Y+4	; 0x04
    1800:	5d 81       	ldd	r21, Y+5	; 0x05
    1802:	42 30       	cpi	r20, 0x02	; 2
    1804:	51 05       	cpc	r21, r1
    1806:	41 f1       	breq	.+80     	; 0x1858 <DIO_u8GetPinValue+0x78>
    1808:	8c 81       	ldd	r24, Y+4	; 0x04
    180a:	9d 81       	ldd	r25, Y+5	; 0x05
    180c:	83 30       	cpi	r24, 0x03	; 3
    180e:	91 05       	cpc	r25, r1
    1810:	34 f4       	brge	.+12     	; 0x181e <DIO_u8GetPinValue+0x3e>
    1812:	2c 81       	ldd	r18, Y+4	; 0x04
    1814:	3d 81       	ldd	r19, Y+5	; 0x05
    1816:	21 30       	cpi	r18, 0x01	; 1
    1818:	31 05       	cpc	r19, r1
    181a:	61 f0       	breq	.+24     	; 0x1834 <DIO_u8GetPinValue+0x54>
    181c:	52 c0       	rjmp	.+164    	; 0x18c2 <DIO_u8GetPinValue+0xe2>
    181e:	4c 81       	ldd	r20, Y+4	; 0x04
    1820:	5d 81       	ldd	r21, Y+5	; 0x05
    1822:	43 30       	cpi	r20, 0x03	; 3
    1824:	51 05       	cpc	r21, r1
    1826:	51 f1       	breq	.+84     	; 0x187c <DIO_u8GetPinValue+0x9c>
    1828:	8c 81       	ldd	r24, Y+4	; 0x04
    182a:	9d 81       	ldd	r25, Y+5	; 0x05
    182c:	84 30       	cpi	r24, 0x04	; 4
    182e:	91 05       	cpc	r25, r1
    1830:	b9 f1       	breq	.+110    	; 0x18a0 <DIO_u8GetPinValue+0xc0>
    1832:	47 c0       	rjmp	.+142    	; 0x18c2 <DIO_u8GetPinValue+0xe2>
	{
		case PORT_u8A:Local_u8PinState=GET_BIT(PINA,Copy_u8PinNum);break;
    1834:	e9 e3       	ldi	r30, 0x39	; 57
    1836:	f0 e0       	ldi	r31, 0x00	; 0
    1838:	80 81       	ld	r24, Z
    183a:	28 2f       	mov	r18, r24
    183c:	30 e0       	ldi	r19, 0x00	; 0
    183e:	8b 81       	ldd	r24, Y+3	; 0x03
    1840:	88 2f       	mov	r24, r24
    1842:	90 e0       	ldi	r25, 0x00	; 0
    1844:	a9 01       	movw	r20, r18
    1846:	02 c0       	rjmp	.+4      	; 0x184c <DIO_u8GetPinValue+0x6c>
    1848:	55 95       	asr	r21
    184a:	47 95       	ror	r20
    184c:	8a 95       	dec	r24
    184e:	e2 f7       	brpl	.-8      	; 0x1848 <DIO_u8GetPinValue+0x68>
    1850:	ca 01       	movw	r24, r20
    1852:	81 70       	andi	r24, 0x01	; 1
    1854:	89 83       	std	Y+1, r24	; 0x01
    1856:	35 c0       	rjmp	.+106    	; 0x18c2 <DIO_u8GetPinValue+0xe2>
		case PORT_u8B:Local_u8PinState=GET_BIT(PINB,Copy_u8PinNum);break;
    1858:	e6 e3       	ldi	r30, 0x36	; 54
    185a:	f0 e0       	ldi	r31, 0x00	; 0
    185c:	80 81       	ld	r24, Z
    185e:	28 2f       	mov	r18, r24
    1860:	30 e0       	ldi	r19, 0x00	; 0
    1862:	8b 81       	ldd	r24, Y+3	; 0x03
    1864:	88 2f       	mov	r24, r24
    1866:	90 e0       	ldi	r25, 0x00	; 0
    1868:	a9 01       	movw	r20, r18
    186a:	02 c0       	rjmp	.+4      	; 0x1870 <DIO_u8GetPinValue+0x90>
    186c:	55 95       	asr	r21
    186e:	47 95       	ror	r20
    1870:	8a 95       	dec	r24
    1872:	e2 f7       	brpl	.-8      	; 0x186c <DIO_u8GetPinValue+0x8c>
    1874:	ca 01       	movw	r24, r20
    1876:	81 70       	andi	r24, 0x01	; 1
    1878:	89 83       	std	Y+1, r24	; 0x01
    187a:	23 c0       	rjmp	.+70     	; 0x18c2 <DIO_u8GetPinValue+0xe2>
		case PORT_u8C:Local_u8PinState=GET_BIT(PINC,Copy_u8PinNum);break;
    187c:	e3 e3       	ldi	r30, 0x33	; 51
    187e:	f0 e0       	ldi	r31, 0x00	; 0
    1880:	80 81       	ld	r24, Z
    1882:	28 2f       	mov	r18, r24
    1884:	30 e0       	ldi	r19, 0x00	; 0
    1886:	8b 81       	ldd	r24, Y+3	; 0x03
    1888:	88 2f       	mov	r24, r24
    188a:	90 e0       	ldi	r25, 0x00	; 0
    188c:	a9 01       	movw	r20, r18
    188e:	02 c0       	rjmp	.+4      	; 0x1894 <DIO_u8GetPinValue+0xb4>
    1890:	55 95       	asr	r21
    1892:	47 95       	ror	r20
    1894:	8a 95       	dec	r24
    1896:	e2 f7       	brpl	.-8      	; 0x1890 <DIO_u8GetPinValue+0xb0>
    1898:	ca 01       	movw	r24, r20
    189a:	81 70       	andi	r24, 0x01	; 1
    189c:	89 83       	std	Y+1, r24	; 0x01
    189e:	11 c0       	rjmp	.+34     	; 0x18c2 <DIO_u8GetPinValue+0xe2>
		case PORT_u8D:Local_u8PinState=GET_BIT(PIND,Copy_u8PinNum);break;
    18a0:	e0 e3       	ldi	r30, 0x30	; 48
    18a2:	f0 e0       	ldi	r31, 0x00	; 0
    18a4:	80 81       	ld	r24, Z
    18a6:	28 2f       	mov	r18, r24
    18a8:	30 e0       	ldi	r19, 0x00	; 0
    18aa:	8b 81       	ldd	r24, Y+3	; 0x03
    18ac:	88 2f       	mov	r24, r24
    18ae:	90 e0       	ldi	r25, 0x00	; 0
    18b0:	a9 01       	movw	r20, r18
    18b2:	02 c0       	rjmp	.+4      	; 0x18b8 <DIO_u8GetPinValue+0xd8>
    18b4:	55 95       	asr	r21
    18b6:	47 95       	ror	r20
    18b8:	8a 95       	dec	r24
    18ba:	e2 f7       	brpl	.-8      	; 0x18b4 <DIO_u8GetPinValue+0xd4>
    18bc:	ca 01       	movw	r24, r20
    18be:	81 70       	andi	r24, 0x01	; 1
    18c0:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8PinState;
    18c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    18c4:	0f 90       	pop	r0
    18c6:	0f 90       	pop	r0
    18c8:	0f 90       	pop	r0
    18ca:	0f 90       	pop	r0
    18cc:	0f 90       	pop	r0
    18ce:	cf 91       	pop	r28
    18d0:	df 91       	pop	r29
    18d2:	08 95       	ret

000018d4 <DIO_voidTogglePinValue>:
void DIO_voidTogglePinValue(u8 Copy_u8PortNum , u8 Copy_u8PinNum)
{
    18d4:	df 93       	push	r29
    18d6:	cf 93       	push	r28
    18d8:	00 d0       	rcall	.+0      	; 0x18da <DIO_voidTogglePinValue+0x6>
    18da:	00 d0       	rcall	.+0      	; 0x18dc <DIO_voidTogglePinValue+0x8>
    18dc:	cd b7       	in	r28, 0x3d	; 61
    18de:	de b7       	in	r29, 0x3e	; 62
    18e0:	89 83       	std	Y+1, r24	; 0x01
    18e2:	6a 83       	std	Y+2, r22	; 0x02
	if(Copy_u8PinNum < MAX_PIN_NUM)
    18e4:	8a 81       	ldd	r24, Y+2	; 0x02
    18e6:	87 30       	cpi	r24, 0x07	; 7
    18e8:	08 f0       	brcs	.+2      	; 0x18ec <DIO_voidTogglePinValue+0x18>
    18ea:	6f c0       	rjmp	.+222    	; 0x19ca <DIO_voidTogglePinValue+0xf6>
	{
		switch(Copy_u8PortNum)
    18ec:	89 81       	ldd	r24, Y+1	; 0x01
    18ee:	28 2f       	mov	r18, r24
    18f0:	30 e0       	ldi	r19, 0x00	; 0
    18f2:	3c 83       	std	Y+4, r19	; 0x04
    18f4:	2b 83       	std	Y+3, r18	; 0x03
    18f6:	8b 81       	ldd	r24, Y+3	; 0x03
    18f8:	9c 81       	ldd	r25, Y+4	; 0x04
    18fa:	82 30       	cpi	r24, 0x02	; 2
    18fc:	91 05       	cpc	r25, r1
    18fe:	51 f1       	breq	.+84     	; 0x1954 <DIO_voidTogglePinValue+0x80>
    1900:	2b 81       	ldd	r18, Y+3	; 0x03
    1902:	3c 81       	ldd	r19, Y+4	; 0x04
    1904:	23 30       	cpi	r18, 0x03	; 3
    1906:	31 05       	cpc	r19, r1
    1908:	34 f4       	brge	.+12     	; 0x1916 <DIO_voidTogglePinValue+0x42>
    190a:	8b 81       	ldd	r24, Y+3	; 0x03
    190c:	9c 81       	ldd	r25, Y+4	; 0x04
    190e:	81 30       	cpi	r24, 0x01	; 1
    1910:	91 05       	cpc	r25, r1
    1912:	61 f0       	breq	.+24     	; 0x192c <DIO_voidTogglePinValue+0x58>
    1914:	5a c0       	rjmp	.+180    	; 0x19ca <DIO_voidTogglePinValue+0xf6>
    1916:	2b 81       	ldd	r18, Y+3	; 0x03
    1918:	3c 81       	ldd	r19, Y+4	; 0x04
    191a:	23 30       	cpi	r18, 0x03	; 3
    191c:	31 05       	cpc	r19, r1
    191e:	71 f1       	breq	.+92     	; 0x197c <DIO_voidTogglePinValue+0xa8>
    1920:	8b 81       	ldd	r24, Y+3	; 0x03
    1922:	9c 81       	ldd	r25, Y+4	; 0x04
    1924:	84 30       	cpi	r24, 0x04	; 4
    1926:	91 05       	cpc	r25, r1
    1928:	e9 f1       	breq	.+122    	; 0x19a4 <DIO_voidTogglePinValue+0xd0>
    192a:	4f c0       	rjmp	.+158    	; 0x19ca <DIO_voidTogglePinValue+0xf6>
	        {
		        case PORT_u8A:TOG_BIT(PORTA,Copy_u8PinNum);break;
    192c:	ab e3       	ldi	r26, 0x3B	; 59
    192e:	b0 e0       	ldi	r27, 0x00	; 0
    1930:	eb e3       	ldi	r30, 0x3B	; 59
    1932:	f0 e0       	ldi	r31, 0x00	; 0
    1934:	80 81       	ld	r24, Z
    1936:	48 2f       	mov	r20, r24
    1938:	8a 81       	ldd	r24, Y+2	; 0x02
    193a:	28 2f       	mov	r18, r24
    193c:	30 e0       	ldi	r19, 0x00	; 0
    193e:	81 e0       	ldi	r24, 0x01	; 1
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	02 2e       	mov	r0, r18
    1944:	02 c0       	rjmp	.+4      	; 0x194a <DIO_voidTogglePinValue+0x76>
    1946:	88 0f       	add	r24, r24
    1948:	99 1f       	adc	r25, r25
    194a:	0a 94       	dec	r0
    194c:	e2 f7       	brpl	.-8      	; 0x1946 <DIO_voidTogglePinValue+0x72>
    194e:	84 27       	eor	r24, r20
    1950:	8c 93       	st	X, r24
    1952:	3b c0       	rjmp	.+118    	; 0x19ca <DIO_voidTogglePinValue+0xf6>
		        case PORT_u8B:TOG_BIT(PORTB,Copy_u8PinNum);break;
    1954:	a8 e3       	ldi	r26, 0x38	; 56
    1956:	b0 e0       	ldi	r27, 0x00	; 0
    1958:	e8 e3       	ldi	r30, 0x38	; 56
    195a:	f0 e0       	ldi	r31, 0x00	; 0
    195c:	80 81       	ld	r24, Z
    195e:	48 2f       	mov	r20, r24
    1960:	8a 81       	ldd	r24, Y+2	; 0x02
    1962:	28 2f       	mov	r18, r24
    1964:	30 e0       	ldi	r19, 0x00	; 0
    1966:	81 e0       	ldi	r24, 0x01	; 1
    1968:	90 e0       	ldi	r25, 0x00	; 0
    196a:	02 2e       	mov	r0, r18
    196c:	02 c0       	rjmp	.+4      	; 0x1972 <DIO_voidTogglePinValue+0x9e>
    196e:	88 0f       	add	r24, r24
    1970:	99 1f       	adc	r25, r25
    1972:	0a 94       	dec	r0
    1974:	e2 f7       	brpl	.-8      	; 0x196e <DIO_voidTogglePinValue+0x9a>
    1976:	84 27       	eor	r24, r20
    1978:	8c 93       	st	X, r24
    197a:	27 c0       	rjmp	.+78     	; 0x19ca <DIO_voidTogglePinValue+0xf6>
		        case PORT_u8C:TOG_BIT(PORTC,Copy_u8PinNum);break;
    197c:	a5 e3       	ldi	r26, 0x35	; 53
    197e:	b0 e0       	ldi	r27, 0x00	; 0
    1980:	e5 e3       	ldi	r30, 0x35	; 53
    1982:	f0 e0       	ldi	r31, 0x00	; 0
    1984:	80 81       	ld	r24, Z
    1986:	48 2f       	mov	r20, r24
    1988:	8a 81       	ldd	r24, Y+2	; 0x02
    198a:	28 2f       	mov	r18, r24
    198c:	30 e0       	ldi	r19, 0x00	; 0
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	02 2e       	mov	r0, r18
    1994:	02 c0       	rjmp	.+4      	; 0x199a <DIO_voidTogglePinValue+0xc6>
    1996:	88 0f       	add	r24, r24
    1998:	99 1f       	adc	r25, r25
    199a:	0a 94       	dec	r0
    199c:	e2 f7       	brpl	.-8      	; 0x1996 <DIO_voidTogglePinValue+0xc2>
    199e:	84 27       	eor	r24, r20
    19a0:	8c 93       	st	X, r24
    19a2:	13 c0       	rjmp	.+38     	; 0x19ca <DIO_voidTogglePinValue+0xf6>
		        case PORT_u8D:TOG_BIT(PORTD,Copy_u8PinNum);break;
    19a4:	a2 e3       	ldi	r26, 0x32	; 50
    19a6:	b0 e0       	ldi	r27, 0x00	; 0
    19a8:	e2 e3       	ldi	r30, 0x32	; 50
    19aa:	f0 e0       	ldi	r31, 0x00	; 0
    19ac:	80 81       	ld	r24, Z
    19ae:	48 2f       	mov	r20, r24
    19b0:	8a 81       	ldd	r24, Y+2	; 0x02
    19b2:	28 2f       	mov	r18, r24
    19b4:	30 e0       	ldi	r19, 0x00	; 0
    19b6:	81 e0       	ldi	r24, 0x01	; 1
    19b8:	90 e0       	ldi	r25, 0x00	; 0
    19ba:	02 2e       	mov	r0, r18
    19bc:	02 c0       	rjmp	.+4      	; 0x19c2 <DIO_voidTogglePinValue+0xee>
    19be:	88 0f       	add	r24, r24
    19c0:	99 1f       	adc	r25, r25
    19c2:	0a 94       	dec	r0
    19c4:	e2 f7       	brpl	.-8      	; 0x19be <DIO_voidTogglePinValue+0xea>
    19c6:	84 27       	eor	r24, r20
    19c8:	8c 93       	st	X, r24
	        }
	}

}
    19ca:	0f 90       	pop	r0
    19cc:	0f 90       	pop	r0
    19ce:	0f 90       	pop	r0
    19d0:	0f 90       	pop	r0
    19d2:	cf 91       	pop	r28
    19d4:	df 91       	pop	r29
    19d6:	08 95       	ret

000019d8 <EEPROM_voidWriteByte>:
#include "TWI_Interface.h"
#include "EEPROM_Interface.h"
#include <util/delay.h>

void EEPROM_voidWriteByte(u16 Copy_u16LocationAddress, u8 Copy_u8Byte, u8 Copy_u8DeviceNumber)
{
    19d8:	df 93       	push	r29
    19da:	cf 93       	push	r28
    19dc:	cd b7       	in	r28, 0x3d	; 61
    19de:	de b7       	in	r29, 0x3e	; 62
    19e0:	63 97       	sbiw	r28, 0x13	; 19
    19e2:	0f b6       	in	r0, 0x3f	; 63
    19e4:	f8 94       	cli
    19e6:	de bf       	out	0x3e, r29	; 62
    19e8:	0f be       	out	0x3f, r0	; 63
    19ea:	cd bf       	out	0x3d, r28	; 61
    19ec:	99 8b       	std	Y+17, r25	; 0x11
    19ee:	88 8b       	std	Y+16, r24	; 0x10
    19f0:	6a 8b       	std	Y+18, r22	; 0x12
    19f2:	4b 8b       	std	Y+19, r20	; 0x13
	u8 Local_u8SlaveAddress;
	Local_u8SlaveAddress = (0b01010000) | (Copy_u8DeviceNumber<<2) | (u8)(Copy_u16LocationAddress>>8);
    19f4:	8b 89       	ldd	r24, Y+19	; 0x13
    19f6:	88 2f       	mov	r24, r24
    19f8:	90 e0       	ldi	r25, 0x00	; 0
    19fa:	88 0f       	add	r24, r24
    19fc:	99 1f       	adc	r25, r25
    19fe:	88 0f       	add	r24, r24
    1a00:	99 1f       	adc	r25, r25
    1a02:	28 2f       	mov	r18, r24
    1a04:	20 65       	ori	r18, 0x50	; 80
    1a06:	88 89       	ldd	r24, Y+16	; 0x10
    1a08:	99 89       	ldd	r25, Y+17	; 0x11
    1a0a:	89 2f       	mov	r24, r25
    1a0c:	99 27       	eor	r25, r25
    1a0e:	82 2b       	or	r24, r18
    1a10:	8f 87       	std	Y+15, r24	; 0x0f

	TWI_voidStartCondition();
    1a12:	0e 94 bb 10 	call	0x2176	; 0x2176 <TWI_voidStartCondition>

	TWI_voidSendSlaveAddressWithWrite(Local_u8SlaveAddress);
    1a16:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a18:	0e 94 d5 10 	call	0x21aa	; 0x21aa <TWI_voidSendSlaveAddressWithWrite>

	TWI_voidSendData((u8)Copy_u16LocationAddress);
    1a1c:	88 89       	ldd	r24, Y+16	; 0x10
    1a1e:	0e 94 27 11 	call	0x224e	; 0x224e <TWI_voidSendData>

	TWI_voidSendData(Copy_u8Byte);
    1a22:	8a 89       	ldd	r24, Y+18	; 0x12
    1a24:	0e 94 27 11 	call	0x224e	; 0x224e <TWI_voidSendData>

	TWI_voidStopCondition();
    1a28:	0e 94 57 11 	call	0x22ae	; 0x22ae <TWI_voidStopCondition>
    1a2c:	80 e0       	ldi	r24, 0x00	; 0
    1a2e:	90 e0       	ldi	r25, 0x00	; 0
    1a30:	a0 e2       	ldi	r26, 0x20	; 32
    1a32:	b1 e4       	ldi	r27, 0x41	; 65
    1a34:	8b 87       	std	Y+11, r24	; 0x0b
    1a36:	9c 87       	std	Y+12, r25	; 0x0c
    1a38:	ad 87       	std	Y+13, r26	; 0x0d
    1a3a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1a3c:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a3e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a40:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a42:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a44:	20 e0       	ldi	r18, 0x00	; 0
    1a46:	30 e0       	ldi	r19, 0x00	; 0
    1a48:	4a ef       	ldi	r20, 0xFA	; 250
    1a4a:	54 e4       	ldi	r21, 0x44	; 68
    1a4c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a50:	dc 01       	movw	r26, r24
    1a52:	cb 01       	movw	r24, r22
    1a54:	8f 83       	std	Y+7, r24	; 0x07
    1a56:	98 87       	std	Y+8, r25	; 0x08
    1a58:	a9 87       	std	Y+9, r26	; 0x09
    1a5a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1a5c:	6f 81       	ldd	r22, Y+7	; 0x07
    1a5e:	78 85       	ldd	r23, Y+8	; 0x08
    1a60:	89 85       	ldd	r24, Y+9	; 0x09
    1a62:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a64:	20 e0       	ldi	r18, 0x00	; 0
    1a66:	30 e0       	ldi	r19, 0x00	; 0
    1a68:	40 e8       	ldi	r20, 0x80	; 128
    1a6a:	5f e3       	ldi	r21, 0x3F	; 63
    1a6c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1a70:	88 23       	and	r24, r24
    1a72:	2c f4       	brge	.+10     	; 0x1a7e <EEPROM_voidWriteByte+0xa6>
		__ticks = 1;
    1a74:	81 e0       	ldi	r24, 0x01	; 1
    1a76:	90 e0       	ldi	r25, 0x00	; 0
    1a78:	9e 83       	std	Y+6, r25	; 0x06
    1a7a:	8d 83       	std	Y+5, r24	; 0x05
    1a7c:	3f c0       	rjmp	.+126    	; 0x1afc <EEPROM_voidWriteByte+0x124>
	else if (__tmp > 65535)
    1a7e:	6f 81       	ldd	r22, Y+7	; 0x07
    1a80:	78 85       	ldd	r23, Y+8	; 0x08
    1a82:	89 85       	ldd	r24, Y+9	; 0x09
    1a84:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a86:	20 e0       	ldi	r18, 0x00	; 0
    1a88:	3f ef       	ldi	r19, 0xFF	; 255
    1a8a:	4f e7       	ldi	r20, 0x7F	; 127
    1a8c:	57 e4       	ldi	r21, 0x47	; 71
    1a8e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1a92:	18 16       	cp	r1, r24
    1a94:	4c f5       	brge	.+82     	; 0x1ae8 <EEPROM_voidWriteByte+0x110>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a96:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a98:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a9e:	20 e0       	ldi	r18, 0x00	; 0
    1aa0:	30 e0       	ldi	r19, 0x00	; 0
    1aa2:	40 e2       	ldi	r20, 0x20	; 32
    1aa4:	51 e4       	ldi	r21, 0x41	; 65
    1aa6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1aaa:	dc 01       	movw	r26, r24
    1aac:	cb 01       	movw	r24, r22
    1aae:	bc 01       	movw	r22, r24
    1ab0:	cd 01       	movw	r24, r26
    1ab2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ab6:	dc 01       	movw	r26, r24
    1ab8:	cb 01       	movw	r24, r22
    1aba:	9e 83       	std	Y+6, r25	; 0x06
    1abc:	8d 83       	std	Y+5, r24	; 0x05
    1abe:	0f c0       	rjmp	.+30     	; 0x1ade <EEPROM_voidWriteByte+0x106>
    1ac0:	88 ec       	ldi	r24, 0xC8	; 200
    1ac2:	90 e0       	ldi	r25, 0x00	; 0
    1ac4:	9c 83       	std	Y+4, r25	; 0x04
    1ac6:	8b 83       	std	Y+3, r24	; 0x03
    1ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aca:	9c 81       	ldd	r25, Y+4	; 0x04
    1acc:	01 97       	sbiw	r24, 0x01	; 1
    1ace:	f1 f7       	brne	.-4      	; 0x1acc <EEPROM_voidWriteByte+0xf4>
    1ad0:	9c 83       	std	Y+4, r25	; 0x04
    1ad2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ad4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ad6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ad8:	01 97       	sbiw	r24, 0x01	; 1
    1ada:	9e 83       	std	Y+6, r25	; 0x06
    1adc:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ade:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ae2:	00 97       	sbiw	r24, 0x00	; 0
    1ae4:	69 f7       	brne	.-38     	; 0x1ac0 <EEPROM_voidWriteByte+0xe8>
    1ae6:	14 c0       	rjmp	.+40     	; 0x1b10 <EEPROM_voidWriteByte+0x138>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ae8:	6f 81       	ldd	r22, Y+7	; 0x07
    1aea:	78 85       	ldd	r23, Y+8	; 0x08
    1aec:	89 85       	ldd	r24, Y+9	; 0x09
    1aee:	9a 85       	ldd	r25, Y+10	; 0x0a
    1af0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1af4:	dc 01       	movw	r26, r24
    1af6:	cb 01       	movw	r24, r22
    1af8:	9e 83       	std	Y+6, r25	; 0x06
    1afa:	8d 83       	std	Y+5, r24	; 0x05
    1afc:	8d 81       	ldd	r24, Y+5	; 0x05
    1afe:	9e 81       	ldd	r25, Y+6	; 0x06
    1b00:	9a 83       	std	Y+2, r25	; 0x02
    1b02:	89 83       	std	Y+1, r24	; 0x01
    1b04:	89 81       	ldd	r24, Y+1	; 0x01
    1b06:	9a 81       	ldd	r25, Y+2	; 0x02
    1b08:	01 97       	sbiw	r24, 0x01	; 1
    1b0a:	f1 f7       	brne	.-4      	; 0x1b08 <EEPROM_voidWriteByte+0x130>
    1b0c:	9a 83       	std	Y+2, r25	; 0x02
    1b0e:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(10);
}
    1b10:	63 96       	adiw	r28, 0x13	; 19
    1b12:	0f b6       	in	r0, 0x3f	; 63
    1b14:	f8 94       	cli
    1b16:	de bf       	out	0x3e, r29	; 62
    1b18:	0f be       	out	0x3f, r0	; 63
    1b1a:	cd bf       	out	0x3d, r28	; 61
    1b1c:	cf 91       	pop	r28
    1b1e:	df 91       	pop	r29
    1b20:	08 95       	ret

00001b22 <EEPROM_u8ReadByte>:

u8 EEPROM_u8ReadByte(u16 Copy_u16LocationAddress, u8 Copy_u8DeviceNumber)
{
    1b22:	df 93       	push	r29
    1b24:	cf 93       	push	r28
    1b26:	00 d0       	rcall	.+0      	; 0x1b28 <EEPROM_u8ReadByte+0x6>
    1b28:	00 d0       	rcall	.+0      	; 0x1b2a <EEPROM_u8ReadByte+0x8>
    1b2a:	0f 92       	push	r0
    1b2c:	cd b7       	in	r28, 0x3d	; 61
    1b2e:	de b7       	in	r29, 0x3e	; 62
    1b30:	9c 83       	std	Y+4, r25	; 0x04
    1b32:	8b 83       	std	Y+3, r24	; 0x03
    1b34:	6d 83       	std	Y+5, r22	; 0x05

	u8 Local_u8ReturnData;
	u8 Local_u8SlaveAddress;
	Local_u8SlaveAddress = (0b01010000) | (Copy_u8DeviceNumber<<2) | (u8)(Copy_u16LocationAddress>>8);
    1b36:	8d 81       	ldd	r24, Y+5	; 0x05
    1b38:	88 2f       	mov	r24, r24
    1b3a:	90 e0       	ldi	r25, 0x00	; 0
    1b3c:	88 0f       	add	r24, r24
    1b3e:	99 1f       	adc	r25, r25
    1b40:	88 0f       	add	r24, r24
    1b42:	99 1f       	adc	r25, r25
    1b44:	28 2f       	mov	r18, r24
    1b46:	20 65       	ori	r18, 0x50	; 80
    1b48:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b4c:	89 2f       	mov	r24, r25
    1b4e:	99 27       	eor	r25, r25
    1b50:	82 2b       	or	r24, r18
    1b52:	89 83       	std	Y+1, r24	; 0x01

	TWI_voidStartCondition();
    1b54:	0e 94 bb 10 	call	0x2176	; 0x2176 <TWI_voidStartCondition>

	TWI_voidSendSlaveAddressWithWrite(Local_u8SlaveAddress);
    1b58:	89 81       	ldd	r24, Y+1	; 0x01
    1b5a:	0e 94 d5 10 	call	0x21aa	; 0x21aa <TWI_voidSendSlaveAddressWithWrite>

	TWI_voidSendData((u8)Copy_u16LocationAddress);
    1b5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b60:	0e 94 27 11 	call	0x224e	; 0x224e <TWI_voidSendData>

	TWI_voidStartCondition();
    1b64:	0e 94 bb 10 	call	0x2176	; 0x2176 <TWI_voidStartCondition>

	TWI_voidSendSLaveAddressWithRead(Local_u8SlaveAddress);
    1b68:	89 81       	ldd	r24, Y+1	; 0x01
    1b6a:	0e 94 fe 10 	call	0x21fc	; 0x21fc <TWI_voidSendSLaveAddressWithRead>

	Local_u8ReturnData = TWI_u8RecieveData();
    1b6e:	0e 94 41 11 	call	0x2282	; 0x2282 <TWI_u8RecieveData>
    1b72:	8a 83       	std	Y+2, r24	; 0x02

	TWI_voidStopCondition();
    1b74:	0e 94 57 11 	call	0x22ae	; 0x22ae <TWI_voidStopCondition>

	return Local_u8ReturnData;
    1b78:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1b7a:	0f 90       	pop	r0
    1b7c:	0f 90       	pop	r0
    1b7e:	0f 90       	pop	r0
    1b80:	0f 90       	pop	r0
    1b82:	0f 90       	pop	r0
    1b84:	cf 91       	pop	r28
    1b86:	df 91       	pop	r29
    1b88:	08 95       	ret

00001b8a <EXIT_voidEnableDisable>:




void EXIT_voidEnableDisable(Int_num_e Copy_e_Int_Num,Int_Mode_e Copy_e_Mode)
{
    1b8a:	df 93       	push	r29
    1b8c:	cf 93       	push	r28
    1b8e:	cd b7       	in	r28, 0x3d	; 61
    1b90:	de b7       	in	r29, 0x3e	; 62
    1b92:	2a 97       	sbiw	r28, 0x0a	; 10
    1b94:	0f b6       	in	r0, 0x3f	; 63
    1b96:	f8 94       	cli
    1b98:	de bf       	out	0x3e, r29	; 62
    1b9a:	0f be       	out	0x3f, r0	; 63
    1b9c:	cd bf       	out	0x3d, r28	; 61
    1b9e:	89 83       	std	Y+1, r24	; 0x01
    1ba0:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_e_Int_Num)
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
    1ba4:	28 2f       	mov	r18, r24
    1ba6:	30 e0       	ldi	r19, 0x00	; 0
    1ba8:	3a 87       	std	Y+10, r19	; 0x0a
    1baa:	29 87       	std	Y+9, r18	; 0x09
    1bac:	89 85       	ldd	r24, Y+9	; 0x09
    1bae:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bb0:	81 30       	cpi	r24, 0x01	; 1
    1bb2:	91 05       	cpc	r25, r1
    1bb4:	51 f1       	breq	.+84     	; 0x1c0a <EXIT_voidEnableDisable+0x80>
    1bb6:	29 85       	ldd	r18, Y+9	; 0x09
    1bb8:	3a 85       	ldd	r19, Y+10	; 0x0a
    1bba:	22 30       	cpi	r18, 0x02	; 2
    1bbc:	31 05       	cpc	r19, r1
    1bbe:	09 f4       	brne	.+2      	; 0x1bc2 <EXIT_voidEnableDisable+0x38>
    1bc0:	43 c0       	rjmp	.+134    	; 0x1c48 <EXIT_voidEnableDisable+0xbe>
    1bc2:	89 85       	ldd	r24, Y+9	; 0x09
    1bc4:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bc6:	00 97       	sbiw	r24, 0x00	; 0
    1bc8:	09 f0       	breq	.+2      	; 0x1bcc <EXIT_voidEnableDisable+0x42>
    1bca:	5c c0       	rjmp	.+184    	; 0x1c84 <EXIT_voidEnableDisable+0xfa>
	{
	case INT_0:
		switch(Copy_e_Mode)
    1bcc:	8a 81       	ldd	r24, Y+2	; 0x02
    1bce:	28 2f       	mov	r18, r24
    1bd0:	30 e0       	ldi	r19, 0x00	; 0
    1bd2:	38 87       	std	Y+8, r19	; 0x08
    1bd4:	2f 83       	std	Y+7, r18	; 0x07
    1bd6:	8f 81       	ldd	r24, Y+7	; 0x07
    1bd8:	98 85       	ldd	r25, Y+8	; 0x08
    1bda:	00 97       	sbiw	r24, 0x00	; 0
    1bdc:	31 f0       	breq	.+12     	; 0x1bea <EXIT_voidEnableDisable+0x60>
    1bde:	2f 81       	ldd	r18, Y+7	; 0x07
    1be0:	38 85       	ldd	r19, Y+8	; 0x08
    1be2:	21 30       	cpi	r18, 0x01	; 1
    1be4:	31 05       	cpc	r19, r1
    1be6:	49 f0       	breq	.+18     	; 0x1bfa <EXIT_voidEnableDisable+0x70>
    1be8:	4d c0       	rjmp	.+154    	; 0x1c84 <EXIT_voidEnableDisable+0xfa>
		{
		case Enabled:SET_BIT(GICR,GICR_INT0);
    1bea:	ab e5       	ldi	r26, 0x5B	; 91
    1bec:	b0 e0       	ldi	r27, 0x00	; 0
    1bee:	eb e5       	ldi	r30, 0x5B	; 91
    1bf0:	f0 e0       	ldi	r31, 0x00	; 0
    1bf2:	80 81       	ld	r24, Z
    1bf4:	80 64       	ori	r24, 0x40	; 64
    1bf6:	8c 93       	st	X, r24
    1bf8:	45 c0       	rjmp	.+138    	; 0x1c84 <EXIT_voidEnableDisable+0xfa>
		break;
		case Disabled:CLR_BIT(GICR,GICR_INT0);
    1bfa:	ab e5       	ldi	r26, 0x5B	; 91
    1bfc:	b0 e0       	ldi	r27, 0x00	; 0
    1bfe:	eb e5       	ldi	r30, 0x5B	; 91
    1c00:	f0 e0       	ldi	r31, 0x00	; 0
    1c02:	80 81       	ld	r24, Z
    1c04:	8f 7b       	andi	r24, 0xBF	; 191
    1c06:	8c 93       	st	X, r24
    1c08:	3d c0       	rjmp	.+122    	; 0x1c84 <EXIT_voidEnableDisable+0xfa>
		break;
		}
		;break;
		case INT_1: switch(Copy_e_Mode)
    1c0a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c0c:	28 2f       	mov	r18, r24
    1c0e:	30 e0       	ldi	r19, 0x00	; 0
    1c10:	3e 83       	std	Y+6, r19	; 0x06
    1c12:	2d 83       	std	Y+5, r18	; 0x05
    1c14:	8d 81       	ldd	r24, Y+5	; 0x05
    1c16:	9e 81       	ldd	r25, Y+6	; 0x06
    1c18:	00 97       	sbiw	r24, 0x00	; 0
    1c1a:	31 f0       	breq	.+12     	; 0x1c28 <EXIT_voidEnableDisable+0x9e>
    1c1c:	2d 81       	ldd	r18, Y+5	; 0x05
    1c1e:	3e 81       	ldd	r19, Y+6	; 0x06
    1c20:	21 30       	cpi	r18, 0x01	; 1
    1c22:	31 05       	cpc	r19, r1
    1c24:	49 f0       	breq	.+18     	; 0x1c38 <EXIT_voidEnableDisable+0xae>
    1c26:	2e c0       	rjmp	.+92     	; 0x1c84 <EXIT_voidEnableDisable+0xfa>
		{
		case Enabled:SET_BIT(GICR,GICR_INT1);
    1c28:	ab e5       	ldi	r26, 0x5B	; 91
    1c2a:	b0 e0       	ldi	r27, 0x00	; 0
    1c2c:	eb e5       	ldi	r30, 0x5B	; 91
    1c2e:	f0 e0       	ldi	r31, 0x00	; 0
    1c30:	80 81       	ld	r24, Z
    1c32:	80 68       	ori	r24, 0x80	; 128
    1c34:	8c 93       	st	X, r24
    1c36:	26 c0       	rjmp	.+76     	; 0x1c84 <EXIT_voidEnableDisable+0xfa>
		break;
		case Disabled:CLR_BIT(GICR,GICR_INT1);
    1c38:	ab e5       	ldi	r26, 0x5B	; 91
    1c3a:	b0 e0       	ldi	r27, 0x00	; 0
    1c3c:	eb e5       	ldi	r30, 0x5B	; 91
    1c3e:	f0 e0       	ldi	r31, 0x00	; 0
    1c40:	80 81       	ld	r24, Z
    1c42:	8f 77       	andi	r24, 0x7F	; 127
    1c44:	8c 93       	st	X, r24
    1c46:	1e c0       	rjmp	.+60     	; 0x1c84 <EXIT_voidEnableDisable+0xfa>
		break;
		};break;
		case INT_2:      switch(Copy_e_Mode)
    1c48:	8a 81       	ldd	r24, Y+2	; 0x02
    1c4a:	28 2f       	mov	r18, r24
    1c4c:	30 e0       	ldi	r19, 0x00	; 0
    1c4e:	3c 83       	std	Y+4, r19	; 0x04
    1c50:	2b 83       	std	Y+3, r18	; 0x03
    1c52:	8b 81       	ldd	r24, Y+3	; 0x03
    1c54:	9c 81       	ldd	r25, Y+4	; 0x04
    1c56:	00 97       	sbiw	r24, 0x00	; 0
    1c58:	31 f0       	breq	.+12     	; 0x1c66 <EXIT_voidEnableDisable+0xdc>
    1c5a:	2b 81       	ldd	r18, Y+3	; 0x03
    1c5c:	3c 81       	ldd	r19, Y+4	; 0x04
    1c5e:	21 30       	cpi	r18, 0x01	; 1
    1c60:	31 05       	cpc	r19, r1
    1c62:	49 f0       	breq	.+18     	; 0x1c76 <EXIT_voidEnableDisable+0xec>
    1c64:	0f c0       	rjmp	.+30     	; 0x1c84 <EXIT_voidEnableDisable+0xfa>
		{
		case Enabled:SET_BIT(GICR,GICR_INT2);
    1c66:	ab e5       	ldi	r26, 0x5B	; 91
    1c68:	b0 e0       	ldi	r27, 0x00	; 0
    1c6a:	eb e5       	ldi	r30, 0x5B	; 91
    1c6c:	f0 e0       	ldi	r31, 0x00	; 0
    1c6e:	80 81       	ld	r24, Z
    1c70:	80 62       	ori	r24, 0x20	; 32
    1c72:	8c 93       	st	X, r24
    1c74:	07 c0       	rjmp	.+14     	; 0x1c84 <EXIT_voidEnableDisable+0xfa>
		break;
		case Disabled:CLR_BIT(GICR,GICR_INT2);
    1c76:	ab e5       	ldi	r26, 0x5B	; 91
    1c78:	b0 e0       	ldi	r27, 0x00	; 0
    1c7a:	eb e5       	ldi	r30, 0x5B	; 91
    1c7c:	f0 e0       	ldi	r31, 0x00	; 0
    1c7e:	80 81       	ld	r24, Z
    1c80:	8f 7d       	andi	r24, 0xDF	; 223
    1c82:	8c 93       	st	X, r24
		break;
		};break;
	}
}
    1c84:	2a 96       	adiw	r28, 0x0a	; 10
    1c86:	0f b6       	in	r0, 0x3f	; 63
    1c88:	f8 94       	cli
    1c8a:	de bf       	out	0x3e, r29	; 62
    1c8c:	0f be       	out	0x3f, r0	; 63
    1c8e:	cd bf       	out	0x3d, r28	; 61
    1c90:	cf 91       	pop	r28
    1c92:	df 91       	pop	r29
    1c94:	08 95       	ret

00001c96 <EXIT_voidSetSenseControl>:
void EXIT_voidSetSenseControl(Int_num_e Copy_e_Int_Num,Int_SenseCtrl_e Copy_e_SenseCtrl)
{
    1c96:	df 93       	push	r29
    1c98:	cf 93       	push	r28
    1c9a:	cd b7       	in	r28, 0x3d	; 61
    1c9c:	de b7       	in	r29, 0x3e	; 62
    1c9e:	2a 97       	sbiw	r28, 0x0a	; 10
    1ca0:	0f b6       	in	r0, 0x3f	; 63
    1ca2:	f8 94       	cli
    1ca4:	de bf       	out	0x3e, r29	; 62
    1ca6:	0f be       	out	0x3f, r0	; 63
    1ca8:	cd bf       	out	0x3d, r28	; 61
    1caa:	89 83       	std	Y+1, r24	; 0x01
    1cac:	6a 83       	std	Y+2, r22	; 0x02
switch(Copy_e_Int_Num)
    1cae:	89 81       	ldd	r24, Y+1	; 0x01
    1cb0:	28 2f       	mov	r18, r24
    1cb2:	30 e0       	ldi	r19, 0x00	; 0
    1cb4:	3a 87       	std	Y+10, r19	; 0x0a
    1cb6:	29 87       	std	Y+9, r18	; 0x09
    1cb8:	89 85       	ldd	r24, Y+9	; 0x09
    1cba:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cbc:	81 30       	cpi	r24, 0x01	; 1
    1cbe:	91 05       	cpc	r25, r1
    1cc0:	09 f4       	brne	.+2      	; 0x1cc4 <EXIT_voidSetSenseControl+0x2e>
    1cc2:	66 c0       	rjmp	.+204    	; 0x1d90 <EXIT_voidSetSenseControl+0xfa>
    1cc4:	29 85       	ldd	r18, Y+9	; 0x09
    1cc6:	3a 85       	ldd	r19, Y+10	; 0x0a
    1cc8:	22 30       	cpi	r18, 0x02	; 2
    1cca:	31 05       	cpc	r19, r1
    1ccc:	09 f4       	brne	.+2      	; 0x1cd0 <EXIT_voidSetSenseControl+0x3a>
    1cce:	bb c0       	rjmp	.+374    	; 0x1e46 <EXIT_voidSetSenseControl+0x1b0>
    1cd0:	89 85       	ldd	r24, Y+9	; 0x09
    1cd2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cd4:	00 97       	sbiw	r24, 0x00	; 0
    1cd6:	09 f0       	breq	.+2      	; 0x1cda <EXIT_voidSetSenseControl+0x44>
    1cd8:	d5 c0       	rjmp	.+426    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
{
case INT_0:
	switch(Copy_e_SenseCtrl)
    1cda:	8a 81       	ldd	r24, Y+2	; 0x02
    1cdc:	28 2f       	mov	r18, r24
    1cde:	30 e0       	ldi	r19, 0x00	; 0
    1ce0:	38 87       	std	Y+8, r19	; 0x08
    1ce2:	2f 83       	std	Y+7, r18	; 0x07
    1ce4:	8f 81       	ldd	r24, Y+7	; 0x07
    1ce6:	98 85       	ldd	r25, Y+8	; 0x08
    1ce8:	81 30       	cpi	r24, 0x01	; 1
    1cea:	91 05       	cpc	r25, r1
    1cec:	21 f1       	breq	.+72     	; 0x1d36 <EXIT_voidSetSenseControl+0xa0>
    1cee:	2f 81       	ldd	r18, Y+7	; 0x07
    1cf0:	38 85       	ldd	r19, Y+8	; 0x08
    1cf2:	22 30       	cpi	r18, 0x02	; 2
    1cf4:	31 05       	cpc	r19, r1
    1cf6:	2c f4       	brge	.+10     	; 0x1d02 <EXIT_voidSetSenseControl+0x6c>
    1cf8:	8f 81       	ldd	r24, Y+7	; 0x07
    1cfa:	98 85       	ldd	r25, Y+8	; 0x08
    1cfc:	00 97       	sbiw	r24, 0x00	; 0
    1cfe:	61 f0       	breq	.+24     	; 0x1d18 <EXIT_voidSetSenseControl+0x82>
    1d00:	c1 c0       	rjmp	.+386    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
    1d02:	2f 81       	ldd	r18, Y+7	; 0x07
    1d04:	38 85       	ldd	r19, Y+8	; 0x08
    1d06:	22 30       	cpi	r18, 0x02	; 2
    1d08:	31 05       	cpc	r19, r1
    1d0a:	21 f1       	breq	.+72     	; 0x1d54 <EXIT_voidSetSenseControl+0xbe>
    1d0c:	8f 81       	ldd	r24, Y+7	; 0x07
    1d0e:	98 85       	ldd	r25, Y+8	; 0x08
    1d10:	83 30       	cpi	r24, 0x03	; 3
    1d12:	91 05       	cpc	r25, r1
    1d14:	71 f1       	breq	.+92     	; 0x1d72 <EXIT_voidSetSenseControl+0xdc>
    1d16:	b6 c0       	rjmp	.+364    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
	{
	case low_level :
		CLR_BIT(MCUCR,MCUCR_ISC00);
    1d18:	a5 e5       	ldi	r26, 0x55	; 85
    1d1a:	b0 e0       	ldi	r27, 0x00	; 0
    1d1c:	e5 e5       	ldi	r30, 0x55	; 85
    1d1e:	f0 e0       	ldi	r31, 0x00	; 0
    1d20:	80 81       	ld	r24, Z
    1d22:	8e 7f       	andi	r24, 0xFE	; 254
    1d24:	8c 93       	st	X, r24
		CLR_BIT(MCUCR,MCUCR_ISC01);
    1d26:	a5 e5       	ldi	r26, 0x55	; 85
    1d28:	b0 e0       	ldi	r27, 0x00	; 0
    1d2a:	e5 e5       	ldi	r30, 0x55	; 85
    1d2c:	f0 e0       	ldi	r31, 0x00	; 0
    1d2e:	80 81       	ld	r24, Z
    1d30:	8d 7f       	andi	r24, 0xFD	; 253
    1d32:	8c 93       	st	X, r24
    1d34:	a7 c0       	rjmp	.+334    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
		break;
	case logical_change :
		SET_BIT(MCUCR,MCUCR_ISC00);
    1d36:	a5 e5       	ldi	r26, 0x55	; 85
    1d38:	b0 e0       	ldi	r27, 0x00	; 0
    1d3a:	e5 e5       	ldi	r30, 0x55	; 85
    1d3c:	f0 e0       	ldi	r31, 0x00	; 0
    1d3e:	80 81       	ld	r24, Z
    1d40:	81 60       	ori	r24, 0x01	; 1
    1d42:	8c 93       	st	X, r24
		CLR_BIT(MCUCR,MCUCR_ISC01);
    1d44:	a5 e5       	ldi	r26, 0x55	; 85
    1d46:	b0 e0       	ldi	r27, 0x00	; 0
    1d48:	e5 e5       	ldi	r30, 0x55	; 85
    1d4a:	f0 e0       	ldi	r31, 0x00	; 0
    1d4c:	80 81       	ld	r24, Z
    1d4e:	8d 7f       	andi	r24, 0xFD	; 253
    1d50:	8c 93       	st	X, r24
    1d52:	98 c0       	rjmp	.+304    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
		break;
	case falling_age :
		CLR_BIT(MCUCR,MCUCR_ISC00);
    1d54:	a5 e5       	ldi	r26, 0x55	; 85
    1d56:	b0 e0       	ldi	r27, 0x00	; 0
    1d58:	e5 e5       	ldi	r30, 0x55	; 85
    1d5a:	f0 e0       	ldi	r31, 0x00	; 0
    1d5c:	80 81       	ld	r24, Z
    1d5e:	8e 7f       	andi	r24, 0xFE	; 254
    1d60:	8c 93       	st	X, r24
		SET_BIT(MCUCR,MCUCR_ISC01);
    1d62:	a5 e5       	ldi	r26, 0x55	; 85
    1d64:	b0 e0       	ldi	r27, 0x00	; 0
    1d66:	e5 e5       	ldi	r30, 0x55	; 85
    1d68:	f0 e0       	ldi	r31, 0x00	; 0
    1d6a:	80 81       	ld	r24, Z
    1d6c:	82 60       	ori	r24, 0x02	; 2
    1d6e:	8c 93       	st	X, r24
    1d70:	89 c0       	rjmp	.+274    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
		break;
	case rising_age :
		SET_BIT(MCUCR,MCUCR_ISC00);
    1d72:	a5 e5       	ldi	r26, 0x55	; 85
    1d74:	b0 e0       	ldi	r27, 0x00	; 0
    1d76:	e5 e5       	ldi	r30, 0x55	; 85
    1d78:	f0 e0       	ldi	r31, 0x00	; 0
    1d7a:	80 81       	ld	r24, Z
    1d7c:	81 60       	ori	r24, 0x01	; 1
    1d7e:	8c 93       	st	X, r24
		SET_BIT(MCUCR,MCUCR_ISC01);
    1d80:	a5 e5       	ldi	r26, 0x55	; 85
    1d82:	b0 e0       	ldi	r27, 0x00	; 0
    1d84:	e5 e5       	ldi	r30, 0x55	; 85
    1d86:	f0 e0       	ldi	r31, 0x00	; 0
    1d88:	80 81       	ld	r24, Z
    1d8a:	82 60       	ori	r24, 0x02	; 2
    1d8c:	8c 93       	st	X, r24
    1d8e:	7a c0       	rjmp	.+244    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
		break;
	}
	break;
case INT_1:
	switch(Copy_e_SenseCtrl)
    1d90:	8a 81       	ldd	r24, Y+2	; 0x02
    1d92:	28 2f       	mov	r18, r24
    1d94:	30 e0       	ldi	r19, 0x00	; 0
    1d96:	3e 83       	std	Y+6, r19	; 0x06
    1d98:	2d 83       	std	Y+5, r18	; 0x05
    1d9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d9e:	81 30       	cpi	r24, 0x01	; 1
    1da0:	91 05       	cpc	r25, r1
    1da2:	21 f1       	breq	.+72     	; 0x1dec <EXIT_voidSetSenseControl+0x156>
    1da4:	2d 81       	ldd	r18, Y+5	; 0x05
    1da6:	3e 81       	ldd	r19, Y+6	; 0x06
    1da8:	22 30       	cpi	r18, 0x02	; 2
    1daa:	31 05       	cpc	r19, r1
    1dac:	2c f4       	brge	.+10     	; 0x1db8 <EXIT_voidSetSenseControl+0x122>
    1dae:	8d 81       	ldd	r24, Y+5	; 0x05
    1db0:	9e 81       	ldd	r25, Y+6	; 0x06
    1db2:	00 97       	sbiw	r24, 0x00	; 0
    1db4:	61 f0       	breq	.+24     	; 0x1dce <EXIT_voidSetSenseControl+0x138>
    1db6:	66 c0       	rjmp	.+204    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
    1db8:	2d 81       	ldd	r18, Y+5	; 0x05
    1dba:	3e 81       	ldd	r19, Y+6	; 0x06
    1dbc:	22 30       	cpi	r18, 0x02	; 2
    1dbe:	31 05       	cpc	r19, r1
    1dc0:	21 f1       	breq	.+72     	; 0x1e0a <EXIT_voidSetSenseControl+0x174>
    1dc2:	8d 81       	ldd	r24, Y+5	; 0x05
    1dc4:	9e 81       	ldd	r25, Y+6	; 0x06
    1dc6:	83 30       	cpi	r24, 0x03	; 3
    1dc8:	91 05       	cpc	r25, r1
    1dca:	71 f1       	breq	.+92     	; 0x1e28 <EXIT_voidSetSenseControl+0x192>
    1dcc:	5b c0       	rjmp	.+182    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
		{
		case low_level :
			CLR_BIT(MCUCR,MCUCR_ISC10);
    1dce:	a5 e5       	ldi	r26, 0x55	; 85
    1dd0:	b0 e0       	ldi	r27, 0x00	; 0
    1dd2:	e5 e5       	ldi	r30, 0x55	; 85
    1dd4:	f0 e0       	ldi	r31, 0x00	; 0
    1dd6:	80 81       	ld	r24, Z
    1dd8:	8b 7f       	andi	r24, 0xFB	; 251
    1dda:	8c 93       	st	X, r24
			CLR_BIT(MCUCR,MCUCR_ISC11);
    1ddc:	a5 e5       	ldi	r26, 0x55	; 85
    1dde:	b0 e0       	ldi	r27, 0x00	; 0
    1de0:	e5 e5       	ldi	r30, 0x55	; 85
    1de2:	f0 e0       	ldi	r31, 0x00	; 0
    1de4:	80 81       	ld	r24, Z
    1de6:	87 7f       	andi	r24, 0xF7	; 247
    1de8:	8c 93       	st	X, r24
    1dea:	4c c0       	rjmp	.+152    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
			break;
		case logical_change :
			SET_BIT(MCUCR,MCUCR_ISC10);
    1dec:	a5 e5       	ldi	r26, 0x55	; 85
    1dee:	b0 e0       	ldi	r27, 0x00	; 0
    1df0:	e5 e5       	ldi	r30, 0x55	; 85
    1df2:	f0 e0       	ldi	r31, 0x00	; 0
    1df4:	80 81       	ld	r24, Z
    1df6:	84 60       	ori	r24, 0x04	; 4
    1df8:	8c 93       	st	X, r24
			CLR_BIT(MCUCR,MCUCR_ISC11);
    1dfa:	a5 e5       	ldi	r26, 0x55	; 85
    1dfc:	b0 e0       	ldi	r27, 0x00	; 0
    1dfe:	e5 e5       	ldi	r30, 0x55	; 85
    1e00:	f0 e0       	ldi	r31, 0x00	; 0
    1e02:	80 81       	ld	r24, Z
    1e04:	87 7f       	andi	r24, 0xF7	; 247
    1e06:	8c 93       	st	X, r24
    1e08:	3d c0       	rjmp	.+122    	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
			break;
		case falling_age :
			CLR_BIT(MCUCR,MCUCR_ISC10);
    1e0a:	a5 e5       	ldi	r26, 0x55	; 85
    1e0c:	b0 e0       	ldi	r27, 0x00	; 0
    1e0e:	e5 e5       	ldi	r30, 0x55	; 85
    1e10:	f0 e0       	ldi	r31, 0x00	; 0
    1e12:	80 81       	ld	r24, Z
    1e14:	8b 7f       	andi	r24, 0xFB	; 251
    1e16:	8c 93       	st	X, r24
			SET_BIT(MCUCR,MCUCR_ISC11);
    1e18:	a5 e5       	ldi	r26, 0x55	; 85
    1e1a:	b0 e0       	ldi	r27, 0x00	; 0
    1e1c:	e5 e5       	ldi	r30, 0x55	; 85
    1e1e:	f0 e0       	ldi	r31, 0x00	; 0
    1e20:	80 81       	ld	r24, Z
    1e22:	88 60       	ori	r24, 0x08	; 8
    1e24:	8c 93       	st	X, r24
    1e26:	2e c0       	rjmp	.+92     	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
			break;
		case rising_age :
			SET_BIT(MCUCR,MCUCR_ISC10);
    1e28:	a5 e5       	ldi	r26, 0x55	; 85
    1e2a:	b0 e0       	ldi	r27, 0x00	; 0
    1e2c:	e5 e5       	ldi	r30, 0x55	; 85
    1e2e:	f0 e0       	ldi	r31, 0x00	; 0
    1e30:	80 81       	ld	r24, Z
    1e32:	84 60       	ori	r24, 0x04	; 4
    1e34:	8c 93       	st	X, r24
			SET_BIT(MCUCR,MCUCR_ISC11);
    1e36:	a5 e5       	ldi	r26, 0x55	; 85
    1e38:	b0 e0       	ldi	r27, 0x00	; 0
    1e3a:	e5 e5       	ldi	r30, 0x55	; 85
    1e3c:	f0 e0       	ldi	r31, 0x00	; 0
    1e3e:	80 81       	ld	r24, Z
    1e40:	88 60       	ori	r24, 0x08	; 8
    1e42:	8c 93       	st	X, r24
    1e44:	1f c0       	rjmp	.+62     	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
			break;
		}
	break;
case INT_2:
	switch(Copy_e_SenseCtrl)
    1e46:	8a 81       	ldd	r24, Y+2	; 0x02
    1e48:	28 2f       	mov	r18, r24
    1e4a:	30 e0       	ldi	r19, 0x00	; 0
    1e4c:	3c 83       	std	Y+4, r19	; 0x04
    1e4e:	2b 83       	std	Y+3, r18	; 0x03
    1e50:	8b 81       	ldd	r24, Y+3	; 0x03
    1e52:	9c 81       	ldd	r25, Y+4	; 0x04
    1e54:	82 30       	cpi	r24, 0x02	; 2
    1e56:	91 05       	cpc	r25, r1
    1e58:	31 f0       	breq	.+12     	; 0x1e66 <EXIT_voidSetSenseControl+0x1d0>
    1e5a:	2b 81       	ldd	r18, Y+3	; 0x03
    1e5c:	3c 81       	ldd	r19, Y+4	; 0x04
    1e5e:	23 30       	cpi	r18, 0x03	; 3
    1e60:	31 05       	cpc	r19, r1
    1e62:	49 f0       	breq	.+18     	; 0x1e76 <EXIT_voidSetSenseControl+0x1e0>
    1e64:	0f c0       	rjmp	.+30     	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>
		{

		case falling_age :
			CLR_BIT(MCUCSR,MCUCSR_ISC2);
    1e66:	a4 e5       	ldi	r26, 0x54	; 84
    1e68:	b0 e0       	ldi	r27, 0x00	; 0
    1e6a:	e4 e5       	ldi	r30, 0x54	; 84
    1e6c:	f0 e0       	ldi	r31, 0x00	; 0
    1e6e:	80 81       	ld	r24, Z
    1e70:	8f 7b       	andi	r24, 0xBF	; 191
    1e72:	8c 93       	st	X, r24
    1e74:	07 c0       	rjmp	.+14     	; 0x1e84 <EXIT_voidSetSenseControl+0x1ee>

			break;
		case rising_age :
			SET_BIT(MCUCSR,MCUCSR_ISC2);
    1e76:	a4 e5       	ldi	r26, 0x54	; 84
    1e78:	b0 e0       	ldi	r27, 0x00	; 0
    1e7a:	e4 e5       	ldi	r30, 0x54	; 84
    1e7c:	f0 e0       	ldi	r31, 0x00	; 0
    1e7e:	80 81       	ld	r24, Z
    1e80:	80 64       	ori	r24, 0x40	; 64
    1e82:	8c 93       	st	X, r24
			break;
		}
	break;
}

}
    1e84:	2a 96       	adiw	r28, 0x0a	; 10
    1e86:	0f b6       	in	r0, 0x3f	; 63
    1e88:	f8 94       	cli
    1e8a:	de bf       	out	0x3e, r29	; 62
    1e8c:	0f be       	out	0x3f, r0	; 63
    1e8e:	cd bf       	out	0x3d, r28	; 61
    1e90:	cf 91       	pop	r28
    1e92:	df 91       	pop	r29
    1e94:	08 95       	ret

00001e96 <EXTI_voidSetCallBack>:

Std_err_e EXTI_voidSetCallBack(Int_num_e Copy_e_IntNum,void (*PvoidFunc)(void))
{
    1e96:	df 93       	push	r29
    1e98:	cf 93       	push	r28
    1e9a:	00 d0       	rcall	.+0      	; 0x1e9c <EXTI_voidSetCallBack+0x6>
    1e9c:	00 d0       	rcall	.+0      	; 0x1e9e <EXTI_voidSetCallBack+0x8>
    1e9e:	00 d0       	rcall	.+0      	; 0x1ea0 <EXTI_voidSetCallBack+0xa>
    1ea0:	cd b7       	in	r28, 0x3d	; 61
    1ea2:	de b7       	in	r29, 0x3e	; 62
    1ea4:	8a 83       	std	Y+2, r24	; 0x02
    1ea6:	7c 83       	std	Y+4, r23	; 0x04
    1ea8:	6b 83       	std	Y+3, r22	; 0x03
	Std_err_e Local_eState=OK;
    1eaa:	19 82       	std	Y+1, r1	; 0x01
	switch(Copy_e_IntNum)
    1eac:	8a 81       	ldd	r24, Y+2	; 0x02
    1eae:	28 2f       	mov	r18, r24
    1eb0:	30 e0       	ldi	r19, 0x00	; 0
    1eb2:	3e 83       	std	Y+6, r19	; 0x06
    1eb4:	2d 83       	std	Y+5, r18	; 0x05
    1eb6:	8d 81       	ldd	r24, Y+5	; 0x05
    1eb8:	9e 81       	ldd	r25, Y+6	; 0x06
    1eba:	81 30       	cpi	r24, 0x01	; 1
    1ebc:	91 05       	cpc	r25, r1
    1ebe:	b9 f0       	breq	.+46     	; 0x1eee <EXTI_voidSetCallBack+0x58>
    1ec0:	2d 81       	ldd	r18, Y+5	; 0x05
    1ec2:	3e 81       	ldd	r19, Y+6	; 0x06
    1ec4:	22 30       	cpi	r18, 0x02	; 2
    1ec6:	31 05       	cpc	r19, r1
    1ec8:	01 f1       	breq	.+64     	; 0x1f0a <EXTI_voidSetCallBack+0x74>
    1eca:	8d 81       	ldd	r24, Y+5	; 0x05
    1ecc:	9e 81       	ldd	r25, Y+6	; 0x06
    1ece:	00 97       	sbiw	r24, 0x00	; 0
    1ed0:	49 f5       	brne	.+82     	; 0x1f24 <EXTI_voidSetCallBack+0x8e>
	{
	case INT_0:
		if(PvoidFunc !=NULL)
    1ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ed6:	00 97       	sbiw	r24, 0x00	; 0
    1ed8:	39 f0       	breq	.+14     	; 0x1ee8 <EXTI_voidSetCallBack+0x52>
		{
			GlobalPtrTofunc[0]=PvoidFunc;
    1eda:	8b 81       	ldd	r24, Y+3	; 0x03
    1edc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ede:	90 93 29 01 	sts	0x0129, r25
    1ee2:	80 93 28 01 	sts	0x0128, r24
    1ee6:	1e c0       	rjmp	.+60     	; 0x1f24 <EXTI_voidSetCallBack+0x8e>
		}
		else
		{
			Local_eState=NOK;
    1ee8:	81 e0       	ldi	r24, 0x01	; 1
    1eea:	89 83       	std	Y+1, r24	; 0x01
    1eec:	1b c0       	rjmp	.+54     	; 0x1f24 <EXTI_voidSetCallBack+0x8e>
		}
		break;

	case INT_1:
		if(PvoidFunc !=NULL)
    1eee:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef2:	00 97       	sbiw	r24, 0x00	; 0
    1ef4:	39 f0       	breq	.+14     	; 0x1f04 <EXTI_voidSetCallBack+0x6e>
		{
			GlobalPtrTofunc[1]=PvoidFunc;
    1ef6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef8:	9c 81       	ldd	r25, Y+4	; 0x04
    1efa:	90 93 2b 01 	sts	0x012B, r25
    1efe:	80 93 2a 01 	sts	0x012A, r24
    1f02:	10 c0       	rjmp	.+32     	; 0x1f24 <EXTI_voidSetCallBack+0x8e>
		}
		else
		{
			Local_eState=NOK;
    1f04:	81 e0       	ldi	r24, 0x01	; 1
    1f06:	89 83       	std	Y+1, r24	; 0x01
    1f08:	0d c0       	rjmp	.+26     	; 0x1f24 <EXTI_voidSetCallBack+0x8e>
		}
		break;
	case INT_2:
		if(PvoidFunc !=NULL)
    1f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f0e:	00 97       	sbiw	r24, 0x00	; 0
    1f10:	39 f0       	breq	.+14     	; 0x1f20 <EXTI_voidSetCallBack+0x8a>
		{
			GlobalPtrTofunc[2]=PvoidFunc;
    1f12:	8b 81       	ldd	r24, Y+3	; 0x03
    1f14:	9c 81       	ldd	r25, Y+4	; 0x04
    1f16:	90 93 2d 01 	sts	0x012D, r25
    1f1a:	80 93 2c 01 	sts	0x012C, r24
    1f1e:	02 c0       	rjmp	.+4      	; 0x1f24 <EXTI_voidSetCallBack+0x8e>
		}
		else
		{
			Local_eState=NOK;
    1f20:	81 e0       	ldi	r24, 0x01	; 1
    1f22:	89 83       	std	Y+1, r24	; 0x01
		}
		break;
	}

	return Local_eState;
    1f24:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f26:	26 96       	adiw	r28, 0x06	; 6
    1f28:	0f b6       	in	r0, 0x3f	; 63
    1f2a:	f8 94       	cli
    1f2c:	de bf       	out	0x3e, r29	; 62
    1f2e:	0f be       	out	0x3f, r0	; 63
    1f30:	cd bf       	out	0x3d, r28	; 61
    1f32:	cf 91       	pop	r28
    1f34:	df 91       	pop	r29
    1f36:	08 95       	ret

00001f38 <__vector_1>:


void __vector_1(void)  __attribute__((signal));
void __vector_1(void)
{
    1f38:	1f 92       	push	r1
    1f3a:	0f 92       	push	r0
    1f3c:	0f b6       	in	r0, 0x3f	; 63
    1f3e:	0f 92       	push	r0
    1f40:	11 24       	eor	r1, r1
    1f42:	2f 93       	push	r18
    1f44:	3f 93       	push	r19
    1f46:	4f 93       	push	r20
    1f48:	5f 93       	push	r21
    1f4a:	6f 93       	push	r22
    1f4c:	7f 93       	push	r23
    1f4e:	8f 93       	push	r24
    1f50:	9f 93       	push	r25
    1f52:	af 93       	push	r26
    1f54:	bf 93       	push	r27
    1f56:	ef 93       	push	r30
    1f58:	ff 93       	push	r31
    1f5a:	df 93       	push	r29
    1f5c:	cf 93       	push	r28
    1f5e:	cd b7       	in	r28, 0x3d	; 61
    1f60:	de b7       	in	r29, 0x3e	; 62
   //INVOKE FUNCTION TO BE RUN INSIDE INT0
	GlobalPtrTofunc[0]();
    1f62:	e0 91 28 01 	lds	r30, 0x0128
    1f66:	f0 91 29 01 	lds	r31, 0x0129
    1f6a:	09 95       	icall
}
    1f6c:	cf 91       	pop	r28
    1f6e:	df 91       	pop	r29
    1f70:	ff 91       	pop	r31
    1f72:	ef 91       	pop	r30
    1f74:	bf 91       	pop	r27
    1f76:	af 91       	pop	r26
    1f78:	9f 91       	pop	r25
    1f7a:	8f 91       	pop	r24
    1f7c:	7f 91       	pop	r23
    1f7e:	6f 91       	pop	r22
    1f80:	5f 91       	pop	r21
    1f82:	4f 91       	pop	r20
    1f84:	3f 91       	pop	r19
    1f86:	2f 91       	pop	r18
    1f88:	0f 90       	pop	r0
    1f8a:	0f be       	out	0x3f, r0	; 63
    1f8c:	0f 90       	pop	r0
    1f8e:	1f 90       	pop	r1
    1f90:	18 95       	reti

00001f92 <__vector_2>:

void __vector_2(void)  __attribute__((signal));
void __vector_2(void)
{
    1f92:	1f 92       	push	r1
    1f94:	0f 92       	push	r0
    1f96:	0f b6       	in	r0, 0x3f	; 63
    1f98:	0f 92       	push	r0
    1f9a:	11 24       	eor	r1, r1
    1f9c:	2f 93       	push	r18
    1f9e:	3f 93       	push	r19
    1fa0:	4f 93       	push	r20
    1fa2:	5f 93       	push	r21
    1fa4:	6f 93       	push	r22
    1fa6:	7f 93       	push	r23
    1fa8:	8f 93       	push	r24
    1faa:	9f 93       	push	r25
    1fac:	af 93       	push	r26
    1fae:	bf 93       	push	r27
    1fb0:	ef 93       	push	r30
    1fb2:	ff 93       	push	r31
    1fb4:	df 93       	push	r29
    1fb6:	cf 93       	push	r28
    1fb8:	cd b7       	in	r28, 0x3d	; 61
    1fba:	de b7       	in	r29, 0x3e	; 62
	GlobalPtrTofunc[1]();
    1fbc:	e0 91 2a 01 	lds	r30, 0x012A
    1fc0:	f0 91 2b 01 	lds	r31, 0x012B
    1fc4:	09 95       	icall
}
    1fc6:	cf 91       	pop	r28
    1fc8:	df 91       	pop	r29
    1fca:	ff 91       	pop	r31
    1fcc:	ef 91       	pop	r30
    1fce:	bf 91       	pop	r27
    1fd0:	af 91       	pop	r26
    1fd2:	9f 91       	pop	r25
    1fd4:	8f 91       	pop	r24
    1fd6:	7f 91       	pop	r23
    1fd8:	6f 91       	pop	r22
    1fda:	5f 91       	pop	r21
    1fdc:	4f 91       	pop	r20
    1fde:	3f 91       	pop	r19
    1fe0:	2f 91       	pop	r18
    1fe2:	0f 90       	pop	r0
    1fe4:	0f be       	out	0x3f, r0	; 63
    1fe6:	0f 90       	pop	r0
    1fe8:	1f 90       	pop	r1
    1fea:	18 95       	reti

00001fec <__vector_3>:

void __vector_3(void)  __attribute__((signal));
void __vector_3(void)
{
    1fec:	1f 92       	push	r1
    1fee:	0f 92       	push	r0
    1ff0:	0f b6       	in	r0, 0x3f	; 63
    1ff2:	0f 92       	push	r0
    1ff4:	11 24       	eor	r1, r1
    1ff6:	2f 93       	push	r18
    1ff8:	3f 93       	push	r19
    1ffa:	4f 93       	push	r20
    1ffc:	5f 93       	push	r21
    1ffe:	6f 93       	push	r22
    2000:	7f 93       	push	r23
    2002:	8f 93       	push	r24
    2004:	9f 93       	push	r25
    2006:	af 93       	push	r26
    2008:	bf 93       	push	r27
    200a:	ef 93       	push	r30
    200c:	ff 93       	push	r31
    200e:	df 93       	push	r29
    2010:	cf 93       	push	r28
    2012:	cd b7       	in	r28, 0x3d	; 61
    2014:	de b7       	in	r29, 0x3e	; 62
	GlobalPtrTofunc[2]();
    2016:	e0 91 2c 01 	lds	r30, 0x012C
    201a:	f0 91 2d 01 	lds	r31, 0x012D
    201e:	09 95       	icall
}
    2020:	cf 91       	pop	r28
    2022:	df 91       	pop	r29
    2024:	ff 91       	pop	r31
    2026:	ef 91       	pop	r30
    2028:	bf 91       	pop	r27
    202a:	af 91       	pop	r26
    202c:	9f 91       	pop	r25
    202e:	8f 91       	pop	r24
    2030:	7f 91       	pop	r23
    2032:	6f 91       	pop	r22
    2034:	5f 91       	pop	r21
    2036:	4f 91       	pop	r20
    2038:	3f 91       	pop	r19
    203a:	2f 91       	pop	r18
    203c:	0f 90       	pop	r0
    203e:	0f be       	out	0x3f, r0	; 63
    2040:	0f 90       	pop	r0
    2042:	1f 90       	pop	r1
    2044:	18 95       	reti

00002046 <GI_voidEnable>:

#include "GI_interface.h"

#include "GI_private.h"

void GI_voidEnable(void){
    2046:	df 93       	push	r29
    2048:	cf 93       	push	r28
    204a:	cd b7       	in	r28, 0x3d	; 61
    204c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,SREG_I);
    204e:	af e5       	ldi	r26, 0x5F	; 95
    2050:	b0 e0       	ldi	r27, 0x00	; 0
    2052:	ef e5       	ldi	r30, 0x5F	; 95
    2054:	f0 e0       	ldi	r31, 0x00	; 0
    2056:	80 81       	ld	r24, Z
    2058:	80 68       	ori	r24, 0x80	; 128
    205a:	8c 93       	st	X, r24
}
    205c:	cf 91       	pop	r28
    205e:	df 91       	pop	r29
    2060:	08 95       	ret

00002062 <GI_voidDisable>:
void GI_voidDisable(void){
    2062:	df 93       	push	r29
    2064:	cf 93       	push	r28
    2066:	cd b7       	in	r28, 0x3d	; 61
    2068:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,SREG_I);
    206a:	af e5       	ldi	r26, 0x5F	; 95
    206c:	b0 e0       	ldi	r27, 0x00	; 0
    206e:	ef e5       	ldi	r30, 0x5F	; 95
    2070:	f0 e0       	ldi	r31, 0x00	; 0
    2072:	80 81       	ld	r24, Z
    2074:	8f 77       	andi	r24, 0x7F	; 127
    2076:	8c 93       	st	X, r24
}
    2078:	cf 91       	pop	r28
    207a:	df 91       	pop	r29
    207c:	08 95       	ret

0000207e <SWITCH_u8IsPressed>:
#include "SW_interface.h"
#include "SW_private.h"
#include "SW_config.h"

u8 SWITCH_u8IsPressed(SWITCH_t Switch)
{
    207e:	df 93       	push	r29
    2080:	cf 93       	push	r28
    2082:	00 d0       	rcall	.+0      	; 0x2084 <SWITCH_u8IsPressed+0x6>
    2084:	00 d0       	rcall	.+0      	; 0x2086 <SWITCH_u8IsPressed+0x8>
    2086:	0f 92       	push	r0
    2088:	cd b7       	in	r28, 0x3d	; 61
    208a:	de b7       	in	r29, 0x3e	; 62
    208c:	6b 83       	std	Y+3, r22	; 0x03
    208e:	7c 83       	std	Y+4, r23	; 0x04
    2090:	8d 83       	std	Y+5, r24	; 0x05
	u8 IsPressed = 0;
    2092:	1a 82       	std	Y+2, r1	; 0x02
	u8 PinValue = DIO_u8GetPinValue(Switch.PortNumber , Switch.PinNumber);
    2094:	8b 81       	ldd	r24, Y+3	; 0x03
    2096:	48 2f       	mov	r20, r24
    2098:	50 e0       	ldi	r21, 0x00	; 0
    209a:	8c 81       	ldd	r24, Y+4	; 0x04
    209c:	28 2f       	mov	r18, r24
    209e:	30 e0       	ldi	r19, 0x00	; 0
    20a0:	ca 01       	movw	r24, r20
    20a2:	b9 01       	movw	r22, r18
    20a4:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <DIO_u8GetPinValue>
    20a8:	89 83       	std	Y+1, r24	; 0x01
	if(PULL_UP == Switch.Type)
    20aa:	8d 81       	ldd	r24, Y+5	; 0x05
    20ac:	88 23       	and	r24, r24
    20ae:	31 f4       	brne	.+12     	; 0x20bc <SWITCH_u8IsPressed+0x3e>
	{
		if(PinValue == RELEASED)
    20b0:	89 81       	ldd	r24, Y+1	; 0x01
    20b2:	88 23       	and	r24, r24
    20b4:	59 f4       	brne	.+22     	; 0x20cc <SWITCH_u8IsPressed+0x4e>
		{
			IsPressed = 1;
    20b6:	81 e0       	ldi	r24, 0x01	; 1
    20b8:	8a 83       	std	Y+2, r24	; 0x02
    20ba:	08 c0       	rjmp	.+16     	; 0x20cc <SWITCH_u8IsPressed+0x4e>
		}

	}
	else if(PULL_DOWN == Switch.Type)
    20bc:	8d 81       	ldd	r24, Y+5	; 0x05
    20be:	81 30       	cpi	r24, 0x01	; 1
    20c0:	29 f4       	brne	.+10     	; 0x20cc <SWITCH_u8IsPressed+0x4e>
	{
		if(PinValue == PRESSED)
    20c2:	89 81       	ldd	r24, Y+1	; 0x01
    20c4:	81 30       	cpi	r24, 0x01	; 1
    20c6:	11 f4       	brne	.+4      	; 0x20cc <SWITCH_u8IsPressed+0x4e>
		{
			IsPressed = 1;
    20c8:	81 e0       	ldi	r24, 0x01	; 1
    20ca:	8a 83       	std	Y+2, r24	; 0x02
		}
	}
	return IsPressed;
    20cc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    20ce:	0f 90       	pop	r0
    20d0:	0f 90       	pop	r0
    20d2:	0f 90       	pop	r0
    20d4:	0f 90       	pop	r0
    20d6:	0f 90       	pop	r0
    20d8:	cf 91       	pop	r28
    20da:	df 91       	pop	r29
    20dc:	08 95       	ret

000020de <TWI_voidMasterInit>:
#include "BIT_MATH.h"
#include "TWI_Register.h"
#include "TWI_Interface.h"

void TWI_voidMasterInit(u8 Copy_MasterAddress)
{
    20de:	df 93       	push	r29
    20e0:	cf 93       	push	r28
    20e2:	0f 92       	push	r0
    20e4:	cd b7       	in	r28, 0x3d	; 61
    20e6:	de b7       	in	r29, 0x3e	; 62
    20e8:	89 83       	std	Y+1, r24	; 0x01
	TWBR = 12;
    20ea:	e0 e2       	ldi	r30, 0x20	; 32
    20ec:	f0 e0       	ldi	r31, 0x00	; 0
    20ee:	8c e0       	ldi	r24, 0x0C	; 12
    20f0:	80 83       	st	Z, r24

	CLR_BIT(TWSR,TWSR_TWPS0);
    20f2:	a1 e2       	ldi	r26, 0x21	; 33
    20f4:	b0 e0       	ldi	r27, 0x00	; 0
    20f6:	e1 e2       	ldi	r30, 0x21	; 33
    20f8:	f0 e0       	ldi	r31, 0x00	; 0
    20fa:	80 81       	ld	r24, Z
    20fc:	8e 7f       	andi	r24, 0xFE	; 254
    20fe:	8c 93       	st	X, r24
	CLR_BIT(TWSR,TWSR_TWPS1);
    2100:	a1 e2       	ldi	r26, 0x21	; 33
    2102:	b0 e0       	ldi	r27, 0x00	; 0
    2104:	e1 e2       	ldi	r30, 0x21	; 33
    2106:	f0 e0       	ldi	r31, 0x00	; 0
    2108:	80 81       	ld	r24, Z
    210a:	8d 7f       	andi	r24, 0xFD	; 253
    210c:	8c 93       	st	X, r24

	SET_BIT(TWCR,TWCR_TWEA);
    210e:	a6 e5       	ldi	r26, 0x56	; 86
    2110:	b0 e0       	ldi	r27, 0x00	; 0
    2112:	e6 e5       	ldi	r30, 0x56	; 86
    2114:	f0 e0       	ldi	r31, 0x00	; 0
    2116:	80 81       	ld	r24, Z
    2118:	80 64       	ori	r24, 0x40	; 64
    211a:	8c 93       	st	X, r24

	TWAR = Copy_MasterAddress<<1;
    211c:	e2 e2       	ldi	r30, 0x22	; 34
    211e:	f0 e0       	ldi	r31, 0x00	; 0
    2120:	89 81       	ldd	r24, Y+1	; 0x01
    2122:	88 0f       	add	r24, r24
    2124:	80 83       	st	Z, r24

	SET_BIT(TWCR,TWCR_TWEN);
    2126:	a6 e5       	ldi	r26, 0x56	; 86
    2128:	b0 e0       	ldi	r27, 0x00	; 0
    212a:	e6 e5       	ldi	r30, 0x56	; 86
    212c:	f0 e0       	ldi	r31, 0x00	; 0
    212e:	80 81       	ld	r24, Z
    2130:	84 60       	ori	r24, 0x04	; 4
    2132:	8c 93       	st	X, r24
}
    2134:	0f 90       	pop	r0
    2136:	cf 91       	pop	r28
    2138:	df 91       	pop	r29
    213a:	08 95       	ret

0000213c <TWI_voidSlaveInit>:

void TWI_voidSlaveInit(u8 Copy_SlaveAddress)
{
    213c:	df 93       	push	r29
    213e:	cf 93       	push	r28
    2140:	0f 92       	push	r0
    2142:	cd b7       	in	r28, 0x3d	; 61
    2144:	de b7       	in	r29, 0x3e	; 62
    2146:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(TWCR,TWCR_TWEA);
    2148:	a6 e5       	ldi	r26, 0x56	; 86
    214a:	b0 e0       	ldi	r27, 0x00	; 0
    214c:	e6 e5       	ldi	r30, 0x56	; 86
    214e:	f0 e0       	ldi	r31, 0x00	; 0
    2150:	80 81       	ld	r24, Z
    2152:	80 64       	ori	r24, 0x40	; 64
    2154:	8c 93       	st	X, r24

	TWAR = Copy_SlaveAddress<<1;
    2156:	e2 e2       	ldi	r30, 0x22	; 34
    2158:	f0 e0       	ldi	r31, 0x00	; 0
    215a:	89 81       	ldd	r24, Y+1	; 0x01
    215c:	88 0f       	add	r24, r24
    215e:	80 83       	st	Z, r24

	SET_BIT(TWCR,TWCR_TWEN);
    2160:	a6 e5       	ldi	r26, 0x56	; 86
    2162:	b0 e0       	ldi	r27, 0x00	; 0
    2164:	e6 e5       	ldi	r30, 0x56	; 86
    2166:	f0 e0       	ldi	r31, 0x00	; 0
    2168:	80 81       	ld	r24, Z
    216a:	84 60       	ori	r24, 0x04	; 4
    216c:	8c 93       	st	X, r24
}
    216e:	0f 90       	pop	r0
    2170:	cf 91       	pop	r28
    2172:	df 91       	pop	r29
    2174:	08 95       	ret

00002176 <TWI_voidStartCondition>:

void TWI_voidStartCondition()
{
    2176:	df 93       	push	r29
    2178:	cf 93       	push	r28
    217a:	cd b7       	in	r28, 0x3d	; 61
    217c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TWCR,TWCR_TWSTA);
    217e:	a6 e5       	ldi	r26, 0x56	; 86
    2180:	b0 e0       	ldi	r27, 0x00	; 0
    2182:	e6 e5       	ldi	r30, 0x56	; 86
    2184:	f0 e0       	ldi	r31, 0x00	; 0
    2186:	80 81       	ld	r24, Z
    2188:	80 62       	ori	r24, 0x20	; 32
    218a:	8c 93       	st	X, r24

	SET_BIT(TWCR,TWCR_TWINT);
    218c:	a6 e5       	ldi	r26, 0x56	; 86
    218e:	b0 e0       	ldi	r27, 0x00	; 0
    2190:	e6 e5       	ldi	r30, 0x56	; 86
    2192:	f0 e0       	ldi	r31, 0x00	; 0
    2194:	80 81       	ld	r24, Z
    2196:	80 68       	ori	r24, 0x80	; 128
    2198:	8c 93       	st	X, r24

	while( GET_BIT(TWCR,TWCR_TWINT) == 0 );
    219a:	e6 e5       	ldi	r30, 0x56	; 86
    219c:	f0 e0       	ldi	r31, 0x00	; 0
    219e:	80 81       	ld	r24, Z
    21a0:	88 23       	and	r24, r24
    21a2:	dc f7       	brge	.-10     	; 0x219a <TWI_voidStartCondition+0x24>
}
    21a4:	cf 91       	pop	r28
    21a6:	df 91       	pop	r29
    21a8:	08 95       	ret

000021aa <TWI_voidSendSlaveAddressWithWrite>:

void TWI_voidSendSlaveAddressWithWrite(u8 Copy_u8SlaveAddress)
{
    21aa:	df 93       	push	r29
    21ac:	cf 93       	push	r28
    21ae:	0f 92       	push	r0
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
    21b4:	89 83       	std	Y+1, r24	; 0x01
	TWDR = Copy_u8SlaveAddress<<1;
    21b6:	e3 e2       	ldi	r30, 0x23	; 35
    21b8:	f0 e0       	ldi	r31, 0x00	; 0
    21ba:	89 81       	ldd	r24, Y+1	; 0x01
    21bc:	88 0f       	add	r24, r24
    21be:	80 83       	st	Z, r24
	CLR_BIT(TWDR,0);
    21c0:	a3 e2       	ldi	r26, 0x23	; 35
    21c2:	b0 e0       	ldi	r27, 0x00	; 0
    21c4:	e3 e2       	ldi	r30, 0x23	; 35
    21c6:	f0 e0       	ldi	r31, 0x00	; 0
    21c8:	80 81       	ld	r24, Z
    21ca:	8e 7f       	andi	r24, 0xFE	; 254
    21cc:	8c 93       	st	X, r24

	CLR_BIT(TWCR,TWCR_TWSTA);
    21ce:	a6 e5       	ldi	r26, 0x56	; 86
    21d0:	b0 e0       	ldi	r27, 0x00	; 0
    21d2:	e6 e5       	ldi	r30, 0x56	; 86
    21d4:	f0 e0       	ldi	r31, 0x00	; 0
    21d6:	80 81       	ld	r24, Z
    21d8:	8f 7d       	andi	r24, 0xDF	; 223
    21da:	8c 93       	st	X, r24

	SET_BIT(TWCR,TWCR_TWINT);
    21dc:	a6 e5       	ldi	r26, 0x56	; 86
    21de:	b0 e0       	ldi	r27, 0x00	; 0
    21e0:	e6 e5       	ldi	r30, 0x56	; 86
    21e2:	f0 e0       	ldi	r31, 0x00	; 0
    21e4:	80 81       	ld	r24, Z
    21e6:	80 68       	ori	r24, 0x80	; 128
    21e8:	8c 93       	st	X, r24

	while( GET_BIT(TWCR,TWCR_TWINT) == 0 );
    21ea:	e6 e5       	ldi	r30, 0x56	; 86
    21ec:	f0 e0       	ldi	r31, 0x00	; 0
    21ee:	80 81       	ld	r24, Z
    21f0:	88 23       	and	r24, r24
    21f2:	dc f7       	brge	.-10     	; 0x21ea <TWI_voidSendSlaveAddressWithWrite+0x40>
}
    21f4:	0f 90       	pop	r0
    21f6:	cf 91       	pop	r28
    21f8:	df 91       	pop	r29
    21fa:	08 95       	ret

000021fc <TWI_voidSendSLaveAddressWithRead>:

void TWI_voidSendSLaveAddressWithRead(u8 Copy_u8SlaveAddress)
{
    21fc:	df 93       	push	r29
    21fe:	cf 93       	push	r28
    2200:	0f 92       	push	r0
    2202:	cd b7       	in	r28, 0x3d	; 61
    2204:	de b7       	in	r29, 0x3e	; 62
    2206:	89 83       	std	Y+1, r24	; 0x01
	TWDR = Copy_u8SlaveAddress<<1;
    2208:	e3 e2       	ldi	r30, 0x23	; 35
    220a:	f0 e0       	ldi	r31, 0x00	; 0
    220c:	89 81       	ldd	r24, Y+1	; 0x01
    220e:	88 0f       	add	r24, r24
    2210:	80 83       	st	Z, r24
	SET_BIT(TWDR,0);
    2212:	a3 e2       	ldi	r26, 0x23	; 35
    2214:	b0 e0       	ldi	r27, 0x00	; 0
    2216:	e3 e2       	ldi	r30, 0x23	; 35
    2218:	f0 e0       	ldi	r31, 0x00	; 0
    221a:	80 81       	ld	r24, Z
    221c:	81 60       	ori	r24, 0x01	; 1
    221e:	8c 93       	st	X, r24

	CLR_BIT(TWCR,TWCR_TWSTA);
    2220:	a6 e5       	ldi	r26, 0x56	; 86
    2222:	b0 e0       	ldi	r27, 0x00	; 0
    2224:	e6 e5       	ldi	r30, 0x56	; 86
    2226:	f0 e0       	ldi	r31, 0x00	; 0
    2228:	80 81       	ld	r24, Z
    222a:	8f 7d       	andi	r24, 0xDF	; 223
    222c:	8c 93       	st	X, r24

	SET_BIT(TWCR,TWCR_TWINT);
    222e:	a6 e5       	ldi	r26, 0x56	; 86
    2230:	b0 e0       	ldi	r27, 0x00	; 0
    2232:	e6 e5       	ldi	r30, 0x56	; 86
    2234:	f0 e0       	ldi	r31, 0x00	; 0
    2236:	80 81       	ld	r24, Z
    2238:	80 68       	ori	r24, 0x80	; 128
    223a:	8c 93       	st	X, r24

	while( GET_BIT(TWCR,TWCR_TWINT) == 0 );
    223c:	e6 e5       	ldi	r30, 0x56	; 86
    223e:	f0 e0       	ldi	r31, 0x00	; 0
    2240:	80 81       	ld	r24, Z
    2242:	88 23       	and	r24, r24
    2244:	dc f7       	brge	.-10     	; 0x223c <TWI_voidSendSLaveAddressWithRead+0x40>
}
    2246:	0f 90       	pop	r0
    2248:	cf 91       	pop	r28
    224a:	df 91       	pop	r29
    224c:	08 95       	ret

0000224e <TWI_voidSendData>:

void TWI_voidSendData(u8 Copy_u8Data)
{
    224e:	df 93       	push	r29
    2250:	cf 93       	push	r28
    2252:	0f 92       	push	r0
    2254:	cd b7       	in	r28, 0x3d	; 61
    2256:	de b7       	in	r29, 0x3e	; 62
    2258:	89 83       	std	Y+1, r24	; 0x01
	TWDR = Copy_u8Data;
    225a:	e3 e2       	ldi	r30, 0x23	; 35
    225c:	f0 e0       	ldi	r31, 0x00	; 0
    225e:	89 81       	ldd	r24, Y+1	; 0x01
    2260:	80 83       	st	Z, r24

	SET_BIT(TWCR,TWCR_TWINT);
    2262:	a6 e5       	ldi	r26, 0x56	; 86
    2264:	b0 e0       	ldi	r27, 0x00	; 0
    2266:	e6 e5       	ldi	r30, 0x56	; 86
    2268:	f0 e0       	ldi	r31, 0x00	; 0
    226a:	80 81       	ld	r24, Z
    226c:	80 68       	ori	r24, 0x80	; 128
    226e:	8c 93       	st	X, r24

	while( GET_BIT(TWCR,TWCR_TWINT) == 0 );
    2270:	e6 e5       	ldi	r30, 0x56	; 86
    2272:	f0 e0       	ldi	r31, 0x00	; 0
    2274:	80 81       	ld	r24, Z
    2276:	88 23       	and	r24, r24
    2278:	dc f7       	brge	.-10     	; 0x2270 <TWI_voidSendData+0x22>
}
    227a:	0f 90       	pop	r0
    227c:	cf 91       	pop	r28
    227e:	df 91       	pop	r29
    2280:	08 95       	ret

00002282 <TWI_u8RecieveData>:

u8 TWI_u8RecieveData()
{
    2282:	df 93       	push	r29
    2284:	cf 93       	push	r28
    2286:	cd b7       	in	r28, 0x3d	; 61
    2288:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TWCR,TWCR_TWINT);
    228a:	a6 e5       	ldi	r26, 0x56	; 86
    228c:	b0 e0       	ldi	r27, 0x00	; 0
    228e:	e6 e5       	ldi	r30, 0x56	; 86
    2290:	f0 e0       	ldi	r31, 0x00	; 0
    2292:	80 81       	ld	r24, Z
    2294:	80 68       	ori	r24, 0x80	; 128
    2296:	8c 93       	st	X, r24

	while( GET_BIT(TWCR,TWCR_TWINT) == 0 );
    2298:	e6 e5       	ldi	r30, 0x56	; 86
    229a:	f0 e0       	ldi	r31, 0x00	; 0
    229c:	80 81       	ld	r24, Z
    229e:	88 23       	and	r24, r24
    22a0:	dc f7       	brge	.-10     	; 0x2298 <TWI_u8RecieveData+0x16>

	return TWDR;
    22a2:	e3 e2       	ldi	r30, 0x23	; 35
    22a4:	f0 e0       	ldi	r31, 0x00	; 0
    22a6:	80 81       	ld	r24, Z
}
    22a8:	cf 91       	pop	r28
    22aa:	df 91       	pop	r29
    22ac:	08 95       	ret

000022ae <TWI_voidStopCondition>:

void TWI_voidStopCondition()
{
    22ae:	df 93       	push	r29
    22b0:	cf 93       	push	r28
    22b2:	cd b7       	in	r28, 0x3d	; 61
    22b4:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TWCR,TWCR_TWSTO);
    22b6:	a6 e5       	ldi	r26, 0x56	; 86
    22b8:	b0 e0       	ldi	r27, 0x00	; 0
    22ba:	e6 e5       	ldi	r30, 0x56	; 86
    22bc:	f0 e0       	ldi	r31, 0x00	; 0
    22be:	80 81       	ld	r24, Z
    22c0:	80 61       	ori	r24, 0x10	; 16
    22c2:	8c 93       	st	X, r24
}
    22c4:	cf 91       	pop	r28
    22c6:	df 91       	pop	r29
    22c8:	08 95       	ret

000022ca <UART_voidInit>:
#include "UART_interface.h"
#include "UART_config.h"
#include "UART_private.h"

void UART_voidInit()
{
    22ca:	df 93       	push	r29
    22cc:	cf 93       	push	r28
    22ce:	0f 92       	push	r0
    22d0:	cd b7       	in	r28, 0x3d	; 61
    22d2:	de b7       	in	r29, 0x3e	; 62
	u8 Local_u8CtrlCvalue=0;
    22d4:	19 82       	std	Y+1, r1	; 0x01
	SET_BIT(Local_u8CtrlCvalue,7);
    22d6:	89 81       	ldd	r24, Y+1	; 0x01
    22d8:	80 68       	ori	r24, 0x80	; 128
    22da:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(Local_u8CtrlCvalue,1);
    22dc:	89 81       	ldd	r24, Y+1	; 0x01
    22de:	82 60       	ori	r24, 0x02	; 2
    22e0:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(Local_u8CtrlCvalue,2);
    22e2:	89 81       	ldd	r24, Y+1	; 0x01
    22e4:	84 60       	ori	r24, 0x04	; 4
    22e6:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(Local_u8CtrlCvalue,3);
    22e8:	89 81       	ldd	r24, Y+1	; 0x01
    22ea:	87 7f       	andi	r24, 0xF7	; 247
    22ec:	89 83       	std	Y+1, r24	; 0x01
	UCSRC=Local_u8CtrlCvalue;
    22ee:	e0 e4       	ldi	r30, 0x40	; 64
    22f0:	f0 e0       	ldi	r31, 0x00	; 0
    22f2:	89 81       	ldd	r24, Y+1	; 0x01
    22f4:	80 83       	st	Z, r24
	//NO INT
	//NO PARITY
	//UART
	//9600 BaudRate
	UBRRL=51;
    22f6:	e9 e2       	ldi	r30, 0x29	; 41
    22f8:	f0 e0       	ldi	r31, 0x00	; 0
    22fa:	83 e3       	ldi	r24, 0x33	; 51
    22fc:	80 83       	st	Z, r24
	//Ch size -> 8 bits
	CLR_BIT(UCSRB,2);
    22fe:	aa e2       	ldi	r26, 0x2A	; 42
    2300:	b0 e0       	ldi	r27, 0x00	; 0
    2302:	ea e2       	ldi	r30, 0x2A	; 42
    2304:	f0 e0       	ldi	r31, 0x00	; 0
    2306:	80 81       	ld	r24, Z
    2308:	8b 7f       	andi	r24, 0xFB	; 251
    230a:	8c 93       	st	X, r24
	//full duplex
	SET_BIT(UCSRB,3);
    230c:	aa e2       	ldi	r26, 0x2A	; 42
    230e:	b0 e0       	ldi	r27, 0x00	; 0
    2310:	ea e2       	ldi	r30, 0x2A	; 42
    2312:	f0 e0       	ldi	r31, 0x00	; 0
    2314:	80 81       	ld	r24, Z
    2316:	88 60       	ori	r24, 0x08	; 8
    2318:	8c 93       	st	X, r24
	SET_BIT(UCSRB,4);
    231a:	aa e2       	ldi	r26, 0x2A	; 42
    231c:	b0 e0       	ldi	r27, 0x00	; 0
    231e:	ea e2       	ldi	r30, 0x2A	; 42
    2320:	f0 e0       	ldi	r31, 0x00	; 0
    2322:	80 81       	ld	r24, Z
    2324:	80 61       	ori	r24, 0x10	; 16
    2326:	8c 93       	st	X, r24
}
    2328:	0f 90       	pop	r0
    232a:	cf 91       	pop	r28
    232c:	df 91       	pop	r29
    232e:	08 95       	ret

00002330 <UART_voidSendData>:
void UART_voidSendData(u8 Copy_u8Data)
{
    2330:	df 93       	push	r29
    2332:	cf 93       	push	r28
    2334:	0f 92       	push	r0
    2336:	cd b7       	in	r28, 0x3d	; 61
    2338:	de b7       	in	r29, 0x3e	; 62
    233a:	89 83       	std	Y+1, r24	; 0x01
	//Polling UDRE -> Send Data
	while(!GET_BIT(UCSRA,5));
    233c:	eb e2       	ldi	r30, 0x2B	; 43
    233e:	f0 e0       	ldi	r31, 0x00	; 0
    2340:	80 81       	ld	r24, Z
    2342:	82 95       	swap	r24
    2344:	86 95       	lsr	r24
    2346:	87 70       	andi	r24, 0x07	; 7
    2348:	88 2f       	mov	r24, r24
    234a:	90 e0       	ldi	r25, 0x00	; 0
    234c:	81 70       	andi	r24, 0x01	; 1
    234e:	90 70       	andi	r25, 0x00	; 0
    2350:	00 97       	sbiw	r24, 0x00	; 0
    2352:	a1 f3       	breq	.-24     	; 0x233c <UART_voidSendData+0xc>
	UDR=Copy_u8Data;
    2354:	ec e2       	ldi	r30, 0x2C	; 44
    2356:	f0 e0       	ldi	r31, 0x00	; 0
    2358:	89 81       	ldd	r24, Y+1	; 0x01
    235a:	80 83       	st	Z, r24
}
    235c:	0f 90       	pop	r0
    235e:	cf 91       	pop	r28
    2360:	df 91       	pop	r29
    2362:	08 95       	ret

00002364 <UART_u8ReceiveData>:
u8 UART_u8ReceiveData()
{
    2364:	df 93       	push	r29
    2366:	cf 93       	push	r28
    2368:	cd b7       	in	r28, 0x3d	; 61
    236a:	de b7       	in	r29, 0x3e	; 62
	while(!GET_BIT(UCSRA,7));
    236c:	eb e2       	ldi	r30, 0x2B	; 43
    236e:	f0 e0       	ldi	r31, 0x00	; 0
    2370:	80 81       	ld	r24, Z
    2372:	88 23       	and	r24, r24
    2374:	dc f7       	brge	.-10     	; 0x236c <UART_u8ReceiveData+0x8>
	return UDR;
    2376:	ec e2       	ldi	r30, 0x2C	; 44
    2378:	f0 e0       	ldi	r31, 0x00	; 0
    237a:	80 81       	ld	r24, Z
}
    237c:	cf 91       	pop	r28
    237e:	df 91       	pop	r29
    2380:	08 95       	ret

00002382 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2382:	df 93       	push	r29
    2384:	cf 93       	push	r28
    2386:	cd b7       	in	r28, 0x3d	; 61
    2388:	de b7       	in	r29, 0x3e	; 62
    238a:	27 97       	sbiw	r28, 0x07	; 7
    238c:	0f b6       	in	r0, 0x3f	; 63
    238e:	f8 94       	cli
    2390:	de bf       	out	0x3e, r29	; 62
    2392:	0f be       	out	0x3f, r0	; 63
    2394:	cd bf       	out	0x3d, r28	; 61
    2396:	9d 83       	std	Y+5, r25	; 0x05
    2398:	8c 83       	std	Y+4, r24	; 0x04
    239a:	6e 83       	std	Y+6, r22	; 0x06
    239c:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    239e:	8a e1       	ldi	r24, 0x1A	; 26
    23a0:	90 e0       	ldi	r25, 0x00	; 0
    23a2:	0e 94 99 14 	call	0x2932	; 0x2932 <pvPortMalloc>
    23a6:	9a 83       	std	Y+2, r25	; 0x02
    23a8:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    23aa:	89 81       	ldd	r24, Y+1	; 0x01
    23ac:	9a 81       	ldd	r25, Y+2	; 0x02
    23ae:	00 97       	sbiw	r24, 0x00	; 0
    23b0:	09 f4       	brne	.+2      	; 0x23b4 <xCoRoutineCreate+0x32>
    23b2:	6f c0       	rjmp	.+222    	; 0x2492 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    23b4:	80 91 2e 01 	lds	r24, 0x012E
    23b8:	90 91 2f 01 	lds	r25, 0x012F
    23bc:	00 97       	sbiw	r24, 0x00	; 0
    23be:	41 f4       	brne	.+16     	; 0x23d0 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    23c0:	89 81       	ldd	r24, Y+1	; 0x01
    23c2:	9a 81       	ldd	r25, Y+2	; 0x02
    23c4:	90 93 2f 01 	sts	0x012F, r25
    23c8:	80 93 2e 01 	sts	0x012E, r24
			prvInitialiseCoRoutineLists();
    23cc:	0e 94 28 14 	call	0x2850	; 0x2850 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    23d0:	8e 81       	ldd	r24, Y+6	; 0x06
    23d2:	82 30       	cpi	r24, 0x02	; 2
    23d4:	10 f0       	brcs	.+4      	; 0x23da <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    23d6:	81 e0       	ldi	r24, 0x01	; 1
    23d8:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    23da:	e9 81       	ldd	r30, Y+1	; 0x01
    23dc:	fa 81       	ldd	r31, Y+2	; 0x02
    23de:	11 8e       	std	Z+25, r1	; 0x19
    23e0:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    23e2:	e9 81       	ldd	r30, Y+1	; 0x01
    23e4:	fa 81       	ldd	r31, Y+2	; 0x02
    23e6:	8e 81       	ldd	r24, Y+6	; 0x06
    23e8:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    23ea:	e9 81       	ldd	r30, Y+1	; 0x01
    23ec:	fa 81       	ldd	r31, Y+2	; 0x02
    23ee:	8f 81       	ldd	r24, Y+7	; 0x07
    23f0:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    23f2:	e9 81       	ldd	r30, Y+1	; 0x01
    23f4:	fa 81       	ldd	r31, Y+2	; 0x02
    23f6:	8c 81       	ldd	r24, Y+4	; 0x04
    23f8:	9d 81       	ldd	r25, Y+5	; 0x05
    23fa:	91 83       	std	Z+1, r25	; 0x01
    23fc:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    23fe:	89 81       	ldd	r24, Y+1	; 0x01
    2400:	9a 81       	ldd	r25, Y+2	; 0x02
    2402:	02 96       	adiw	r24, 0x02	; 2
    2404:	0e 94 2f 15 	call	0x2a5e	; 0x2a5e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2408:	89 81       	ldd	r24, Y+1	; 0x01
    240a:	9a 81       	ldd	r25, Y+2	; 0x02
    240c:	0c 96       	adiw	r24, 0x0c	; 12
    240e:	0e 94 2f 15 	call	0x2a5e	; 0x2a5e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2412:	e9 81       	ldd	r30, Y+1	; 0x01
    2414:	fa 81       	ldd	r31, Y+2	; 0x02
    2416:	89 81       	ldd	r24, Y+1	; 0x01
    2418:	9a 81       	ldd	r25, Y+2	; 0x02
    241a:	91 87       	std	Z+9, r25	; 0x09
    241c:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    241e:	e9 81       	ldd	r30, Y+1	; 0x01
    2420:	fa 81       	ldd	r31, Y+2	; 0x02
    2422:	89 81       	ldd	r24, Y+1	; 0x01
    2424:	9a 81       	ldd	r25, Y+2	; 0x02
    2426:	93 8b       	std	Z+19, r25	; 0x13
    2428:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    242a:	8e 81       	ldd	r24, Y+6	; 0x06
    242c:	28 2f       	mov	r18, r24
    242e:	30 e0       	ldi	r19, 0x00	; 0
    2430:	85 e0       	ldi	r24, 0x05	; 5
    2432:	90 e0       	ldi	r25, 0x00	; 0
    2434:	82 1b       	sub	r24, r18
    2436:	93 0b       	sbc	r25, r19
    2438:	e9 81       	ldd	r30, Y+1	; 0x01
    243a:	fa 81       	ldd	r31, Y+2	; 0x02
    243c:	95 87       	std	Z+13, r25	; 0x0d
    243e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2440:	e9 81       	ldd	r30, Y+1	; 0x01
    2442:	fa 81       	ldd	r31, Y+2	; 0x02
    2444:	96 89       	ldd	r25, Z+22	; 0x16
    2446:	80 91 30 01 	lds	r24, 0x0130
    244a:	89 17       	cp	r24, r25
    244c:	28 f4       	brcc	.+10     	; 0x2458 <xCoRoutineCreate+0xd6>
    244e:	e9 81       	ldd	r30, Y+1	; 0x01
    2450:	fa 81       	ldd	r31, Y+2	; 0x02
    2452:	86 89       	ldd	r24, Z+22	; 0x16
    2454:	80 93 30 01 	sts	0x0130, r24
    2458:	e9 81       	ldd	r30, Y+1	; 0x01
    245a:	fa 81       	ldd	r31, Y+2	; 0x02
    245c:	86 89       	ldd	r24, Z+22	; 0x16
    245e:	28 2f       	mov	r18, r24
    2460:	30 e0       	ldi	r19, 0x00	; 0
    2462:	c9 01       	movw	r24, r18
    2464:	88 0f       	add	r24, r24
    2466:	99 1f       	adc	r25, r25
    2468:	88 0f       	add	r24, r24
    246a:	99 1f       	adc	r25, r25
    246c:	88 0f       	add	r24, r24
    246e:	99 1f       	adc	r25, r25
    2470:	82 0f       	add	r24, r18
    2472:	93 1f       	adc	r25, r19
    2474:	ac 01       	movw	r20, r24
    2476:	49 5c       	subi	r20, 0xC9	; 201
    2478:	5e 4f       	sbci	r21, 0xFE	; 254
    247a:	89 81       	ldd	r24, Y+1	; 0x01
    247c:	9a 81       	ldd	r25, Y+2	; 0x02
    247e:	9c 01       	movw	r18, r24
    2480:	2e 5f       	subi	r18, 0xFE	; 254
    2482:	3f 4f       	sbci	r19, 0xFF	; 255
    2484:	ca 01       	movw	r24, r20
    2486:	b9 01       	movw	r22, r18
    2488:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <vListInsertEnd>

		xReturn = pdPASS;
    248c:	81 e0       	ldi	r24, 0x01	; 1
    248e:	8b 83       	std	Y+3, r24	; 0x03
    2490:	02 c0       	rjmp	.+4      	; 0x2496 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2492:	8f ef       	ldi	r24, 0xFF	; 255
    2494:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    2496:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2498:	27 96       	adiw	r28, 0x07	; 7
    249a:	0f b6       	in	r0, 0x3f	; 63
    249c:	f8 94       	cli
    249e:	de bf       	out	0x3e, r29	; 62
    24a0:	0f be       	out	0x3f, r0	; 63
    24a2:	cd bf       	out	0x3d, r28	; 61
    24a4:	cf 91       	pop	r28
    24a6:	df 91       	pop	r29
    24a8:	08 95       	ret

000024aa <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    24aa:	df 93       	push	r29
    24ac:	cf 93       	push	r28
    24ae:	00 d0       	rcall	.+0      	; 0x24b0 <vCoRoutineAddToDelayedList+0x6>
    24b0:	00 d0       	rcall	.+0      	; 0x24b2 <vCoRoutineAddToDelayedList+0x8>
    24b2:	00 d0       	rcall	.+0      	; 0x24b4 <vCoRoutineAddToDelayedList+0xa>
    24b4:	cd b7       	in	r28, 0x3d	; 61
    24b6:	de b7       	in	r29, 0x3e	; 62
    24b8:	9c 83       	std	Y+4, r25	; 0x04
    24ba:	8b 83       	std	Y+3, r24	; 0x03
    24bc:	7e 83       	std	Y+6, r23	; 0x06
    24be:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    24c0:	20 91 31 01 	lds	r18, 0x0131
    24c4:	30 91 32 01 	lds	r19, 0x0132
    24c8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ca:	9c 81       	ldd	r25, Y+4	; 0x04
    24cc:	82 0f       	add	r24, r18
    24ce:	93 1f       	adc	r25, r19
    24d0:	9a 83       	std	Y+2, r25	; 0x02
    24d2:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    24d4:	80 91 2e 01 	lds	r24, 0x012E
    24d8:	90 91 2f 01 	lds	r25, 0x012F
    24dc:	02 96       	adiw	r24, 0x02	; 2
    24de:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    24e2:	e0 91 2e 01 	lds	r30, 0x012E
    24e6:	f0 91 2f 01 	lds	r31, 0x012F
    24ea:	89 81       	ldd	r24, Y+1	; 0x01
    24ec:	9a 81       	ldd	r25, Y+2	; 0x02
    24ee:	93 83       	std	Z+3, r25	; 0x03
    24f0:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    24f2:	20 91 31 01 	lds	r18, 0x0131
    24f6:	30 91 32 01 	lds	r19, 0x0132
    24fa:	89 81       	ldd	r24, Y+1	; 0x01
    24fc:	9a 81       	ldd	r25, Y+2	; 0x02
    24fe:	82 17       	cp	r24, r18
    2500:	93 07       	cpc	r25, r19
    2502:	70 f4       	brcc	.+28     	; 0x2520 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2504:	80 91 5d 01 	lds	r24, 0x015D
    2508:	90 91 5e 01 	lds	r25, 0x015E
    250c:	20 91 2e 01 	lds	r18, 0x012E
    2510:	30 91 2f 01 	lds	r19, 0x012F
    2514:	2e 5f       	subi	r18, 0xFE	; 254
    2516:	3f 4f       	sbci	r19, 0xFF	; 255
    2518:	b9 01       	movw	r22, r18
    251a:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <vListInsert>
    251e:	0d c0       	rjmp	.+26     	; 0x253a <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2520:	80 91 5b 01 	lds	r24, 0x015B
    2524:	90 91 5c 01 	lds	r25, 0x015C
    2528:	20 91 2e 01 	lds	r18, 0x012E
    252c:	30 91 2f 01 	lds	r19, 0x012F
    2530:	2e 5f       	subi	r18, 0xFE	; 254
    2532:	3f 4f       	sbci	r19, 0xFF	; 255
    2534:	b9 01       	movw	r22, r18
    2536:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <vListInsert>
	}

	if( pxEventList )
    253a:	8d 81       	ldd	r24, Y+5	; 0x05
    253c:	9e 81       	ldd	r25, Y+6	; 0x06
    253e:	00 97       	sbiw	r24, 0x00	; 0
    2540:	61 f0       	breq	.+24     	; 0x255a <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2542:	80 91 2e 01 	lds	r24, 0x012E
    2546:	90 91 2f 01 	lds	r25, 0x012F
    254a:	9c 01       	movw	r18, r24
    254c:	24 5f       	subi	r18, 0xF4	; 244
    254e:	3f 4f       	sbci	r19, 0xFF	; 255
    2550:	8d 81       	ldd	r24, Y+5	; 0x05
    2552:	9e 81       	ldd	r25, Y+6	; 0x06
    2554:	b9 01       	movw	r22, r18
    2556:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <vListInsert>
	}
}
    255a:	26 96       	adiw	r28, 0x06	; 6
    255c:	0f b6       	in	r0, 0x3f	; 63
    255e:	f8 94       	cli
    2560:	de bf       	out	0x3e, r29	; 62
    2562:	0f be       	out	0x3f, r0	; 63
    2564:	cd bf       	out	0x3d, r28	; 61
    2566:	cf 91       	pop	r28
    2568:	df 91       	pop	r29
    256a:	08 95       	ret

0000256c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    256c:	df 93       	push	r29
    256e:	cf 93       	push	r28
    2570:	00 d0       	rcall	.+0      	; 0x2572 <prvCheckPendingReadyList+0x6>
    2572:	cd b7       	in	r28, 0x3d	; 61
    2574:	de b7       	in	r29, 0x3e	; 62
    2576:	3a c0       	rjmp	.+116    	; 0x25ec <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2578:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    257a:	e0 91 64 01 	lds	r30, 0x0164
    257e:	f0 91 65 01 	lds	r31, 0x0165
    2582:	86 81       	ldd	r24, Z+6	; 0x06
    2584:	97 81       	ldd	r25, Z+7	; 0x07
    2586:	9a 83       	std	Y+2, r25	; 0x02
    2588:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    258a:	89 81       	ldd	r24, Y+1	; 0x01
    258c:	9a 81       	ldd	r25, Y+2	; 0x02
    258e:	0c 96       	adiw	r24, 0x0c	; 12
    2590:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2594:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2596:	89 81       	ldd	r24, Y+1	; 0x01
    2598:	9a 81       	ldd	r25, Y+2	; 0x02
    259a:	02 96       	adiw	r24, 0x02	; 2
    259c:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    25a0:	e9 81       	ldd	r30, Y+1	; 0x01
    25a2:	fa 81       	ldd	r31, Y+2	; 0x02
    25a4:	96 89       	ldd	r25, Z+22	; 0x16
    25a6:	80 91 30 01 	lds	r24, 0x0130
    25aa:	89 17       	cp	r24, r25
    25ac:	28 f4       	brcc	.+10     	; 0x25b8 <prvCheckPendingReadyList+0x4c>
    25ae:	e9 81       	ldd	r30, Y+1	; 0x01
    25b0:	fa 81       	ldd	r31, Y+2	; 0x02
    25b2:	86 89       	ldd	r24, Z+22	; 0x16
    25b4:	80 93 30 01 	sts	0x0130, r24
    25b8:	e9 81       	ldd	r30, Y+1	; 0x01
    25ba:	fa 81       	ldd	r31, Y+2	; 0x02
    25bc:	86 89       	ldd	r24, Z+22	; 0x16
    25be:	28 2f       	mov	r18, r24
    25c0:	30 e0       	ldi	r19, 0x00	; 0
    25c2:	c9 01       	movw	r24, r18
    25c4:	88 0f       	add	r24, r24
    25c6:	99 1f       	adc	r25, r25
    25c8:	88 0f       	add	r24, r24
    25ca:	99 1f       	adc	r25, r25
    25cc:	88 0f       	add	r24, r24
    25ce:	99 1f       	adc	r25, r25
    25d0:	82 0f       	add	r24, r18
    25d2:	93 1f       	adc	r25, r19
    25d4:	ac 01       	movw	r20, r24
    25d6:	49 5c       	subi	r20, 0xC9	; 201
    25d8:	5e 4f       	sbci	r21, 0xFE	; 254
    25da:	89 81       	ldd	r24, Y+1	; 0x01
    25dc:	9a 81       	ldd	r25, Y+2	; 0x02
    25de:	9c 01       	movw	r18, r24
    25e0:	2e 5f       	subi	r18, 0xFE	; 254
    25e2:	3f 4f       	sbci	r19, 0xFF	; 255
    25e4:	ca 01       	movw	r24, r20
    25e6:	b9 01       	movw	r22, r18
    25e8:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    25ec:	80 91 5f 01 	lds	r24, 0x015F
    25f0:	88 23       	and	r24, r24
    25f2:	09 f0       	breq	.+2      	; 0x25f6 <prvCheckPendingReadyList+0x8a>
    25f4:	c1 cf       	rjmp	.-126    	; 0x2578 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    25f6:	0f 90       	pop	r0
    25f8:	0f 90       	pop	r0
    25fa:	cf 91       	pop	r28
    25fc:	df 91       	pop	r29
    25fe:	08 95       	ret

00002600 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2600:	df 93       	push	r29
    2602:	cf 93       	push	r28
    2604:	00 d0       	rcall	.+0      	; 0x2606 <prvCheckDelayedList+0x6>
    2606:	00 d0       	rcall	.+0      	; 0x2608 <prvCheckDelayedList+0x8>
    2608:	cd b7       	in	r28, 0x3d	; 61
    260a:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    260c:	0e 94 f7 24 	call	0x49ee	; 0x49ee <xTaskGetTickCount>
    2610:	20 91 33 01 	lds	r18, 0x0133
    2614:	30 91 34 01 	lds	r19, 0x0134
    2618:	82 1b       	sub	r24, r18
    261a:	93 0b       	sbc	r25, r19
    261c:	90 93 36 01 	sts	0x0136, r25
    2620:	80 93 35 01 	sts	0x0135, r24
    2624:	85 c0       	rjmp	.+266    	; 0x2730 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2626:	80 91 31 01 	lds	r24, 0x0131
    262a:	90 91 32 01 	lds	r25, 0x0132
    262e:	01 96       	adiw	r24, 0x01	; 1
    2630:	90 93 32 01 	sts	0x0132, r25
    2634:	80 93 31 01 	sts	0x0131, r24
		xPassedTicks--;
    2638:	80 91 35 01 	lds	r24, 0x0135
    263c:	90 91 36 01 	lds	r25, 0x0136
    2640:	01 97       	sbiw	r24, 0x01	; 1
    2642:	90 93 36 01 	sts	0x0136, r25
    2646:	80 93 35 01 	sts	0x0135, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    264a:	80 91 31 01 	lds	r24, 0x0131
    264e:	90 91 32 01 	lds	r25, 0x0132
    2652:	00 97       	sbiw	r24, 0x00	; 0
    2654:	09 f0       	breq	.+2      	; 0x2658 <prvCheckDelayedList+0x58>
    2656:	64 c0       	rjmp	.+200    	; 0x2720 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2658:	80 91 5b 01 	lds	r24, 0x015B
    265c:	90 91 5c 01 	lds	r25, 0x015C
    2660:	9a 83       	std	Y+2, r25	; 0x02
    2662:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2664:	80 91 5d 01 	lds	r24, 0x015D
    2668:	90 91 5e 01 	lds	r25, 0x015E
    266c:	90 93 5c 01 	sts	0x015C, r25
    2670:	80 93 5b 01 	sts	0x015B, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2674:	89 81       	ldd	r24, Y+1	; 0x01
    2676:	9a 81       	ldd	r25, Y+2	; 0x02
    2678:	90 93 5e 01 	sts	0x015E, r25
    267c:	80 93 5d 01 	sts	0x015D, r24
    2680:	4f c0       	rjmp	.+158    	; 0x2720 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2682:	e0 91 5b 01 	lds	r30, 0x015B
    2686:	f0 91 5c 01 	lds	r31, 0x015C
    268a:	05 80       	ldd	r0, Z+5	; 0x05
    268c:	f6 81       	ldd	r31, Z+6	; 0x06
    268e:	e0 2d       	mov	r30, r0
    2690:	86 81       	ldd	r24, Z+6	; 0x06
    2692:	97 81       	ldd	r25, Z+7	; 0x07
    2694:	9c 83       	std	Y+4, r25	; 0x04
    2696:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2698:	eb 81       	ldd	r30, Y+3	; 0x03
    269a:	fc 81       	ldd	r31, Y+4	; 0x04
    269c:	22 81       	ldd	r18, Z+2	; 0x02
    269e:	33 81       	ldd	r19, Z+3	; 0x03
    26a0:	80 91 31 01 	lds	r24, 0x0131
    26a4:	90 91 32 01 	lds	r25, 0x0132
    26a8:	82 17       	cp	r24, r18
    26aa:	93 07       	cpc	r25, r19
    26ac:	08 f4       	brcc	.+2      	; 0x26b0 <prvCheckDelayedList+0xb0>
    26ae:	40 c0       	rjmp	.+128    	; 0x2730 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    26b0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    26b2:	8b 81       	ldd	r24, Y+3	; 0x03
    26b4:	9c 81       	ldd	r25, Y+4	; 0x04
    26b6:	02 96       	adiw	r24, 0x02	; 2
    26b8:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    26bc:	eb 81       	ldd	r30, Y+3	; 0x03
    26be:	fc 81       	ldd	r31, Y+4	; 0x04
    26c0:	84 89       	ldd	r24, Z+20	; 0x14
    26c2:	95 89       	ldd	r25, Z+21	; 0x15
    26c4:	00 97       	sbiw	r24, 0x00	; 0
    26c6:	29 f0       	breq	.+10     	; 0x26d2 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    26c8:	8b 81       	ldd	r24, Y+3	; 0x03
    26ca:	9c 81       	ldd	r25, Y+4	; 0x04
    26cc:	0c 96       	adiw	r24, 0x0c	; 12
    26ce:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    26d2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    26d4:	eb 81       	ldd	r30, Y+3	; 0x03
    26d6:	fc 81       	ldd	r31, Y+4	; 0x04
    26d8:	96 89       	ldd	r25, Z+22	; 0x16
    26da:	80 91 30 01 	lds	r24, 0x0130
    26de:	89 17       	cp	r24, r25
    26e0:	28 f4       	brcc	.+10     	; 0x26ec <prvCheckDelayedList+0xec>
    26e2:	eb 81       	ldd	r30, Y+3	; 0x03
    26e4:	fc 81       	ldd	r31, Y+4	; 0x04
    26e6:	86 89       	ldd	r24, Z+22	; 0x16
    26e8:	80 93 30 01 	sts	0x0130, r24
    26ec:	eb 81       	ldd	r30, Y+3	; 0x03
    26ee:	fc 81       	ldd	r31, Y+4	; 0x04
    26f0:	86 89       	ldd	r24, Z+22	; 0x16
    26f2:	28 2f       	mov	r18, r24
    26f4:	30 e0       	ldi	r19, 0x00	; 0
    26f6:	c9 01       	movw	r24, r18
    26f8:	88 0f       	add	r24, r24
    26fa:	99 1f       	adc	r25, r25
    26fc:	88 0f       	add	r24, r24
    26fe:	99 1f       	adc	r25, r25
    2700:	88 0f       	add	r24, r24
    2702:	99 1f       	adc	r25, r25
    2704:	82 0f       	add	r24, r18
    2706:	93 1f       	adc	r25, r19
    2708:	ac 01       	movw	r20, r24
    270a:	49 5c       	subi	r20, 0xC9	; 201
    270c:	5e 4f       	sbci	r21, 0xFE	; 254
    270e:	8b 81       	ldd	r24, Y+3	; 0x03
    2710:	9c 81       	ldd	r25, Y+4	; 0x04
    2712:	9c 01       	movw	r18, r24
    2714:	2e 5f       	subi	r18, 0xFE	; 254
    2716:	3f 4f       	sbci	r19, 0xFF	; 255
    2718:	ca 01       	movw	r24, r20
    271a:	b9 01       	movw	r22, r18
    271c:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2720:	e0 91 5b 01 	lds	r30, 0x015B
    2724:	f0 91 5c 01 	lds	r31, 0x015C
    2728:	80 81       	ld	r24, Z
    272a:	88 23       	and	r24, r24
    272c:	09 f0       	breq	.+2      	; 0x2730 <prvCheckDelayedList+0x130>
    272e:	a9 cf       	rjmp	.-174    	; 0x2682 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2730:	80 91 35 01 	lds	r24, 0x0135
    2734:	90 91 36 01 	lds	r25, 0x0136
    2738:	00 97       	sbiw	r24, 0x00	; 0
    273a:	09 f0       	breq	.+2      	; 0x273e <prvCheckDelayedList+0x13e>
    273c:	74 cf       	rjmp	.-280    	; 0x2626 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    273e:	80 91 31 01 	lds	r24, 0x0131
    2742:	90 91 32 01 	lds	r25, 0x0132
    2746:	90 93 34 01 	sts	0x0134, r25
    274a:	80 93 33 01 	sts	0x0133, r24
}
    274e:	0f 90       	pop	r0
    2750:	0f 90       	pop	r0
    2752:	0f 90       	pop	r0
    2754:	0f 90       	pop	r0
    2756:	cf 91       	pop	r28
    2758:	df 91       	pop	r29
    275a:	08 95       	ret

0000275c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    275c:	df 93       	push	r29
    275e:	cf 93       	push	r28
    2760:	00 d0       	rcall	.+0      	; 0x2762 <vCoRoutineSchedule+0x6>
    2762:	cd b7       	in	r28, 0x3d	; 61
    2764:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2766:	0e 94 b6 12 	call	0x256c	; 0x256c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    276a:	0e 94 00 13 	call	0x2600	; 0x2600 <prvCheckDelayedList>
    276e:	0a c0       	rjmp	.+20     	; 0x2784 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2770:	80 91 30 01 	lds	r24, 0x0130
    2774:	88 23       	and	r24, r24
    2776:	09 f4       	brne	.+2      	; 0x277a <vCoRoutineSchedule+0x1e>
    2778:	66 c0       	rjmp	.+204    	; 0x2846 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    277a:	80 91 30 01 	lds	r24, 0x0130
    277e:	81 50       	subi	r24, 0x01	; 1
    2780:	80 93 30 01 	sts	0x0130, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2784:	80 91 30 01 	lds	r24, 0x0130
    2788:	28 2f       	mov	r18, r24
    278a:	30 e0       	ldi	r19, 0x00	; 0
    278c:	c9 01       	movw	r24, r18
    278e:	88 0f       	add	r24, r24
    2790:	99 1f       	adc	r25, r25
    2792:	88 0f       	add	r24, r24
    2794:	99 1f       	adc	r25, r25
    2796:	88 0f       	add	r24, r24
    2798:	99 1f       	adc	r25, r25
    279a:	82 0f       	add	r24, r18
    279c:	93 1f       	adc	r25, r19
    279e:	fc 01       	movw	r30, r24
    27a0:	e9 5c       	subi	r30, 0xC9	; 201
    27a2:	fe 4f       	sbci	r31, 0xFE	; 254
    27a4:	80 81       	ld	r24, Z
    27a6:	88 23       	and	r24, r24
    27a8:	19 f3       	breq	.-58     	; 0x2770 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    27aa:	80 91 30 01 	lds	r24, 0x0130
    27ae:	28 2f       	mov	r18, r24
    27b0:	30 e0       	ldi	r19, 0x00	; 0
    27b2:	c9 01       	movw	r24, r18
    27b4:	88 0f       	add	r24, r24
    27b6:	99 1f       	adc	r25, r25
    27b8:	88 0f       	add	r24, r24
    27ba:	99 1f       	adc	r25, r25
    27bc:	88 0f       	add	r24, r24
    27be:	99 1f       	adc	r25, r25
    27c0:	82 0f       	add	r24, r18
    27c2:	93 1f       	adc	r25, r19
    27c4:	89 5c       	subi	r24, 0xC9	; 201
    27c6:	9e 4f       	sbci	r25, 0xFE	; 254
    27c8:	9a 83       	std	Y+2, r25	; 0x02
    27ca:	89 83       	std	Y+1, r24	; 0x01
    27cc:	e9 81       	ldd	r30, Y+1	; 0x01
    27ce:	fa 81       	ldd	r31, Y+2	; 0x02
    27d0:	01 80       	ldd	r0, Z+1	; 0x01
    27d2:	f2 81       	ldd	r31, Z+2	; 0x02
    27d4:	e0 2d       	mov	r30, r0
    27d6:	82 81       	ldd	r24, Z+2	; 0x02
    27d8:	93 81       	ldd	r25, Z+3	; 0x03
    27da:	e9 81       	ldd	r30, Y+1	; 0x01
    27dc:	fa 81       	ldd	r31, Y+2	; 0x02
    27de:	92 83       	std	Z+2, r25	; 0x02
    27e0:	81 83       	std	Z+1, r24	; 0x01
    27e2:	e9 81       	ldd	r30, Y+1	; 0x01
    27e4:	fa 81       	ldd	r31, Y+2	; 0x02
    27e6:	21 81       	ldd	r18, Z+1	; 0x01
    27e8:	32 81       	ldd	r19, Z+2	; 0x02
    27ea:	89 81       	ldd	r24, Y+1	; 0x01
    27ec:	9a 81       	ldd	r25, Y+2	; 0x02
    27ee:	03 96       	adiw	r24, 0x03	; 3
    27f0:	28 17       	cp	r18, r24
    27f2:	39 07       	cpc	r19, r25
    27f4:	59 f4       	brne	.+22     	; 0x280c <vCoRoutineSchedule+0xb0>
    27f6:	e9 81       	ldd	r30, Y+1	; 0x01
    27f8:	fa 81       	ldd	r31, Y+2	; 0x02
    27fa:	01 80       	ldd	r0, Z+1	; 0x01
    27fc:	f2 81       	ldd	r31, Z+2	; 0x02
    27fe:	e0 2d       	mov	r30, r0
    2800:	82 81       	ldd	r24, Z+2	; 0x02
    2802:	93 81       	ldd	r25, Z+3	; 0x03
    2804:	e9 81       	ldd	r30, Y+1	; 0x01
    2806:	fa 81       	ldd	r31, Y+2	; 0x02
    2808:	92 83       	std	Z+2, r25	; 0x02
    280a:	81 83       	std	Z+1, r24	; 0x01
    280c:	e9 81       	ldd	r30, Y+1	; 0x01
    280e:	fa 81       	ldd	r31, Y+2	; 0x02
    2810:	01 80       	ldd	r0, Z+1	; 0x01
    2812:	f2 81       	ldd	r31, Z+2	; 0x02
    2814:	e0 2d       	mov	r30, r0
    2816:	86 81       	ldd	r24, Z+6	; 0x06
    2818:	97 81       	ldd	r25, Z+7	; 0x07
    281a:	90 93 2f 01 	sts	0x012F, r25
    281e:	80 93 2e 01 	sts	0x012E, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2822:	e0 91 2e 01 	lds	r30, 0x012E
    2826:	f0 91 2f 01 	lds	r31, 0x012F
    282a:	40 81       	ld	r20, Z
    282c:	51 81       	ldd	r21, Z+1	; 0x01
    282e:	80 91 2e 01 	lds	r24, 0x012E
    2832:	90 91 2f 01 	lds	r25, 0x012F
    2836:	e0 91 2e 01 	lds	r30, 0x012E
    283a:	f0 91 2f 01 	lds	r31, 0x012F
    283e:	27 89       	ldd	r18, Z+23	; 0x17
    2840:	62 2f       	mov	r22, r18
    2842:	fa 01       	movw	r30, r20
    2844:	09 95       	icall

	return;
}
    2846:	0f 90       	pop	r0
    2848:	0f 90       	pop	r0
    284a:	cf 91       	pop	r28
    284c:	df 91       	pop	r29
    284e:	08 95       	ret

00002850 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2850:	df 93       	push	r29
    2852:	cf 93       	push	r28
    2854:	0f 92       	push	r0
    2856:	cd b7       	in	r28, 0x3d	; 61
    2858:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    285a:	19 82       	std	Y+1, r1	; 0x01
    285c:	13 c0       	rjmp	.+38     	; 0x2884 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    285e:	89 81       	ldd	r24, Y+1	; 0x01
    2860:	28 2f       	mov	r18, r24
    2862:	30 e0       	ldi	r19, 0x00	; 0
    2864:	c9 01       	movw	r24, r18
    2866:	88 0f       	add	r24, r24
    2868:	99 1f       	adc	r25, r25
    286a:	88 0f       	add	r24, r24
    286c:	99 1f       	adc	r25, r25
    286e:	88 0f       	add	r24, r24
    2870:	99 1f       	adc	r25, r25
    2872:	82 0f       	add	r24, r18
    2874:	93 1f       	adc	r25, r19
    2876:	89 5c       	subi	r24, 0xC9	; 201
    2878:	9e 4f       	sbci	r25, 0xFE	; 254
    287a:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    287e:	89 81       	ldd	r24, Y+1	; 0x01
    2880:	8f 5f       	subi	r24, 0xFF	; 255
    2882:	89 83       	std	Y+1, r24	; 0x01
    2884:	89 81       	ldd	r24, Y+1	; 0x01
    2886:	82 30       	cpi	r24, 0x02	; 2
    2888:	50 f3       	brcs	.-44     	; 0x285e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    288a:	89 e4       	ldi	r24, 0x49	; 73
    288c:	91 e0       	ldi	r25, 0x01	; 1
    288e:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2892:	82 e5       	ldi	r24, 0x52	; 82
    2894:	91 e0       	ldi	r25, 0x01	; 1
    2896:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    289a:	8f e5       	ldi	r24, 0x5F	; 95
    289c:	91 e0       	ldi	r25, 0x01	; 1
    289e:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    28a2:	89 e4       	ldi	r24, 0x49	; 73
    28a4:	91 e0       	ldi	r25, 0x01	; 1
    28a6:	90 93 5c 01 	sts	0x015C, r25
    28aa:	80 93 5b 01 	sts	0x015B, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    28ae:	82 e5       	ldi	r24, 0x52	; 82
    28b0:	91 e0       	ldi	r25, 0x01	; 1
    28b2:	90 93 5e 01 	sts	0x015E, r25
    28b6:	80 93 5d 01 	sts	0x015D, r24
}
    28ba:	0f 90       	pop	r0
    28bc:	cf 91       	pop	r28
    28be:	df 91       	pop	r29
    28c0:	08 95       	ret

000028c2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    28c2:	df 93       	push	r29
    28c4:	cf 93       	push	r28
    28c6:	00 d0       	rcall	.+0      	; 0x28c8 <xCoRoutineRemoveFromEventList+0x6>
    28c8:	00 d0       	rcall	.+0      	; 0x28ca <xCoRoutineRemoveFromEventList+0x8>
    28ca:	0f 92       	push	r0
    28cc:	cd b7       	in	r28, 0x3d	; 61
    28ce:	de b7       	in	r29, 0x3e	; 62
    28d0:	9d 83       	std	Y+5, r25	; 0x05
    28d2:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    28d4:	ec 81       	ldd	r30, Y+4	; 0x04
    28d6:	fd 81       	ldd	r31, Y+5	; 0x05
    28d8:	05 80       	ldd	r0, Z+5	; 0x05
    28da:	f6 81       	ldd	r31, Z+6	; 0x06
    28dc:	e0 2d       	mov	r30, r0
    28de:	86 81       	ldd	r24, Z+6	; 0x06
    28e0:	97 81       	ldd	r25, Z+7	; 0x07
    28e2:	9b 83       	std	Y+3, r25	; 0x03
    28e4:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    28e6:	8a 81       	ldd	r24, Y+2	; 0x02
    28e8:	9b 81       	ldd	r25, Y+3	; 0x03
    28ea:	0c 96       	adiw	r24, 0x0c	; 12
    28ec:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    28f0:	8a 81       	ldd	r24, Y+2	; 0x02
    28f2:	9b 81       	ldd	r25, Y+3	; 0x03
    28f4:	9c 01       	movw	r18, r24
    28f6:	24 5f       	subi	r18, 0xF4	; 244
    28f8:	3f 4f       	sbci	r19, 0xFF	; 255
    28fa:	8f e5       	ldi	r24, 0x5F	; 95
    28fc:	91 e0       	ldi	r25, 0x01	; 1
    28fe:	b9 01       	movw	r22, r18
    2900:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2904:	ea 81       	ldd	r30, Y+2	; 0x02
    2906:	fb 81       	ldd	r31, Y+3	; 0x03
    2908:	96 89       	ldd	r25, Z+22	; 0x16
    290a:	e0 91 2e 01 	lds	r30, 0x012E
    290e:	f0 91 2f 01 	lds	r31, 0x012F
    2912:	86 89       	ldd	r24, Z+22	; 0x16
    2914:	98 17       	cp	r25, r24
    2916:	18 f0       	brcs	.+6      	; 0x291e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2918:	81 e0       	ldi	r24, 0x01	; 1
    291a:	89 83       	std	Y+1, r24	; 0x01
    291c:	01 c0       	rjmp	.+2      	; 0x2920 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    291e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2920:	89 81       	ldd	r24, Y+1	; 0x01
}
    2922:	0f 90       	pop	r0
    2924:	0f 90       	pop	r0
    2926:	0f 90       	pop	r0
    2928:	0f 90       	pop	r0
    292a:	0f 90       	pop	r0
    292c:	cf 91       	pop	r28
    292e:	df 91       	pop	r29
    2930:	08 95       	ret

00002932 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2932:	df 93       	push	r29
    2934:	cf 93       	push	r28
    2936:	00 d0       	rcall	.+0      	; 0x2938 <pvPortMalloc+0x6>
    2938:	00 d0       	rcall	.+0      	; 0x293a <pvPortMalloc+0x8>
    293a:	cd b7       	in	r28, 0x3d	; 61
    293c:	de b7       	in	r29, 0x3e	; 62
    293e:	9c 83       	std	Y+4, r25	; 0x04
    2940:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    2942:	1a 82       	std	Y+2, r1	; 0x02
    2944:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2946:	0e 94 61 24 	call	0x48c2	; 0x48c2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    294a:	80 91 68 01 	lds	r24, 0x0168
    294e:	90 91 69 01 	lds	r25, 0x0169
    2952:	2b 81       	ldd	r18, Y+3	; 0x03
    2954:	3c 81       	ldd	r19, Y+4	; 0x04
    2956:	82 0f       	add	r24, r18
    2958:	93 1f       	adc	r25, r19
    295a:	24 e0       	ldi	r18, 0x04	; 4
    295c:	80 3b       	cpi	r24, 0xB0	; 176
    295e:	92 07       	cpc	r25, r18
    2960:	18 f5       	brcc	.+70     	; 0x29a8 <pvPortMalloc+0x76>
    2962:	20 91 68 01 	lds	r18, 0x0168
    2966:	30 91 69 01 	lds	r19, 0x0169
    296a:	8b 81       	ldd	r24, Y+3	; 0x03
    296c:	9c 81       	ldd	r25, Y+4	; 0x04
    296e:	28 0f       	add	r18, r24
    2970:	39 1f       	adc	r19, r25
    2972:	80 91 68 01 	lds	r24, 0x0168
    2976:	90 91 69 01 	lds	r25, 0x0169
    297a:	82 17       	cp	r24, r18
    297c:	93 07       	cpc	r25, r19
    297e:	a0 f4       	brcc	.+40     	; 0x29a8 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2980:	80 91 68 01 	lds	r24, 0x0168
    2984:	90 91 69 01 	lds	r25, 0x0169
    2988:	86 59       	subi	r24, 0x96	; 150
    298a:	9e 4f       	sbci	r25, 0xFE	; 254
    298c:	9a 83       	std	Y+2, r25	; 0x02
    298e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    2990:	20 91 68 01 	lds	r18, 0x0168
    2994:	30 91 69 01 	lds	r19, 0x0169
    2998:	8b 81       	ldd	r24, Y+3	; 0x03
    299a:	9c 81       	ldd	r25, Y+4	; 0x04
    299c:	82 0f       	add	r24, r18
    299e:	93 1f       	adc	r25, r19
    29a0:	90 93 69 01 	sts	0x0169, r25
    29a4:	80 93 68 01 	sts	0x0168, r24
		}	
	}
	xTaskResumeAll();
    29a8:	0e 94 6d 24 	call	0x48da	; 0x48da <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    29ac:	89 81       	ldd	r24, Y+1	; 0x01
    29ae:	9a 81       	ldd	r25, Y+2	; 0x02
}
    29b0:	0f 90       	pop	r0
    29b2:	0f 90       	pop	r0
    29b4:	0f 90       	pop	r0
    29b6:	0f 90       	pop	r0
    29b8:	cf 91       	pop	r28
    29ba:	df 91       	pop	r29
    29bc:	08 95       	ret

000029be <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    29be:	df 93       	push	r29
    29c0:	cf 93       	push	r28
    29c2:	00 d0       	rcall	.+0      	; 0x29c4 <vPortFree+0x6>
    29c4:	cd b7       	in	r28, 0x3d	; 61
    29c6:	de b7       	in	r29, 0x3e	; 62
    29c8:	9a 83       	std	Y+2, r25	; 0x02
    29ca:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    29cc:	0f 90       	pop	r0
    29ce:	0f 90       	pop	r0
    29d0:	cf 91       	pop	r28
    29d2:	df 91       	pop	r29
    29d4:	08 95       	ret

000029d6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    29d6:	df 93       	push	r29
    29d8:	cf 93       	push	r28
    29da:	cd b7       	in	r28, 0x3d	; 61
    29dc:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    29de:	10 92 69 01 	sts	0x0169, r1
    29e2:	10 92 68 01 	sts	0x0168, r1
}
    29e6:	cf 91       	pop	r28
    29e8:	df 91       	pop	r29
    29ea:	08 95       	ret

000029ec <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    29ec:	df 93       	push	r29
    29ee:	cf 93       	push	r28
    29f0:	cd b7       	in	r28, 0x3d	; 61
    29f2:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    29f4:	20 91 68 01 	lds	r18, 0x0168
    29f8:	30 91 69 01 	lds	r19, 0x0169
    29fc:	80 eb       	ldi	r24, 0xB0	; 176
    29fe:	94 e0       	ldi	r25, 0x04	; 4
    2a00:	82 1b       	sub	r24, r18
    2a02:	93 0b       	sbc	r25, r19
}
    2a04:	cf 91       	pop	r28
    2a06:	df 91       	pop	r29
    2a08:	08 95       	ret

00002a0a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2a0a:	df 93       	push	r29
    2a0c:	cf 93       	push	r28
    2a0e:	00 d0       	rcall	.+0      	; 0x2a10 <vListInitialise+0x6>
    2a10:	cd b7       	in	r28, 0x3d	; 61
    2a12:	de b7       	in	r29, 0x3e	; 62
    2a14:	9a 83       	std	Y+2, r25	; 0x02
    2a16:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2a18:	89 81       	ldd	r24, Y+1	; 0x01
    2a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a1c:	03 96       	adiw	r24, 0x03	; 3
    2a1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a20:	fa 81       	ldd	r31, Y+2	; 0x02
    2a22:	92 83       	std	Z+2, r25	; 0x02
    2a24:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2a26:	e9 81       	ldd	r30, Y+1	; 0x01
    2a28:	fa 81       	ldd	r31, Y+2	; 0x02
    2a2a:	8f ef       	ldi	r24, 0xFF	; 255
    2a2c:	9f ef       	ldi	r25, 0xFF	; 255
    2a2e:	94 83       	std	Z+4, r25	; 0x04
    2a30:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2a32:	89 81       	ldd	r24, Y+1	; 0x01
    2a34:	9a 81       	ldd	r25, Y+2	; 0x02
    2a36:	03 96       	adiw	r24, 0x03	; 3
    2a38:	e9 81       	ldd	r30, Y+1	; 0x01
    2a3a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a3c:	96 83       	std	Z+6, r25	; 0x06
    2a3e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2a40:	89 81       	ldd	r24, Y+1	; 0x01
    2a42:	9a 81       	ldd	r25, Y+2	; 0x02
    2a44:	03 96       	adiw	r24, 0x03	; 3
    2a46:	e9 81       	ldd	r30, Y+1	; 0x01
    2a48:	fa 81       	ldd	r31, Y+2	; 0x02
    2a4a:	90 87       	std	Z+8, r25	; 0x08
    2a4c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2a4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a50:	fa 81       	ldd	r31, Y+2	; 0x02
    2a52:	10 82       	st	Z, r1
}
    2a54:	0f 90       	pop	r0
    2a56:	0f 90       	pop	r0
    2a58:	cf 91       	pop	r28
    2a5a:	df 91       	pop	r29
    2a5c:	08 95       	ret

00002a5e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2a5e:	df 93       	push	r29
    2a60:	cf 93       	push	r28
    2a62:	00 d0       	rcall	.+0      	; 0x2a64 <vListInitialiseItem+0x6>
    2a64:	cd b7       	in	r28, 0x3d	; 61
    2a66:	de b7       	in	r29, 0x3e	; 62
    2a68:	9a 83       	std	Y+2, r25	; 0x02
    2a6a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2a6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a70:	11 86       	std	Z+9, r1	; 0x09
    2a72:	10 86       	std	Z+8, r1	; 0x08
}
    2a74:	0f 90       	pop	r0
    2a76:	0f 90       	pop	r0
    2a78:	cf 91       	pop	r28
    2a7a:	df 91       	pop	r29
    2a7c:	08 95       	ret

00002a7e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2a7e:	df 93       	push	r29
    2a80:	cf 93       	push	r28
    2a82:	00 d0       	rcall	.+0      	; 0x2a84 <vListInsertEnd+0x6>
    2a84:	00 d0       	rcall	.+0      	; 0x2a86 <vListInsertEnd+0x8>
    2a86:	00 d0       	rcall	.+0      	; 0x2a88 <vListInsertEnd+0xa>
    2a88:	cd b7       	in	r28, 0x3d	; 61
    2a8a:	de b7       	in	r29, 0x3e	; 62
    2a8c:	9c 83       	std	Y+4, r25	; 0x04
    2a8e:	8b 83       	std	Y+3, r24	; 0x03
    2a90:	7e 83       	std	Y+6, r23	; 0x06
    2a92:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2a94:	eb 81       	ldd	r30, Y+3	; 0x03
    2a96:	fc 81       	ldd	r31, Y+4	; 0x04
    2a98:	81 81       	ldd	r24, Z+1	; 0x01
    2a9a:	92 81       	ldd	r25, Z+2	; 0x02
    2a9c:	9a 83       	std	Y+2, r25	; 0x02
    2a9e:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2aa0:	e9 81       	ldd	r30, Y+1	; 0x01
    2aa2:	fa 81       	ldd	r31, Y+2	; 0x02
    2aa4:	82 81       	ldd	r24, Z+2	; 0x02
    2aa6:	93 81       	ldd	r25, Z+3	; 0x03
    2aa8:	ed 81       	ldd	r30, Y+5	; 0x05
    2aaa:	fe 81       	ldd	r31, Y+6	; 0x06
    2aac:	93 83       	std	Z+3, r25	; 0x03
    2aae:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2ab0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ab4:	81 81       	ldd	r24, Z+1	; 0x01
    2ab6:	92 81       	ldd	r25, Z+2	; 0x02
    2ab8:	ed 81       	ldd	r30, Y+5	; 0x05
    2aba:	fe 81       	ldd	r31, Y+6	; 0x06
    2abc:	95 83       	std	Z+5, r25	; 0x05
    2abe:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ac4:	02 80       	ldd	r0, Z+2	; 0x02
    2ac6:	f3 81       	ldd	r31, Z+3	; 0x03
    2ac8:	e0 2d       	mov	r30, r0
    2aca:	8d 81       	ldd	r24, Y+5	; 0x05
    2acc:	9e 81       	ldd	r25, Y+6	; 0x06
    2ace:	95 83       	std	Z+5, r25	; 0x05
    2ad0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2ad2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ad4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ad6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ad8:	fa 81       	ldd	r31, Y+2	; 0x02
    2ada:	93 83       	std	Z+3, r25	; 0x03
    2adc:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2ade:	8d 81       	ldd	r24, Y+5	; 0x05
    2ae0:	9e 81       	ldd	r25, Y+6	; 0x06
    2ae2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ae4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae6:	92 83       	std	Z+2, r25	; 0x02
    2ae8:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2aea:	ed 81       	ldd	r30, Y+5	; 0x05
    2aec:	fe 81       	ldd	r31, Y+6	; 0x06
    2aee:	8b 81       	ldd	r24, Y+3	; 0x03
    2af0:	9c 81       	ldd	r25, Y+4	; 0x04
    2af2:	91 87       	std	Z+9, r25	; 0x09
    2af4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2af6:	eb 81       	ldd	r30, Y+3	; 0x03
    2af8:	fc 81       	ldd	r31, Y+4	; 0x04
    2afa:	80 81       	ld	r24, Z
    2afc:	8f 5f       	subi	r24, 0xFF	; 255
    2afe:	eb 81       	ldd	r30, Y+3	; 0x03
    2b00:	fc 81       	ldd	r31, Y+4	; 0x04
    2b02:	80 83       	st	Z, r24
}
    2b04:	26 96       	adiw	r28, 0x06	; 6
    2b06:	0f b6       	in	r0, 0x3f	; 63
    2b08:	f8 94       	cli
    2b0a:	de bf       	out	0x3e, r29	; 62
    2b0c:	0f be       	out	0x3f, r0	; 63
    2b0e:	cd bf       	out	0x3d, r28	; 61
    2b10:	cf 91       	pop	r28
    2b12:	df 91       	pop	r29
    2b14:	08 95       	ret

00002b16 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2b16:	df 93       	push	r29
    2b18:	cf 93       	push	r28
    2b1a:	cd b7       	in	r28, 0x3d	; 61
    2b1c:	de b7       	in	r29, 0x3e	; 62
    2b1e:	28 97       	sbiw	r28, 0x08	; 8
    2b20:	0f b6       	in	r0, 0x3f	; 63
    2b22:	f8 94       	cli
    2b24:	de bf       	out	0x3e, r29	; 62
    2b26:	0f be       	out	0x3f, r0	; 63
    2b28:	cd bf       	out	0x3d, r28	; 61
    2b2a:	9e 83       	std	Y+6, r25	; 0x06
    2b2c:	8d 83       	std	Y+5, r24	; 0x05
    2b2e:	78 87       	std	Y+8, r23	; 0x08
    2b30:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2b32:	ef 81       	ldd	r30, Y+7	; 0x07
    2b34:	f8 85       	ldd	r31, Y+8	; 0x08
    2b36:	80 81       	ld	r24, Z
    2b38:	91 81       	ldd	r25, Z+1	; 0x01
    2b3a:	9a 83       	std	Y+2, r25	; 0x02
    2b3c:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2b3e:	89 81       	ldd	r24, Y+1	; 0x01
    2b40:	9a 81       	ldd	r25, Y+2	; 0x02
    2b42:	2f ef       	ldi	r18, 0xFF	; 255
    2b44:	8f 3f       	cpi	r24, 0xFF	; 255
    2b46:	92 07       	cpc	r25, r18
    2b48:	39 f4       	brne	.+14     	; 0x2b58 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2b4a:	ed 81       	ldd	r30, Y+5	; 0x05
    2b4c:	fe 81       	ldd	r31, Y+6	; 0x06
    2b4e:	87 81       	ldd	r24, Z+7	; 0x07
    2b50:	90 85       	ldd	r25, Z+8	; 0x08
    2b52:	9c 83       	std	Y+4, r25	; 0x04
    2b54:	8b 83       	std	Y+3, r24	; 0x03
    2b56:	18 c0       	rjmp	.+48     	; 0x2b88 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2b58:	8d 81       	ldd	r24, Y+5	; 0x05
    2b5a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b5c:	03 96       	adiw	r24, 0x03	; 3
    2b5e:	9c 83       	std	Y+4, r25	; 0x04
    2b60:	8b 83       	std	Y+3, r24	; 0x03
    2b62:	06 c0       	rjmp	.+12     	; 0x2b70 <vListInsert+0x5a>
    2b64:	eb 81       	ldd	r30, Y+3	; 0x03
    2b66:	fc 81       	ldd	r31, Y+4	; 0x04
    2b68:	82 81       	ldd	r24, Z+2	; 0x02
    2b6a:	93 81       	ldd	r25, Z+3	; 0x03
    2b6c:	9c 83       	std	Y+4, r25	; 0x04
    2b6e:	8b 83       	std	Y+3, r24	; 0x03
    2b70:	eb 81       	ldd	r30, Y+3	; 0x03
    2b72:	fc 81       	ldd	r31, Y+4	; 0x04
    2b74:	02 80       	ldd	r0, Z+2	; 0x02
    2b76:	f3 81       	ldd	r31, Z+3	; 0x03
    2b78:	e0 2d       	mov	r30, r0
    2b7a:	20 81       	ld	r18, Z
    2b7c:	31 81       	ldd	r19, Z+1	; 0x01
    2b7e:	89 81       	ldd	r24, Y+1	; 0x01
    2b80:	9a 81       	ldd	r25, Y+2	; 0x02
    2b82:	82 17       	cp	r24, r18
    2b84:	93 07       	cpc	r25, r19
    2b86:	70 f7       	brcc	.-36     	; 0x2b64 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2b88:	eb 81       	ldd	r30, Y+3	; 0x03
    2b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b8c:	82 81       	ldd	r24, Z+2	; 0x02
    2b8e:	93 81       	ldd	r25, Z+3	; 0x03
    2b90:	ef 81       	ldd	r30, Y+7	; 0x07
    2b92:	f8 85       	ldd	r31, Y+8	; 0x08
    2b94:	93 83       	std	Z+3, r25	; 0x03
    2b96:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2b98:	ef 81       	ldd	r30, Y+7	; 0x07
    2b9a:	f8 85       	ldd	r31, Y+8	; 0x08
    2b9c:	02 80       	ldd	r0, Z+2	; 0x02
    2b9e:	f3 81       	ldd	r31, Z+3	; 0x03
    2ba0:	e0 2d       	mov	r30, r0
    2ba2:	8f 81       	ldd	r24, Y+7	; 0x07
    2ba4:	98 85       	ldd	r25, Y+8	; 0x08
    2ba6:	95 83       	std	Z+5, r25	; 0x05
    2ba8:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2baa:	ef 81       	ldd	r30, Y+7	; 0x07
    2bac:	f8 85       	ldd	r31, Y+8	; 0x08
    2bae:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb2:	95 83       	std	Z+5, r25	; 0x05
    2bb4:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2bb6:	8f 81       	ldd	r24, Y+7	; 0x07
    2bb8:	98 85       	ldd	r25, Y+8	; 0x08
    2bba:	eb 81       	ldd	r30, Y+3	; 0x03
    2bbc:	fc 81       	ldd	r31, Y+4	; 0x04
    2bbe:	93 83       	std	Z+3, r25	; 0x03
    2bc0:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2bc2:	ef 81       	ldd	r30, Y+7	; 0x07
    2bc4:	f8 85       	ldd	r31, Y+8	; 0x08
    2bc6:	8d 81       	ldd	r24, Y+5	; 0x05
    2bc8:	9e 81       	ldd	r25, Y+6	; 0x06
    2bca:	91 87       	std	Z+9, r25	; 0x09
    2bcc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2bce:	ed 81       	ldd	r30, Y+5	; 0x05
    2bd0:	fe 81       	ldd	r31, Y+6	; 0x06
    2bd2:	80 81       	ld	r24, Z
    2bd4:	8f 5f       	subi	r24, 0xFF	; 255
    2bd6:	ed 81       	ldd	r30, Y+5	; 0x05
    2bd8:	fe 81       	ldd	r31, Y+6	; 0x06
    2bda:	80 83       	st	Z, r24
}
    2bdc:	28 96       	adiw	r28, 0x08	; 8
    2bde:	0f b6       	in	r0, 0x3f	; 63
    2be0:	f8 94       	cli
    2be2:	de bf       	out	0x3e, r29	; 62
    2be4:	0f be       	out	0x3f, r0	; 63
    2be6:	cd bf       	out	0x3d, r28	; 61
    2be8:	cf 91       	pop	r28
    2bea:	df 91       	pop	r29
    2bec:	08 95       	ret

00002bee <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2bee:	df 93       	push	r29
    2bf0:	cf 93       	push	r28
    2bf2:	00 d0       	rcall	.+0      	; 0x2bf4 <vListRemove+0x6>
    2bf4:	00 d0       	rcall	.+0      	; 0x2bf6 <vListRemove+0x8>
    2bf6:	cd b7       	in	r28, 0x3d	; 61
    2bf8:	de b7       	in	r29, 0x3e	; 62
    2bfa:	9c 83       	std	Y+4, r25	; 0x04
    2bfc:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2bfe:	eb 81       	ldd	r30, Y+3	; 0x03
    2c00:	fc 81       	ldd	r31, Y+4	; 0x04
    2c02:	a2 81       	ldd	r26, Z+2	; 0x02
    2c04:	b3 81       	ldd	r27, Z+3	; 0x03
    2c06:	eb 81       	ldd	r30, Y+3	; 0x03
    2c08:	fc 81       	ldd	r31, Y+4	; 0x04
    2c0a:	84 81       	ldd	r24, Z+4	; 0x04
    2c0c:	95 81       	ldd	r25, Z+5	; 0x05
    2c0e:	15 96       	adiw	r26, 0x05	; 5
    2c10:	9c 93       	st	X, r25
    2c12:	8e 93       	st	-X, r24
    2c14:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2c16:	eb 81       	ldd	r30, Y+3	; 0x03
    2c18:	fc 81       	ldd	r31, Y+4	; 0x04
    2c1a:	a4 81       	ldd	r26, Z+4	; 0x04
    2c1c:	b5 81       	ldd	r27, Z+5	; 0x05
    2c1e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c20:	fc 81       	ldd	r31, Y+4	; 0x04
    2c22:	82 81       	ldd	r24, Z+2	; 0x02
    2c24:	93 81       	ldd	r25, Z+3	; 0x03
    2c26:	13 96       	adiw	r26, 0x03	; 3
    2c28:	9c 93       	st	X, r25
    2c2a:	8e 93       	st	-X, r24
    2c2c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2c2e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c30:	fc 81       	ldd	r31, Y+4	; 0x04
    2c32:	80 85       	ldd	r24, Z+8	; 0x08
    2c34:	91 85       	ldd	r25, Z+9	; 0x09
    2c36:	9a 83       	std	Y+2, r25	; 0x02
    2c38:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2c3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c3e:	21 81       	ldd	r18, Z+1	; 0x01
    2c40:	32 81       	ldd	r19, Z+2	; 0x02
    2c42:	8b 81       	ldd	r24, Y+3	; 0x03
    2c44:	9c 81       	ldd	r25, Y+4	; 0x04
    2c46:	28 17       	cp	r18, r24
    2c48:	39 07       	cpc	r19, r25
    2c4a:	41 f4       	brne	.+16     	; 0x2c5c <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2c4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c50:	84 81       	ldd	r24, Z+4	; 0x04
    2c52:	95 81       	ldd	r25, Z+5	; 0x05
    2c54:	e9 81       	ldd	r30, Y+1	; 0x01
    2c56:	fa 81       	ldd	r31, Y+2	; 0x02
    2c58:	92 83       	std	Z+2, r25	; 0x02
    2c5a:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2c5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c60:	11 86       	std	Z+9, r1	; 0x09
    2c62:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2c64:	e9 81       	ldd	r30, Y+1	; 0x01
    2c66:	fa 81       	ldd	r31, Y+2	; 0x02
    2c68:	80 81       	ld	r24, Z
    2c6a:	81 50       	subi	r24, 0x01	; 1
    2c6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c70:	80 83       	st	Z, r24
}
    2c72:	0f 90       	pop	r0
    2c74:	0f 90       	pop	r0
    2c76:	0f 90       	pop	r0
    2c78:	0f 90       	pop	r0
    2c7a:	cf 91       	pop	r28
    2c7c:	df 91       	pop	r29
    2c7e:	08 95       	ret

00002c80 <Task1>:

u8 led1;

// Task to receive data from UART
void Task1(void *p)
{
    2c80:	df 93       	push	r29
    2c82:	cf 93       	push	r28
    2c84:	00 d0       	rcall	.+0      	; 0x2c86 <Task1+0x6>
    2c86:	0f 92       	push	r0
    2c88:	cd b7       	in	r28, 0x3d	; 61
    2c8a:	de b7       	in	r29, 0x3e	; 62
    2c8c:	9b 83       	std	Y+3, r25	; 0x03
    2c8e:	8a 83       	std	Y+2, r24	; 0x02
	while(1)
	{
		u8 Local_semState = xSemaphoreTake(LEDS_sm , portMAX_DELAY);
    2c90:	80 91 94 06 	lds	r24, 0x0694
    2c94:	90 91 95 06 	lds	r25, 0x0695
    2c98:	60 e0       	ldi	r22, 0x00	; 0
    2c9a:	70 e0       	ldi	r23, 0x00	; 0
    2c9c:	4f ef       	ldi	r20, 0xFF	; 255
    2c9e:	5f ef       	ldi	r21, 0xFF	; 255
    2ca0:	20 e0       	ldi	r18, 0x00	; 0
    2ca2:	0e 94 38 1f 	call	0x3e70	; 0x3e70 <xQueueGenericReceive>
    2ca6:	89 83       	std	Y+1, r24	; 0x01
		if(Local_semState == pdPASS){
    2ca8:	89 81       	ldd	r24, Y+1	; 0x01
    2caa:	81 30       	cpi	r24, 0x01	; 1
    2cac:	89 f7       	brne	.-30     	; 0x2c90 <Task1+0x10>
		// Receive data from UART
		Recived_data = UART_u8ReceiveData();
    2cae:	0e 94 b2 11 	call	0x2364	; 0x2364 <UART_u8ReceiveData>
    2cb2:	80 93 1a 06 	sts	0x061A, r24
		//led1	= EEPROM_u8ReadByte(10,EEPROM_DEVICE2);
		xSemaphoreGive(LEDS_sm);
    2cb6:	80 91 94 06 	lds	r24, 0x0694
    2cba:	90 91 95 06 	lds	r25, 0x0695
    2cbe:	60 e0       	ldi	r22, 0x00	; 0
    2cc0:	70 e0       	ldi	r23, 0x00	; 0
    2cc2:	40 e0       	ldi	r20, 0x00	; 0
    2cc4:	50 e0       	ldi	r21, 0x00	; 0
    2cc6:	20 e0       	ldi	r18, 0x00	; 0
    2cc8:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <xQueueGenericSend>

		vTaskDelay(1);
    2ccc:	81 e0       	ldi	r24, 0x01	; 1
    2cce:	90 e0       	ldi	r25, 0x00	; 0
    2cd0:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <vTaskDelay>
    2cd4:	dd cf       	rjmp	.-70     	; 0x2c90 <Task1+0x10>

00002cd6 <Task2>:
	}
}

// Task to control the output pin based on received data
void Task2(void *p)
{
    2cd6:	df 93       	push	r29
    2cd8:	cf 93       	push	r28
    2cda:	00 d0       	rcall	.+0      	; 0x2cdc <Task2+0x6>
    2cdc:	00 d0       	rcall	.+0      	; 0x2cde <Task2+0x8>
    2cde:	0f 92       	push	r0
    2ce0:	cd b7       	in	r28, 0x3d	; 61
    2ce2:	de b7       	in	r29, 0x3e	; 62
    2ce4:	9b 83       	std	Y+3, r25	; 0x03
    2ce6:	8a 83       	std	Y+2, r24	; 0x02
	static u32 Counter=0;
	while(1)
	{
		Counter++;
    2ce8:	80 91 1f 06 	lds	r24, 0x061F
    2cec:	90 91 20 06 	lds	r25, 0x0620
    2cf0:	a0 91 21 06 	lds	r26, 0x0621
    2cf4:	b0 91 22 06 	lds	r27, 0x0622
    2cf8:	01 96       	adiw	r24, 0x01	; 1
    2cfa:	a1 1d       	adc	r26, r1
    2cfc:	b1 1d       	adc	r27, r1
    2cfe:	80 93 1f 06 	sts	0x061F, r24
    2d02:	90 93 20 06 	sts	0x0620, r25
    2d06:	a0 93 21 06 	sts	0x0621, r26
    2d0a:	b0 93 22 06 	sts	0x0622, r27

		u8 Local_semState = xSemaphoreTake(LEDS_sm , portMAX_DELAY);
    2d0e:	80 91 94 06 	lds	r24, 0x0694
    2d12:	90 91 95 06 	lds	r25, 0x0695
    2d16:	60 e0       	ldi	r22, 0x00	; 0
    2d18:	70 e0       	ldi	r23, 0x00	; 0
    2d1a:	4f ef       	ldi	r20, 0xFF	; 255
    2d1c:	5f ef       	ldi	r21, 0xFF	; 255
    2d1e:	20 e0       	ldi	r18, 0x00	; 0
    2d20:	0e 94 38 1f 	call	0x3e70	; 0x3e70 <xQueueGenericReceive>
    2d24:	89 83       	std	Y+1, r24	; 0x01
		if(Local_semState == pdPASS){
    2d26:	89 81       	ldd	r24, Y+1	; 0x01
    2d28:	81 30       	cpi	r24, 0x01	; 1
    2d2a:	f1 f6       	brne	.-68     	; 0x2ce8 <Task2+0x12>
		// Check if the received data is '0', if so turn on Pin0


		switch(Recived_data)
    2d2c:	80 91 1a 06 	lds	r24, 0x061A
    2d30:	28 2f       	mov	r18, r24
    2d32:	30 e0       	ldi	r19, 0x00	; 0
    2d34:	3d 83       	std	Y+5, r19	; 0x05
    2d36:	2c 83       	std	Y+4, r18	; 0x04
    2d38:	8c 81       	ldd	r24, Y+4	; 0x04
    2d3a:	9d 81       	ldd	r25, Y+5	; 0x05
    2d3c:	85 33       	cpi	r24, 0x35	; 53
    2d3e:	91 05       	cpc	r25, r1
    2d40:	09 f4       	brne	.+2      	; 0x2d44 <Task2+0x6e>
    2d42:	cd c0       	rjmp	.+410    	; 0x2ede <Task2+0x208>
    2d44:	2c 81       	ldd	r18, Y+4	; 0x04
    2d46:	3d 81       	ldd	r19, Y+5	; 0x05
    2d48:	26 33       	cpi	r18, 0x36	; 54
    2d4a:	31 05       	cpc	r19, r1
    2d4c:	2c f5       	brge	.+74     	; 0x2d98 <Task2+0xc2>
    2d4e:	8c 81       	ldd	r24, Y+4	; 0x04
    2d50:	9d 81       	ldd	r25, Y+5	; 0x05
    2d52:	82 33       	cpi	r24, 0x32	; 50
    2d54:	91 05       	cpc	r25, r1
    2d56:	09 f4       	brne	.+2      	; 0x2d5a <Task2+0x84>
    2d58:	7a c0       	rjmp	.+244    	; 0x2e4e <Task2+0x178>
    2d5a:	2c 81       	ldd	r18, Y+4	; 0x04
    2d5c:	3d 81       	ldd	r19, Y+5	; 0x05
    2d5e:	23 33       	cpi	r18, 0x33	; 51
    2d60:	31 05       	cpc	r19, r1
    2d62:	6c f4       	brge	.+26     	; 0x2d7e <Task2+0xa8>
    2d64:	8c 81       	ldd	r24, Y+4	; 0x04
    2d66:	9d 81       	ldd	r25, Y+5	; 0x05
    2d68:	80 33       	cpi	r24, 0x30	; 48
    2d6a:	91 05       	cpc	r25, r1
    2d6c:	09 f4       	brne	.+2      	; 0x2d70 <Task2+0x9a>
    2d6e:	3f c0       	rjmp	.+126    	; 0x2dee <Task2+0x118>
    2d70:	2c 81       	ldd	r18, Y+4	; 0x04
    2d72:	3d 81       	ldd	r19, Y+5	; 0x05
    2d74:	21 33       	cpi	r18, 0x31	; 49
    2d76:	31 05       	cpc	r19, r1
    2d78:	09 f4       	brne	.+2      	; 0x2d7c <Task2+0xa6>
    2d7a:	51 c0       	rjmp	.+162    	; 0x2e1e <Task2+0x148>
    2d7c:	57 c1       	rjmp	.+686    	; 0x302c <Task2+0x356>
    2d7e:	8c 81       	ldd	r24, Y+4	; 0x04
    2d80:	9d 81       	ldd	r25, Y+5	; 0x05
    2d82:	83 33       	cpi	r24, 0x33	; 51
    2d84:	91 05       	cpc	r25, r1
    2d86:	09 f4       	brne	.+2      	; 0x2d8a <Task2+0xb4>
    2d88:	7a c0       	rjmp	.+244    	; 0x2e7e <Task2+0x1a8>
    2d8a:	2c 81       	ldd	r18, Y+4	; 0x04
    2d8c:	3d 81       	ldd	r19, Y+5	; 0x05
    2d8e:	24 33       	cpi	r18, 0x34	; 52
    2d90:	31 05       	cpc	r19, r1
    2d92:	09 f4       	brne	.+2      	; 0x2d96 <Task2+0xc0>
    2d94:	8c c0       	rjmp	.+280    	; 0x2eae <Task2+0x1d8>
    2d96:	4a c1       	rjmp	.+660    	; 0x302c <Task2+0x356>
    2d98:	8c 81       	ldd	r24, Y+4	; 0x04
    2d9a:	9d 81       	ldd	r25, Y+5	; 0x05
    2d9c:	88 33       	cpi	r24, 0x38	; 56
    2d9e:	91 05       	cpc	r25, r1
    2da0:	09 f4       	brne	.+2      	; 0x2da4 <Task2+0xce>
    2da2:	e5 c0       	rjmp	.+458    	; 0x2f6e <Task2+0x298>
    2da4:	2c 81       	ldd	r18, Y+4	; 0x04
    2da6:	3d 81       	ldd	r19, Y+5	; 0x05
    2da8:	29 33       	cpi	r18, 0x39	; 57
    2daa:	31 05       	cpc	r19, r1
    2dac:	6c f4       	brge	.+26     	; 0x2dc8 <Task2+0xf2>
    2dae:	8c 81       	ldd	r24, Y+4	; 0x04
    2db0:	9d 81       	ldd	r25, Y+5	; 0x05
    2db2:	86 33       	cpi	r24, 0x36	; 54
    2db4:	91 05       	cpc	r25, r1
    2db6:	09 f4       	brne	.+2      	; 0x2dba <Task2+0xe4>
    2db8:	aa c0       	rjmp	.+340    	; 0x2f0e <Task2+0x238>
    2dba:	2c 81       	ldd	r18, Y+4	; 0x04
    2dbc:	3d 81       	ldd	r19, Y+5	; 0x05
    2dbe:	27 33       	cpi	r18, 0x37	; 55
    2dc0:	31 05       	cpc	r19, r1
    2dc2:	09 f4       	brne	.+2      	; 0x2dc6 <Task2+0xf0>
    2dc4:	bc c0       	rjmp	.+376    	; 0x2f3e <Task2+0x268>
    2dc6:	32 c1       	rjmp	.+612    	; 0x302c <Task2+0x356>
    2dc8:	8c 81       	ldd	r24, Y+4	; 0x04
    2dca:	9d 81       	ldd	r25, Y+5	; 0x05
    2dcc:	81 34       	cpi	r24, 0x41	; 65
    2dce:	91 05       	cpc	r25, r1
    2dd0:	09 f4       	brne	.+2      	; 0x2dd4 <Task2+0xfe>
    2dd2:	fd c0       	rjmp	.+506    	; 0x2fce <Task2+0x2f8>
    2dd4:	2c 81       	ldd	r18, Y+4	; 0x04
    2dd6:	3d 81       	ldd	r19, Y+5	; 0x05
    2dd8:	22 34       	cpi	r18, 0x42	; 66
    2dda:	31 05       	cpc	r19, r1
    2ddc:	09 f4       	brne	.+2      	; 0x2de0 <Task2+0x10a>
    2dde:	0f c1       	rjmp	.+542    	; 0x2ffe <Task2+0x328>
    2de0:	8c 81       	ldd	r24, Y+4	; 0x04
    2de2:	9d 81       	ldd	r25, Y+5	; 0x05
    2de4:	89 33       	cpi	r24, 0x39	; 57
    2de6:	91 05       	cpc	r25, r1
    2de8:	09 f4       	brne	.+2      	; 0x2dec <Task2+0x116>
    2dea:	d9 c0       	rjmp	.+434    	; 0x2f9e <Task2+0x2c8>
    2dec:	1f c1       	rjmp	.+574    	; 0x302c <Task2+0x356>
		{
		case '0':
			DIO_voidSetPinValue(PORT_u8A,PIN_0,PIN_HIGH);
    2dee:	81 e0       	ldi	r24, 0x01	; 1
    2df0:	60 e0       	ldi	r22, 0x00	; 0
    2df2:	41 e0       	ldi	r20, 0x01	; 1
    2df4:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
			Led1On_DataTime = Counter;
    2df8:	80 91 1f 06 	lds	r24, 0x061F
    2dfc:	90 91 20 06 	lds	r25, 0x0620
    2e00:	a0 91 21 06 	lds	r26, 0x0621
    2e04:	b0 91 22 06 	lds	r27, 0x0622
    2e08:	80 93 8c 06 	sts	0x068C, r24
			EEPROM_voidWriteByte(0, Led1On_DataTime,EEPROM_DEVICE2);
    2e0c:	20 91 8c 06 	lds	r18, 0x068C
    2e10:	80 e0       	ldi	r24, 0x00	; 0
    2e12:	90 e0       	ldi	r25, 0x00	; 0
    2e14:	62 2f       	mov	r22, r18
    2e16:	41 e0       	ldi	r20, 0x01	; 1
    2e18:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2e1c:	07 c1       	rjmp	.+526    	; 0x302c <Task2+0x356>
		    break;
		case '1':
			DIO_voidSetPinValue(PORT_u8A,PIN_4,PIN_HIGH);
    2e1e:	81 e0       	ldi	r24, 0x01	; 1
    2e20:	64 e0       	ldi	r22, 0x04	; 4
    2e22:	41 e0       	ldi	r20, 0x01	; 1
    2e24:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
			Led1Off_DataTime = Counter;
    2e28:	80 91 1f 06 	lds	r24, 0x061F
    2e2c:	90 91 20 06 	lds	r25, 0x0620
    2e30:	a0 91 21 06 	lds	r26, 0x0621
    2e34:	b0 91 22 06 	lds	r27, 0x0622
    2e38:	80 93 89 06 	sts	0x0689, r24
			 EEPROM_voidWriteByte(10, Led1Off_DataTime,EEPROM_DEVICE2);
    2e3c:	20 91 89 06 	lds	r18, 0x0689
    2e40:	8a e0       	ldi	r24, 0x0A	; 10
    2e42:	90 e0       	ldi	r25, 0x00	; 0
    2e44:	62 2f       	mov	r22, r18
    2e46:	41 e0       	ldi	r20, 0x01	; 1
    2e48:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2e4c:	ef c0       	rjmp	.+478    	; 0x302c <Task2+0x356>
		    break;
		case '2':
			DIO_voidSetPinValue(PORT_u8C,PIN_6,PIN_HIGH);
    2e4e:	83 e0       	ldi	r24, 0x03	; 3
    2e50:	66 e0       	ldi	r22, 0x06	; 6
    2e52:	41 e0       	ldi	r20, 0x01	; 1
    2e54:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
			Led2On_DataTime = Counter;
    2e58:	80 91 1f 06 	lds	r24, 0x061F
    2e5c:	90 91 20 06 	lds	r25, 0x0620
    2e60:	a0 91 21 06 	lds	r26, 0x0621
    2e64:	b0 91 22 06 	lds	r27, 0x0622
    2e68:	80 93 8d 06 	sts	0x068D, r24
			 EEPROM_voidWriteByte(20, Led2On_DataTime,EEPROM_DEVICE2);
    2e6c:	20 91 8d 06 	lds	r18, 0x068D
    2e70:	84 e1       	ldi	r24, 0x14	; 20
    2e72:	90 e0       	ldi	r25, 0x00	; 0
    2e74:	62 2f       	mov	r22, r18
    2e76:	41 e0       	ldi	r20, 0x01	; 1
    2e78:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2e7c:	d7 c0       	rjmp	.+430    	; 0x302c <Task2+0x356>

		    break;
		case '3':
			DIO_voidSetPinValue(PORT_u8D,PIN_5,PIN_LOW);
    2e7e:	84 e0       	ldi	r24, 0x04	; 4
    2e80:	65 e0       	ldi	r22, 0x05	; 5
    2e82:	40 e0       	ldi	r20, 0x00	; 0
    2e84:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
//			DIO_voidSetPinValue(PORT_u8D,PIN_3,PIN_LOW);
			Led2Off_DataTime = Counter;
    2e88:	80 91 1f 06 	lds	r24, 0x061F
    2e8c:	90 91 20 06 	lds	r25, 0x0620
    2e90:	a0 91 21 06 	lds	r26, 0x0621
    2e94:	b0 91 22 06 	lds	r27, 0x0622
    2e98:	80 93 91 06 	sts	0x0691, r24
			 EEPROM_voidWriteByte(40, Led2Off_DataTime,EEPROM_DEVICE2);
    2e9c:	20 91 91 06 	lds	r18, 0x0691
    2ea0:	88 e2       	ldi	r24, 0x28	; 40
    2ea2:	90 e0       	ldi	r25, 0x00	; 0
    2ea4:	62 2f       	mov	r22, r18
    2ea6:	41 e0       	ldi	r20, 0x01	; 1
    2ea8:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2eac:	bf c0       	rjmp	.+382    	; 0x302c <Task2+0x356>
		    break;
		case '4':
			DIO_voidSetPinValue(PORT_u8D,PIN_3,PIN_HIGH);
    2eae:	84 e0       	ldi	r24, 0x04	; 4
    2eb0:	63 e0       	ldi	r22, 0x03	; 3
    2eb2:	41 e0       	ldi	r20, 0x01	; 1
    2eb4:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
			//DIO_voidSetPinValue(PORT_u8A,PIN_2,PIN_HIGH);
			Led3On_DataTime = Counter;
    2eb8:	80 91 1f 06 	lds	r24, 0x061F
    2ebc:	90 91 20 06 	lds	r25, 0x0620
    2ec0:	a0 91 21 06 	lds	r26, 0x0621
    2ec4:	b0 91 22 06 	lds	r27, 0x0622
    2ec8:	80 93 8e 06 	sts	0x068E, r24
			 EEPROM_voidWriteByte(60, Led3On_DataTime,EEPROM_DEVICE2);
    2ecc:	20 91 8e 06 	lds	r18, 0x068E
    2ed0:	8c e3       	ldi	r24, 0x3C	; 60
    2ed2:	90 e0       	ldi	r25, 0x00	; 0
    2ed4:	62 2f       	mov	r22, r18
    2ed6:	41 e0       	ldi	r20, 0x01	; 1
    2ed8:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2edc:	a7 c0       	rjmp	.+334    	; 0x302c <Task2+0x356>
		    break;
		case '5':
							DIO_voidSetPinValue(PORT_u8A , PIN_7 , PIN_HIGH);
    2ede:	81 e0       	ldi	r24, 0x01	; 1
    2ee0:	67 e0       	ldi	r22, 0x07	; 7
    2ee2:	41 e0       	ldi	r20, 0x01	; 1
    2ee4:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>

		//	DIO_voidSetPinValue(PORT_u8A,PIN_2,PIN_LOW);
			Led3Off_DataTime = Counter;
    2ee8:	80 91 1f 06 	lds	r24, 0x061F
    2eec:	90 91 20 06 	lds	r25, 0x0620
    2ef0:	a0 91 21 06 	lds	r26, 0x0621
    2ef4:	b0 91 22 06 	lds	r27, 0x0622
    2ef8:	80 93 97 06 	sts	0x0697, r24
			 EEPROM_voidWriteByte(80, Led3Off_DataTime,EEPROM_DEVICE2);
    2efc:	20 91 97 06 	lds	r18, 0x0697
    2f00:	80 e5       	ldi	r24, 0x50	; 80
    2f02:	90 e0       	ldi	r25, 0x00	; 0
    2f04:	62 2f       	mov	r22, r18
    2f06:	41 e0       	ldi	r20, 0x01	; 1
    2f08:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2f0c:	8f c0       	rjmp	.+286    	; 0x302c <Task2+0x356>

		    break;
		case '6':
			DIO_voidSetPinValue(PORT_u8A,PIN_0,PIN_LOW);
    2f0e:	81 e0       	ldi	r24, 0x01	; 1
    2f10:	60 e0       	ldi	r22, 0x00	; 0
    2f12:	40 e0       	ldi	r20, 0x00	; 0
    2f14:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
			Relay1On_DataTime = Counter;
    2f18:	80 91 1f 06 	lds	r24, 0x061F
    2f1c:	90 91 20 06 	lds	r25, 0x0620
    2f20:	a0 91 21 06 	lds	r26, 0x0621
    2f24:	b0 91 22 06 	lds	r27, 0x0622
    2f28:	80 93 92 06 	sts	0x0692, r24
			 EEPROM_voidWriteByte(80, Relay1On_DataTime,EEPROM_DEVICE2);
    2f2c:	20 91 92 06 	lds	r18, 0x0692
    2f30:	80 e5       	ldi	r24, 0x50	; 80
    2f32:	90 e0       	ldi	r25, 0x00	; 0
    2f34:	62 2f       	mov	r22, r18
    2f36:	41 e0       	ldi	r20, 0x01	; 1
    2f38:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2f3c:	77 c0       	rjmp	.+238    	; 0x302c <Task2+0x356>

		    break;

		case '7':
			DIO_voidSetPinValue(PORT_u8A,PIN_4,PIN_LOW);
    2f3e:	81 e0       	ldi	r24, 0x01	; 1
    2f40:	64 e0       	ldi	r22, 0x04	; 4
    2f42:	40 e0       	ldi	r20, 0x00	; 0
    2f44:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
			Relay1Off_DataTime = Counter;
    2f48:	80 91 1f 06 	lds	r24, 0x061F
    2f4c:	90 91 20 06 	lds	r25, 0x0620
    2f50:	a0 91 21 06 	lds	r26, 0x0621
    2f54:	b0 91 22 06 	lds	r27, 0x0622
    2f58:	80 93 8f 06 	sts	0x068F, r24
			 EEPROM_voidWriteByte(100, Relay1Off_DataTime,EEPROM_DEVICE2);
    2f5c:	20 91 8f 06 	lds	r18, 0x068F
    2f60:	84 e6       	ldi	r24, 0x64	; 100
    2f62:	90 e0       	ldi	r25, 0x00	; 0
    2f64:	62 2f       	mov	r22, r18
    2f66:	41 e0       	ldi	r20, 0x01	; 1
    2f68:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2f6c:	5f c0       	rjmp	.+190    	; 0x302c <Task2+0x356>

		    break;
		case '8':
			DIO_voidSetPinValue(PORT_u8C,PIN_6,PIN_LOW);
    2f6e:	83 e0       	ldi	r24, 0x03	; 3
    2f70:	66 e0       	ldi	r22, 0x06	; 6
    2f72:	40 e0       	ldi	r20, 0x00	; 0
    2f74:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
			Relay2On_DataTime = Counter;
    2f78:	80 91 1f 06 	lds	r24, 0x061F
    2f7c:	90 91 20 06 	lds	r25, 0x0620
    2f80:	a0 91 21 06 	lds	r26, 0x0621
    2f84:	b0 91 22 06 	lds	r27, 0x0622
    2f88:	80 93 8a 06 	sts	0x068A, r24
			 EEPROM_voidWriteByte(120, Relay2On_DataTime,EEPROM_DEVICE2);
    2f8c:	20 91 8a 06 	lds	r18, 0x068A
    2f90:	88 e7       	ldi	r24, 0x78	; 120
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	62 2f       	mov	r22, r18
    2f96:	41 e0       	ldi	r20, 0x01	; 1
    2f98:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2f9c:	47 c0       	rjmp	.+142    	; 0x302c <Task2+0x356>

		    break;

		case '9':
			DIO_voidSetPinValue(PORT_u8D,PIN_5,PIN_HIGH);
    2f9e:	84 e0       	ldi	r24, 0x04	; 4
    2fa0:	65 e0       	ldi	r22, 0x05	; 5
    2fa2:	41 e0       	ldi	r20, 0x01	; 1
    2fa4:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
			//DIO_voidSetPinValue(PORT_u8A,PIN_4,PIN_LOW);
			Relay2Off_DataTime = Counter;
    2fa8:	80 91 1f 06 	lds	r24, 0x061F
    2fac:	90 91 20 06 	lds	r25, 0x0620
    2fb0:	a0 91 21 06 	lds	r26, 0x0621
    2fb4:	b0 91 22 06 	lds	r27, 0x0622
    2fb8:	80 93 90 06 	sts	0x0690, r24
			 EEPROM_voidWriteByte(150, Relay2Off_DataTime,EEPROM_DEVICE2);
    2fbc:	20 91 90 06 	lds	r18, 0x0690
    2fc0:	86 e9       	ldi	r24, 0x96	; 150
    2fc2:	90 e0       	ldi	r25, 0x00	; 0
    2fc4:	62 2f       	mov	r22, r18
    2fc6:	41 e0       	ldi	r20, 0x01	; 1
    2fc8:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2fcc:	2f c0       	rjmp	.+94     	; 0x302c <Task2+0x356>

		    break;
		case 'A':
			DIO_voidSetPinValue(PORT_u8D,PIN_5,PIN_LOW);
    2fce:	84 e0       	ldi	r24, 0x04	; 4
    2fd0:	65 e0       	ldi	r22, 0x05	; 5
    2fd2:	40 e0       	ldi	r20, 0x00	; 0
    2fd4:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
			//DIO_voidSetPinValue(PORT_u8A,PIN_5,PIN_HIGH);
			MotorOn_DataTime = Counter;
    2fd8:	80 91 1f 06 	lds	r24, 0x061F
    2fdc:	90 91 20 06 	lds	r25, 0x0620
    2fe0:	a0 91 21 06 	lds	r26, 0x0621
    2fe4:	b0 91 22 06 	lds	r27, 0x0622
    2fe8:	80 93 93 06 	sts	0x0693, r24
			 EEPROM_voidWriteByte(200, MotorOn_DataTime,EEPROM_DEVICE2);
    2fec:	20 91 93 06 	lds	r18, 0x0693
    2ff0:	88 ec       	ldi	r24, 0xC8	; 200
    2ff2:	90 e0       	ldi	r25, 0x00	; 0
    2ff4:	62 2f       	mov	r22, r18
    2ff6:	41 e0       	ldi	r20, 0x01	; 1
    2ff8:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
    2ffc:	17 c0       	rjmp	.+46     	; 0x302c <Task2+0x356>

		    break;

		case 'B':

			DIO_voidSetPinValue(PORT_u8A,PIN_7,PIN_LOW);
    2ffe:	81 e0       	ldi	r24, 0x01	; 1
    3000:	67 e0       	ldi	r22, 0x07	; 7
    3002:	40 e0       	ldi	r20, 0x00	; 0
    3004:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
			MotorOff_DataTime = Counter;
    3008:	80 91 1f 06 	lds	r24, 0x061F
    300c:	90 91 20 06 	lds	r25, 0x0620
    3010:	a0 91 21 06 	lds	r26, 0x0621
    3014:	b0 91 22 06 	lds	r27, 0x0622
    3018:	80 93 96 06 	sts	0x0696, r24
			 EEPROM_voidWriteByte(300, MotorOff_DataTime,EEPROM_DEVICE2);
    301c:	20 91 96 06 	lds	r18, 0x0696
    3020:	8c e2       	ldi	r24, 0x2C	; 44
    3022:	91 e0       	ldi	r25, 0x01	; 1
    3024:	62 2f       	mov	r22, r18
    3026:	41 e0       	ldi	r20, 0x01	; 1
    3028:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <EEPROM_voidWriteByte>
//				} else {
//					DIO_voidSetPinValue(PORT_u8C,PIN_6,PIN_LOW);
//				}


		xSemaphoreGive(LEDS_sm);
    302c:	80 91 94 06 	lds	r24, 0x0694
    3030:	90 91 95 06 	lds	r25, 0x0695
    3034:	60 e0       	ldi	r22, 0x00	; 0
    3036:	70 e0       	ldi	r23, 0x00	; 0
    3038:	40 e0       	ldi	r20, 0x00	; 0
    303a:	50 e0       	ldi	r21, 0x00	; 0
    303c:	20 e0       	ldi	r18, 0x00	; 0
    303e:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <xQueueGenericSend>
		vTaskDelay(1);
    3042:	81 e0       	ldi	r24, 0x01	; 1
    3044:	90 e0       	ldi	r25, 0x00	; 0
    3046:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <vTaskDelay>
    304a:	4e ce       	rjmp	.-868    	; 0x2ce8 <Task2+0x12>

0000304c <Task3>:
	}
}

// Task to display received data on the LCD
void Task3(void *p)
{
    304c:	df 93       	push	r29
    304e:	cf 93       	push	r28
    3050:	cd b7       	in	r28, 0x3d	; 61
    3052:	de b7       	in	r29, 0x3e	; 62
    3054:	63 97       	sbiw	r28, 0x13	; 19
    3056:	0f b6       	in	r0, 0x3f	; 63
    3058:	f8 94       	cli
    305a:	de bf       	out	0x3e, r29	; 62
    305c:	0f be       	out	0x3f, r0	; 63
    305e:	cd bf       	out	0x3d, r28	; 61
    3060:	99 8b       	std	Y+17, r25	; 0x11
    3062:	88 8b       	std	Y+16, r24	; 0x10
	while(1)
	{
		u8 Local_semState = xSemaphoreTake(LEDS_sm , portMAX_DELAY);
    3064:	80 91 94 06 	lds	r24, 0x0694
    3068:	90 91 95 06 	lds	r25, 0x0695
    306c:	60 e0       	ldi	r22, 0x00	; 0
    306e:	70 e0       	ldi	r23, 0x00	; 0
    3070:	4f ef       	ldi	r20, 0xFF	; 255
    3072:	5f ef       	ldi	r21, 0xFF	; 255
    3074:	20 e0       	ldi	r18, 0x00	; 0
    3076:	0e 94 38 1f 	call	0x3e70	; 0x3e70 <xQueueGenericReceive>
    307a:	8f 87       	std	Y+15, r24	; 0x0f
		if(Local_semState == pdPASS){
    307c:	8f 85       	ldd	r24, Y+15	; 0x0f
    307e:	81 30       	cpi	r24, 0x01	; 1
    3080:	89 f7       	brne	.-30     	; 0x3064 <Task3+0x18>

			switch (Recived_data) {
    3082:	80 91 1a 06 	lds	r24, 0x061A
    3086:	28 2f       	mov	r18, r24
    3088:	30 e0       	ldi	r19, 0x00	; 0
    308a:	3b 8b       	std	Y+19, r19	; 0x13
    308c:	2a 8b       	std	Y+18, r18	; 0x12
    308e:	8a 89       	ldd	r24, Y+18	; 0x12
    3090:	9b 89       	ldd	r25, Y+19	; 0x13
    3092:	85 33       	cpi	r24, 0x35	; 53
    3094:	91 05       	cpc	r25, r1
    3096:	09 f4       	brne	.+2      	; 0x309a <Task3+0x4e>
    3098:	8c c0       	rjmp	.+280    	; 0x31b2 <Task3+0x166>
    309a:	2a 89       	ldd	r18, Y+18	; 0x12
    309c:	3b 89       	ldd	r19, Y+19	; 0x13
    309e:	26 33       	cpi	r18, 0x36	; 54
    30a0:	31 05       	cpc	r19, r1
    30a2:	2c f5       	brge	.+74     	; 0x30ee <Task3+0xa2>
    30a4:	8a 89       	ldd	r24, Y+18	; 0x12
    30a6:	9b 89       	ldd	r25, Y+19	; 0x13
    30a8:	82 33       	cpi	r24, 0x32	; 50
    30aa:	91 05       	cpc	r25, r1
    30ac:	09 f4       	brne	.+2      	; 0x30b0 <Task3+0x64>
    30ae:	60 c0       	rjmp	.+192    	; 0x3170 <Task3+0x124>
    30b0:	2a 89       	ldd	r18, Y+18	; 0x12
    30b2:	3b 89       	ldd	r19, Y+19	; 0x13
    30b4:	23 33       	cpi	r18, 0x33	; 51
    30b6:	31 05       	cpc	r19, r1
    30b8:	6c f4       	brge	.+26     	; 0x30d4 <Task3+0x88>
    30ba:	8a 89       	ldd	r24, Y+18	; 0x12
    30bc:	9b 89       	ldd	r25, Y+19	; 0x13
    30be:	80 33       	cpi	r24, 0x30	; 48
    30c0:	91 05       	cpc	r25, r1
    30c2:	09 f4       	brne	.+2      	; 0x30c6 <Task3+0x7a>
    30c4:	3f c0       	rjmp	.+126    	; 0x3144 <Task3+0xf8>
    30c6:	2a 89       	ldd	r18, Y+18	; 0x12
    30c8:	3b 89       	ldd	r19, Y+19	; 0x13
    30ca:	21 33       	cpi	r18, 0x31	; 49
    30cc:	31 05       	cpc	r19, r1
    30ce:	09 f4       	brne	.+2      	; 0x30d2 <Task3+0x86>
    30d0:	44 c0       	rjmp	.+136    	; 0x315a <Task3+0x10e>
    30d2:	bb c0       	rjmp	.+374    	; 0x324a <Task3+0x1fe>
    30d4:	8a 89       	ldd	r24, Y+18	; 0x12
    30d6:	9b 89       	ldd	r25, Y+19	; 0x13
    30d8:	83 33       	cpi	r24, 0x33	; 51
    30da:	91 05       	cpc	r25, r1
    30dc:	09 f4       	brne	.+2      	; 0x30e0 <Task3+0x94>
    30de:	53 c0       	rjmp	.+166    	; 0x3186 <Task3+0x13a>
    30e0:	2a 89       	ldd	r18, Y+18	; 0x12
    30e2:	3b 89       	ldd	r19, Y+19	; 0x13
    30e4:	24 33       	cpi	r18, 0x34	; 52
    30e6:	31 05       	cpc	r19, r1
    30e8:	09 f4       	brne	.+2      	; 0x30ec <Task3+0xa0>
    30ea:	58 c0       	rjmp	.+176    	; 0x319c <Task3+0x150>
    30ec:	ae c0       	rjmp	.+348    	; 0x324a <Task3+0x1fe>
    30ee:	8a 89       	ldd	r24, Y+18	; 0x12
    30f0:	9b 89       	ldd	r25, Y+19	; 0x13
    30f2:	88 33       	cpi	r24, 0x38	; 56
    30f4:	91 05       	cpc	r25, r1
    30f6:	09 f4       	brne	.+2      	; 0x30fa <Task3+0xae>
    30f8:	7d c0       	rjmp	.+250    	; 0x31f4 <Task3+0x1a8>
    30fa:	2a 89       	ldd	r18, Y+18	; 0x12
    30fc:	3b 89       	ldd	r19, Y+19	; 0x13
    30fe:	29 33       	cpi	r18, 0x39	; 57
    3100:	31 05       	cpc	r19, r1
    3102:	6c f4       	brge	.+26     	; 0x311e <Task3+0xd2>
    3104:	8a 89       	ldd	r24, Y+18	; 0x12
    3106:	9b 89       	ldd	r25, Y+19	; 0x13
    3108:	86 33       	cpi	r24, 0x36	; 54
    310a:	91 05       	cpc	r25, r1
    310c:	09 f4       	brne	.+2      	; 0x3110 <Task3+0xc4>
    310e:	5c c0       	rjmp	.+184    	; 0x31c8 <Task3+0x17c>
    3110:	2a 89       	ldd	r18, Y+18	; 0x12
    3112:	3b 89       	ldd	r19, Y+19	; 0x13
    3114:	27 33       	cpi	r18, 0x37	; 55
    3116:	31 05       	cpc	r19, r1
    3118:	09 f4       	brne	.+2      	; 0x311c <Task3+0xd0>
    311a:	61 c0       	rjmp	.+194    	; 0x31de <Task3+0x192>
    311c:	96 c0       	rjmp	.+300    	; 0x324a <Task3+0x1fe>
    311e:	8a 89       	ldd	r24, Y+18	; 0x12
    3120:	9b 89       	ldd	r25, Y+19	; 0x13
    3122:	81 34       	cpi	r24, 0x41	; 65
    3124:	91 05       	cpc	r25, r1
    3126:	09 f4       	brne	.+2      	; 0x312a <Task3+0xde>
    3128:	7b c0       	rjmp	.+246    	; 0x3220 <Task3+0x1d4>
    312a:	2a 89       	ldd	r18, Y+18	; 0x12
    312c:	3b 89       	ldd	r19, Y+19	; 0x13
    312e:	22 34       	cpi	r18, 0x42	; 66
    3130:	31 05       	cpc	r19, r1
    3132:	09 f4       	brne	.+2      	; 0x3136 <Task3+0xea>
    3134:	80 c0       	rjmp	.+256    	; 0x3236 <Task3+0x1ea>
    3136:	8a 89       	ldd	r24, Y+18	; 0x12
    3138:	9b 89       	ldd	r25, Y+19	; 0x13
    313a:	89 33       	cpi	r24, 0x39	; 57
    313c:	91 05       	cpc	r25, r1
    313e:	09 f4       	brne	.+2      	; 0x3142 <Task3+0xf6>
    3140:	64 c0       	rjmp	.+200    	; 0x320a <Task3+0x1be>
    3142:	83 c0       	rjmp	.+262    	; 0x324a <Task3+0x1fe>
				case '0':

					CLCD_voidClearDisplay();
    3144:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
				    CLCD_voidSitPosition(0,0);
    3148:	80 e0       	ldi	r24, 0x00	; 0
    314a:	60 e0       	ldi	r22, 0x00	; 0
    314c:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
				    CLCD_voidSendString("Led one:on");
    3150:	80 e6       	ldi	r24, 0x60	; 96
    3152:	90 e0       	ldi	r25, 0x00	; 0
    3154:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    3158:	78 c0       	rjmp	.+240    	; 0x324a <Task3+0x1fe>

					break;
				case '1':
					CLCD_voidClearDisplay();
    315a:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					CLCD_voidSitPosition(0,0);
    315e:	80 e0       	ldi	r24, 0x00	; 0
    3160:	60 e0       	ldi	r22, 0x00	; 0
    3162:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					CLCD_voidSendString("Led Two :on");
    3166:	8b e6       	ldi	r24, 0x6B	; 107
    3168:	90 e0       	ldi	r25, 0x00	; 0
    316a:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    316e:	6d c0       	rjmp	.+218    	; 0x324a <Task3+0x1fe>

					break;
				case '2':
					CLCD_voidClearDisplay();
    3170:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					CLCD_voidSitPosition(0,0);
    3174:	80 e0       	ldi	r24, 0x00	; 0
    3176:	60 e0       	ldi	r22, 0x00	; 0
    3178:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					CLCD_voidSendString("Led Three : on");
    317c:	87 e7       	ldi	r24, 0x77	; 119
    317e:	90 e0       	ldi	r25, 0x00	; 0
    3180:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    3184:	62 c0       	rjmp	.+196    	; 0x324a <Task3+0x1fe>

					break;

				case '3':
					CLCD_voidClearDisplay();
    3186:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					CLCD_voidSitPosition(0,0);
    318a:	80 e0       	ldi	r24, 0x00	; 0
    318c:	60 e0       	ldi	r22, 0x00	; 0
    318e:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					CLCD_voidSendString("Relay One : on");
    3192:	86 e8       	ldi	r24, 0x86	; 134
    3194:	90 e0       	ldi	r25, 0x00	; 0
    3196:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    319a:	57 c0       	rjmp	.+174    	; 0x324a <Task3+0x1fe>

					break;


				case '4':
					   CLCD_voidClearDisplay();
    319c:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					   CLCD_voidSitPosition(0,0);
    31a0:	80 e0       	ldi	r24, 0x00	; 0
    31a2:	60 e0       	ldi	r22, 0x00	; 0
    31a4:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					   CLCD_voidSendString("Relay Two:on");
    31a8:	85 e9       	ldi	r24, 0x95	; 149
    31aa:	90 e0       	ldi	r25, 0x00	; 0
    31ac:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    31b0:	4c c0       	rjmp	.+152    	; 0x324a <Task3+0x1fe>

					break;

				case '5':

					CLCD_voidClearDisplay();
    31b2:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					CLCD_voidSitPosition(0,0);
    31b6:	80 e0       	ldi	r24, 0x00	; 0
    31b8:	60 e0       	ldi	r22, 0x00	; 0
    31ba:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					CLCD_voidSendString("Motor : on");
    31be:	82 ea       	ldi	r24, 0xA2	; 162
    31c0:	90 e0       	ldi	r25, 0x00	; 0
    31c2:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    31c6:	41 c0       	rjmp	.+130    	; 0x324a <Task3+0x1fe>

					break;
				case '6':
					   CLCD_voidClearDisplay();
    31c8:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					   CLCD_voidSitPosition(0,0);
    31cc:	80 e0       	ldi	r24, 0x00	; 0
    31ce:	60 e0       	ldi	r22, 0x00	; 0
    31d0:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					   CLCD_voidSendString("Led One : off");
    31d4:	8d ea       	ldi	r24, 0xAD	; 173
    31d6:	90 e0       	ldi	r25, 0x00	; 0
    31d8:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    31dc:	36 c0       	rjmp	.+108    	; 0x324a <Task3+0x1fe>

					break;
				case '7':
					CLCD_voidClearDisplay();
    31de:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					CLCD_voidSitPosition(0,0);
    31e2:	80 e0       	ldi	r24, 0x00	; 0
    31e4:	60 e0       	ldi	r22, 0x00	; 0
    31e6:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					CLCD_voidSendString("Led Two : off");
    31ea:	8b eb       	ldi	r24, 0xBB	; 187
    31ec:	90 e0       	ldi	r25, 0x00	; 0
    31ee:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    31f2:	2b c0       	rjmp	.+86     	; 0x324a <Task3+0x1fe>
					break;

				case '8':
					   CLCD_voidClearDisplay();
    31f4:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					   CLCD_voidSitPosition(0,0);
    31f8:	80 e0       	ldi	r24, 0x00	; 0
    31fa:	60 e0       	ldi	r22, 0x00	; 0
    31fc:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					   CLCD_voidSendString("Led Three : off");
    3200:	89 ec       	ldi	r24, 0xC9	; 201
    3202:	90 e0       	ldi	r25, 0x00	; 0
    3204:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    3208:	20 c0       	rjmp	.+64     	; 0x324a <Task3+0x1fe>

					break;
				case '9':
					CLCD_voidClearDisplay();
    320a:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					CLCD_voidSitPosition(0,0);
    320e:	80 e0       	ldi	r24, 0x00	; 0
    3210:	60 e0       	ldi	r22, 0x00	; 0
    3212:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					CLCD_voidSendString("Relay One : off");
    3216:	89 ed       	ldi	r24, 0xD9	; 217
    3218:	90 e0       	ldi	r25, 0x00	; 0
    321a:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    321e:	15 c0       	rjmp	.+42     	; 0x324a <Task3+0x1fe>
					break;

				case 'A':
					CLCD_voidClearDisplay();
    3220:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					CLCD_voidSitPosition(0,0);
    3224:	80 e0       	ldi	r24, 0x00	; 0
    3226:	60 e0       	ldi	r22, 0x00	; 0
    3228:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					CLCD_voidSendString("Relay Two : off");
    322c:	89 ee       	ldi	r24, 0xE9	; 233
    322e:	90 e0       	ldi	r25, 0x00	; 0
    3230:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
    3234:	0a c0       	rjmp	.+20     	; 0x324a <Task3+0x1fe>
					break;

				case 'B':
					CLCD_voidClearDisplay();
    3236:	0e 94 56 09 	call	0x12ac	; 0x12ac <CLCD_voidClearDisplay>
					CLCD_voidSitPosition(0,0);
    323a:	80 e0       	ldi	r24, 0x00	; 0
    323c:	60 e0       	ldi	r22, 0x00	; 0
    323e:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CLCD_voidSitPosition>
					CLCD_voidSendString("Motor : off");
    3242:	89 ef       	ldi	r24, 0xF9	; 249
    3244:	90 e0       	ldi	r25, 0x00	; 0
    3246:	0e 94 c3 08 	call	0x1186	; 0x1186 <CLCD_voidSendString>
				default :

					break;

			}
			DIO_voidSetPinValue(PORT_u8A,PIN_6,PIN_HIGH);
    324a:	81 e0       	ldi	r24, 0x01	; 1
    324c:	66 e0       	ldi	r22, 0x06	; 6
    324e:	41 e0       	ldi	r20, 0x01	; 1
    3250:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
    3254:	80 e0       	ldi	r24, 0x00	; 0
    3256:	90 e0       	ldi	r25, 0x00	; 0
    3258:	a8 e4       	ldi	r26, 0x48	; 72
    325a:	b2 e4       	ldi	r27, 0x42	; 66
    325c:	8b 87       	std	Y+11, r24	; 0x0b
    325e:	9c 87       	std	Y+12, r25	; 0x0c
    3260:	ad 87       	std	Y+13, r26	; 0x0d
    3262:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3264:	6b 85       	ldd	r22, Y+11	; 0x0b
    3266:	7c 85       	ldd	r23, Y+12	; 0x0c
    3268:	8d 85       	ldd	r24, Y+13	; 0x0d
    326a:	9e 85       	ldd	r25, Y+14	; 0x0e
    326c:	20 e0       	ldi	r18, 0x00	; 0
    326e:	30 e0       	ldi	r19, 0x00	; 0
    3270:	4a ef       	ldi	r20, 0xFA	; 250
    3272:	54 e4       	ldi	r21, 0x44	; 68
    3274:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3278:	dc 01       	movw	r26, r24
    327a:	cb 01       	movw	r24, r22
    327c:	8f 83       	std	Y+7, r24	; 0x07
    327e:	98 87       	std	Y+8, r25	; 0x08
    3280:	a9 87       	std	Y+9, r26	; 0x09
    3282:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3284:	6f 81       	ldd	r22, Y+7	; 0x07
    3286:	78 85       	ldd	r23, Y+8	; 0x08
    3288:	89 85       	ldd	r24, Y+9	; 0x09
    328a:	9a 85       	ldd	r25, Y+10	; 0x0a
    328c:	20 e0       	ldi	r18, 0x00	; 0
    328e:	30 e0       	ldi	r19, 0x00	; 0
    3290:	40 e8       	ldi	r20, 0x80	; 128
    3292:	5f e3       	ldi	r21, 0x3F	; 63
    3294:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3298:	88 23       	and	r24, r24
    329a:	2c f4       	brge	.+10     	; 0x32a6 <Task3+0x25a>
		__ticks = 1;
    329c:	81 e0       	ldi	r24, 0x01	; 1
    329e:	90 e0       	ldi	r25, 0x00	; 0
    32a0:	9e 83       	std	Y+6, r25	; 0x06
    32a2:	8d 83       	std	Y+5, r24	; 0x05
    32a4:	3f c0       	rjmp	.+126    	; 0x3324 <Task3+0x2d8>
	else if (__tmp > 65535)
    32a6:	6f 81       	ldd	r22, Y+7	; 0x07
    32a8:	78 85       	ldd	r23, Y+8	; 0x08
    32aa:	89 85       	ldd	r24, Y+9	; 0x09
    32ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    32ae:	20 e0       	ldi	r18, 0x00	; 0
    32b0:	3f ef       	ldi	r19, 0xFF	; 255
    32b2:	4f e7       	ldi	r20, 0x7F	; 127
    32b4:	57 e4       	ldi	r21, 0x47	; 71
    32b6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    32ba:	18 16       	cp	r1, r24
    32bc:	4c f5       	brge	.+82     	; 0x3310 <Task3+0x2c4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    32be:	6b 85       	ldd	r22, Y+11	; 0x0b
    32c0:	7c 85       	ldd	r23, Y+12	; 0x0c
    32c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    32c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    32c6:	20 e0       	ldi	r18, 0x00	; 0
    32c8:	30 e0       	ldi	r19, 0x00	; 0
    32ca:	40 e2       	ldi	r20, 0x20	; 32
    32cc:	51 e4       	ldi	r21, 0x41	; 65
    32ce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    32d2:	dc 01       	movw	r26, r24
    32d4:	cb 01       	movw	r24, r22
    32d6:	bc 01       	movw	r22, r24
    32d8:	cd 01       	movw	r24, r26
    32da:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    32de:	dc 01       	movw	r26, r24
    32e0:	cb 01       	movw	r24, r22
    32e2:	9e 83       	std	Y+6, r25	; 0x06
    32e4:	8d 83       	std	Y+5, r24	; 0x05
    32e6:	0f c0       	rjmp	.+30     	; 0x3306 <Task3+0x2ba>
    32e8:	88 ec       	ldi	r24, 0xC8	; 200
    32ea:	90 e0       	ldi	r25, 0x00	; 0
    32ec:	9c 83       	std	Y+4, r25	; 0x04
    32ee:	8b 83       	std	Y+3, r24	; 0x03
    32f0:	8b 81       	ldd	r24, Y+3	; 0x03
    32f2:	9c 81       	ldd	r25, Y+4	; 0x04
    32f4:	01 97       	sbiw	r24, 0x01	; 1
    32f6:	f1 f7       	brne	.-4      	; 0x32f4 <Task3+0x2a8>
    32f8:	9c 83       	std	Y+4, r25	; 0x04
    32fa:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    32fc:	8d 81       	ldd	r24, Y+5	; 0x05
    32fe:	9e 81       	ldd	r25, Y+6	; 0x06
    3300:	01 97       	sbiw	r24, 0x01	; 1
    3302:	9e 83       	std	Y+6, r25	; 0x06
    3304:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3306:	8d 81       	ldd	r24, Y+5	; 0x05
    3308:	9e 81       	ldd	r25, Y+6	; 0x06
    330a:	00 97       	sbiw	r24, 0x00	; 0
    330c:	69 f7       	brne	.-38     	; 0x32e8 <Task3+0x29c>
    330e:	14 c0       	rjmp	.+40     	; 0x3338 <Task3+0x2ec>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3310:	6f 81       	ldd	r22, Y+7	; 0x07
    3312:	78 85       	ldd	r23, Y+8	; 0x08
    3314:	89 85       	ldd	r24, Y+9	; 0x09
    3316:	9a 85       	ldd	r25, Y+10	; 0x0a
    3318:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    331c:	dc 01       	movw	r26, r24
    331e:	cb 01       	movw	r24, r22
    3320:	9e 83       	std	Y+6, r25	; 0x06
    3322:	8d 83       	std	Y+5, r24	; 0x05
    3324:	8d 81       	ldd	r24, Y+5	; 0x05
    3326:	9e 81       	ldd	r25, Y+6	; 0x06
    3328:	9a 83       	std	Y+2, r25	; 0x02
    332a:	89 83       	std	Y+1, r24	; 0x01
    332c:	89 81       	ldd	r24, Y+1	; 0x01
    332e:	9a 81       	ldd	r25, Y+2	; 0x02
    3330:	01 97       	sbiw	r24, 0x01	; 1
    3332:	f1 f7       	brne	.-4      	; 0x3330 <Task3+0x2e4>
    3334:	9a 83       	std	Y+2, r25	; 0x02
    3336:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(50);
		    DIO_voidSetPinValue(PORT_u8A,PIN_6,PIN_LOW);
    3338:	81 e0       	ldi	r24, 0x01	; 1
    333a:	66 e0       	ldi	r22, 0x06	; 6
    333c:	40 e0       	ldi	r20, 0x00	; 0
    333e:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>


		xSemaphoreGive(LEDS_sm);
    3342:	80 91 94 06 	lds	r24, 0x0694
    3346:	90 91 95 06 	lds	r25, 0x0695
    334a:	60 e0       	ldi	r22, 0x00	; 0
    334c:	70 e0       	ldi	r23, 0x00	; 0
    334e:	40 e0       	ldi	r20, 0x00	; 0
    3350:	50 e0       	ldi	r21, 0x00	; 0
    3352:	20 e0       	ldi	r18, 0x00	; 0
    3354:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <xQueueGenericSend>
		vTaskDelay(10);
    3358:	8a e0       	ldi	r24, 0x0A	; 10
    335a:	90 e0       	ldi	r25, 0x00	; 0
    335c:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <vTaskDelay>
    3360:	81 ce       	rjmp	.-766    	; 0x3064 <Task3+0x18>

00003362 <Task4>:
		}
	}
}

void Task4(void *p)
{
    3362:	df 93       	push	r29
    3364:	cf 93       	push	r28
    3366:	cd b7       	in	r28, 0x3d	; 61
    3368:	de b7       	in	r29, 0x3e	; 62
    336a:	28 97       	sbiw	r28, 0x08	; 8
    336c:	0f b6       	in	r0, 0x3f	; 63
    336e:	f8 94       	cli
    3370:	de bf       	out	0x3e, r29	; 62
    3372:	0f be       	out	0x3f, r0	; 63
    3374:	cd bf       	out	0x3d, r28	; 61
    3376:	9a 83       	std	Y+2, r25	; 0x02
    3378:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{

//		u8 Local_semState = xSemaphoreTake(LEDS_sm , portMAX_DELAY);
//		if(Local_semState == pdPASS){
		if(SWITCH_u8IsPressed(Switch_3)){
    337a:	60 91 19 01 	lds	r22, 0x0119
    337e:	70 91 1a 01 	lds	r23, 0x011A
    3382:	80 91 1b 01 	lds	r24, 0x011B
    3386:	0e 94 3f 10 	call	0x207e	; 0x207e <SWITCH_u8IsPressed>
    338a:	88 23       	and	r24, r24
    338c:	c1 f0       	breq	.+48     	; 0x33be <Task4+0x5c>

			LedOneState=!LedOneState;
    338e:	80 91 25 06 	lds	r24, 0x0625
    3392:	1d 82       	std	Y+5, r1	; 0x05
    3394:	88 23       	and	r24, r24
    3396:	11 f4       	brne	.+4      	; 0x339c <Task4+0x3a>
    3398:	81 e0       	ldi	r24, 0x01	; 1
    339a:	8d 83       	std	Y+5, r24	; 0x05
    339c:	8d 81       	ldd	r24, Y+5	; 0x05
    339e:	80 93 25 06 	sts	0x0625, r24
					DIO_voidSetPinValue(PORT_u8A, PIN_0, LedOneState?PIN_HIGH:PIN_LOW);
    33a2:	80 91 25 06 	lds	r24, 0x0625
    33a6:	8e 83       	std	Y+6, r24	; 0x06
    33a8:	8e 81       	ldd	r24, Y+6	; 0x06
    33aa:	88 23       	and	r24, r24
    33ac:	11 f0       	breq	.+4      	; 0x33b2 <Task4+0x50>
    33ae:	81 e0       	ldi	r24, 0x01	; 1
    33b0:	8e 83       	std	Y+6, r24	; 0x06
    33b2:	9e 81       	ldd	r25, Y+6	; 0x06
    33b4:	81 e0       	ldi	r24, 0x01	; 1
    33b6:	60 e0       	ldi	r22, 0x00	; 0
    33b8:	49 2f       	mov	r20, r25
    33ba:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
				} else {
					//DIO_voidSetPinValue(PORT_u8A, PIN_0, PIN_LOW);
				}

				if(SWITCH_u8IsPressed(Switch_5)){
    33be:	60 91 1f 01 	lds	r22, 0x011F
    33c2:	70 91 20 01 	lds	r23, 0x0120
    33c6:	80 91 21 01 	lds	r24, 0x0121
    33ca:	0e 94 3f 10 	call	0x207e	; 0x207e <SWITCH_u8IsPressed>
    33ce:	88 23       	and	r24, r24
    33d0:	c1 f0       	breq	.+48     	; 0x3402 <Task4+0xa0>
					LedTwoState =!LedTwoState;
    33d2:	80 91 24 06 	lds	r24, 0x0624
    33d6:	1c 82       	std	Y+4, r1	; 0x04
    33d8:	88 23       	and	r24, r24
    33da:	11 f4       	brne	.+4      	; 0x33e0 <Task4+0x7e>
    33dc:	81 e0       	ldi	r24, 0x01	; 1
    33de:	8c 83       	std	Y+4, r24	; 0x04
    33e0:	8c 81       	ldd	r24, Y+4	; 0x04
    33e2:	80 93 24 06 	sts	0x0624, r24
					DIO_voidSetPinValue(PORT_u8A, PIN_4, LedTwoState?PIN_HIGH:PIN_LOW);
    33e6:	80 91 24 06 	lds	r24, 0x0624
    33ea:	8f 83       	std	Y+7, r24	; 0x07
    33ec:	8f 81       	ldd	r24, Y+7	; 0x07
    33ee:	88 23       	and	r24, r24
    33f0:	11 f0       	breq	.+4      	; 0x33f6 <Task4+0x94>
    33f2:	81 e0       	ldi	r24, 0x01	; 1
    33f4:	8f 83       	std	Y+7, r24	; 0x07
    33f6:	9f 81       	ldd	r25, Y+7	; 0x07
    33f8:	81 e0       	ldi	r24, 0x01	; 1
    33fa:	64 e0       	ldi	r22, 0x04	; 4
    33fc:	49 2f       	mov	r20, r25
    33fe:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
				} else {
					//DIO_voidSetPinValue(PORT_u8A, PIN_4, PIN_LOW);
				}

				if(SWITCH_u8IsPressed(Switch_6)){
    3402:	60 91 22 01 	lds	r22, 0x0122
    3406:	70 91 23 01 	lds	r23, 0x0123
    340a:	80 91 24 01 	lds	r24, 0x0124
    340e:	0e 94 3f 10 	call	0x207e	; 0x207e <SWITCH_u8IsPressed>
    3412:	88 23       	and	r24, r24
    3414:	c1 f0       	breq	.+48     	; 0x3446 <Task4+0xe4>
					LedThreeState =!LedThreeState;
    3416:	80 91 23 06 	lds	r24, 0x0623
    341a:	1b 82       	std	Y+3, r1	; 0x03
    341c:	88 23       	and	r24, r24
    341e:	11 f4       	brne	.+4      	; 0x3424 <Task4+0xc2>
    3420:	81 e0       	ldi	r24, 0x01	; 1
    3422:	8b 83       	std	Y+3, r24	; 0x03
    3424:	8b 81       	ldd	r24, Y+3	; 0x03
    3426:	80 93 23 06 	sts	0x0623, r24
					DIO_voidSetPinValue(PORT_u8C,PIN_6,LedThreeState?PIN_HIGH:PIN_LOW);
    342a:	80 91 23 06 	lds	r24, 0x0623
    342e:	88 87       	std	Y+8, r24	; 0x08
    3430:	88 85       	ldd	r24, Y+8	; 0x08
    3432:	88 23       	and	r24, r24
    3434:	11 f0       	breq	.+4      	; 0x343a <Task4+0xd8>
    3436:	81 e0       	ldi	r24, 0x01	; 1
    3438:	88 87       	std	Y+8, r24	; 0x08
    343a:	98 85       	ldd	r25, Y+8	; 0x08
    343c:	83 e0       	ldi	r24, 0x03	; 3
    343e:	66 e0       	ldi	r22, 0x06	; 6
    3440:	49 2f       	mov	r20, r25
    3442:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
//				DIO_voidSetPinValue(PORT_u8A , PIN_5 , PIN_LOW);
//
//			}
//
//		   xSemaphoreGive(LEDS_sm);
		   vTaskDelay(1);
    3446:	81 e0       	ldi	r24, 0x01	; 1
    3448:	90 e0       	ldi	r25, 0x00	; 0
    344a:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <vTaskDelay>
    344e:	95 cf       	rjmp	.-214    	; 0x337a <Task4+0x18>

00003450 <main>:




int main(void)
{
    3450:	af 92       	push	r10
    3452:	bf 92       	push	r11
    3454:	cf 92       	push	r12
    3456:	df 92       	push	r13
    3458:	ef 92       	push	r14
    345a:	ff 92       	push	r15
    345c:	0f 93       	push	r16
    345e:	df 93       	push	r29
    3460:	cf 93       	push	r28
    3462:	cd b7       	in	r28, 0x3d	; 61
    3464:	de b7       	in	r29, 0x3e	; 62




	// Set pin directions for UART and output pins
	DIO_voidSetPinDirection(PORT_u8D, PIN_0, PIN_IN); // RX
    3466:	84 e0       	ldi	r24, 0x04	; 4
    3468:	60 e0       	ldi	r22, 0x00	; 0
    346a:	40 e0       	ldi	r20, 0x00	; 0
    346c:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PORT_u8D, PIN_1, PIN_IN); // TX
    3470:	84 e0       	ldi	r24, 0x04	; 4
    3472:	61 e0       	ldi	r22, 0x01	; 1
    3474:	40 e0       	ldi	r20, 0x00	; 0
    3476:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <DIO_voidSetPinDirection>
	DIO_voidSetPortDirection(PORT_u8D, PORT_IN);
    347a:	84 e0       	ldi	r24, 0x04	; 4
    347c:	60 e0       	ldi	r22, 0x00	; 0
    347e:	0e 94 60 09 	call	0x12c0	; 0x12c0 <DIO_voidSetPortDirection>
	DIO_voidSetPortDirection(PORT_u8A, PORT_OUT);
    3482:	81 e0       	ldi	r24, 0x01	; 1
    3484:	6f ef       	ldi	r22, 0xFF	; 255
    3486:	0e 94 60 09 	call	0x12c0	; 0x12c0 <DIO_voidSetPortDirection>
	DIO_voidSetPortDirection(PORT_u8C, PORT_OUT);
    348a:	83 e0       	ldi	r24, 0x03	; 3
    348c:	6f ef       	ldi	r22, 0xFF	; 255
    348e:	0e 94 60 09 	call	0x12c0	; 0x12c0 <DIO_voidSetPortDirection>
	DIO_voidSetPortDirection(PORT_u8B, PORT_OUT);
    3492:	82 e0       	ldi	r24, 0x02	; 2
    3494:	6f ef       	ldi	r22, 0xFF	; 255
    3496:	0e 94 60 09 	call	0x12c0	; 0x12c0 <DIO_voidSetPortDirection>
	DIO_voidSetPinValue(PORT_u8D,PIN_2,PIN_HIGH);
    349a:	84 e0       	ldi	r24, 0x04	; 4
    349c:	62 e0       	ldi	r22, 0x02	; 2
    349e:	41 e0       	ldi	r20, 0x01	; 1
    34a0:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PORT_u8D,PIN_4,PIN_HIGH);
    34a4:	84 e0       	ldi	r24, 0x04	; 4
    34a6:	64 e0       	ldi	r22, 0x04	; 4
    34a8:	41 e0       	ldi	r20, 0x01	; 1
    34aa:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
//	DIO_voidSetPinValue(PORT_u8D,PIN_4,PIN_HIGH);
//	DIO_voidSetPinValue(PORT_u8D,PIN_5,PIN_HIGH);
	DIO_voidSetPinValue(PORT_u8D,PIN_6,PIN_HIGH);
    34ae:	84 e0       	ldi	r24, 0x04	; 4
    34b0:	66 e0       	ldi	r22, 0x06	; 6
    34b2:	41 e0       	ldi	r20, 0x01	; 1
    34b4:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PORT_u8D,PIN_7,PIN_HIGH);
    34b8:	84 e0       	ldi	r24, 0x04	; 4
    34ba:	67 e0       	ldi	r22, 0x07	; 7
    34bc:	41 e0       	ldi	r20, 0x01	; 1
    34be:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <DIO_voidSetPinValue>

DIO_voidSetPinDirection(PORT_u8D,PIN_5,PIN_OUT);
    34c2:	84 e0       	ldi	r24, 0x04	; 4
    34c4:	65 e0       	ldi	r22, 0x05	; 5
    34c6:	41 e0       	ldi	r20, 0x01	; 1
    34c8:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <DIO_voidSetPinDirection>
DIO_voidSetPinDirection(PORT_u8D,PIN_3,PIN_OUT);
    34cc:	84 e0       	ldi	r24, 0x04	; 4
    34ce:	63 e0       	ldi	r22, 0x03	; 3
    34d0:	41 e0       	ldi	r20, 0x01	; 1
    34d2:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <DIO_voidSetPinDirection>


	// Set port A as output
	UART_voidInit();
    34d6:	0e 94 65 11 	call	0x22ca	; 0x22ca <UART_voidInit>
	CLCD_voidInit();
    34da:	0e 94 df 06 	call	0xdbe	; 0xdbe <CLCD_voidInit>
	TWI_voidMasterInit(1);
    34de:	81 e0       	ldi	r24, 0x01	; 1
    34e0:	0e 94 6f 10 	call	0x20de	; 0x20de <TWI_voidMasterInit>

	// Create tasks with adjusted priorities
	vSemaphoreCreateBinary(LEDS_sm);
    34e4:	81 e0       	ldi	r24, 0x01	; 1
    34e6:	60 e0       	ldi	r22, 0x00	; 0
    34e8:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <xQueueCreate>
    34ec:	90 93 95 06 	sts	0x0695, r25
    34f0:	80 93 94 06 	sts	0x0694, r24
    34f4:	80 91 94 06 	lds	r24, 0x0694
    34f8:	90 91 95 06 	lds	r25, 0x0695
    34fc:	00 97       	sbiw	r24, 0x00	; 0
    34fe:	59 f0       	breq	.+22     	; 0x3516 <main+0xc6>
    3500:	80 91 94 06 	lds	r24, 0x0694
    3504:	90 91 95 06 	lds	r25, 0x0695
    3508:	60 e0       	ldi	r22, 0x00	; 0
    350a:	70 e0       	ldi	r23, 0x00	; 0
    350c:	40 e0       	ldi	r20, 0x00	; 0
    350e:	50 e0       	ldi	r21, 0x00	; 0
    3510:	20 e0       	ldi	r18, 0x00	; 0
    3512:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <xQueueGenericSend>

	xTaskCreate(&Task1, NULL ,configMINIMAL_STACK_SIZE, NULL, 1, NULL);
    3516:	80 e4       	ldi	r24, 0x40	; 64
    3518:	96 e1       	ldi	r25, 0x16	; 22
    351a:	60 e0       	ldi	r22, 0x00	; 0
    351c:	70 e0       	ldi	r23, 0x00	; 0
    351e:	46 e9       	ldi	r20, 0x96	; 150
    3520:	50 e0       	ldi	r21, 0x00	; 0
    3522:	20 e0       	ldi	r18, 0x00	; 0
    3524:	30 e0       	ldi	r19, 0x00	; 0
    3526:	01 e0       	ldi	r16, 0x01	; 1
    3528:	ee 24       	eor	r14, r14
    352a:	ff 24       	eor	r15, r15
    352c:	cc 24       	eor	r12, r12
    352e:	dd 24       	eor	r13, r13
    3530:	aa 24       	eor	r10, r10
    3532:	bb 24       	eor	r11, r11
    3534:	0e 94 25 22 	call	0x444a	; 0x444a <xTaskGenericCreate>
	xTaskCreate(&Task2, NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL);
    3538:	8b e6       	ldi	r24, 0x6B	; 107
    353a:	96 e1       	ldi	r25, 0x16	; 22
    353c:	60 e0       	ldi	r22, 0x00	; 0
    353e:	70 e0       	ldi	r23, 0x00	; 0
    3540:	46 e9       	ldi	r20, 0x96	; 150
    3542:	50 e0       	ldi	r21, 0x00	; 0
    3544:	20 e0       	ldi	r18, 0x00	; 0
    3546:	30 e0       	ldi	r19, 0x00	; 0
    3548:	02 e0       	ldi	r16, 0x02	; 2
    354a:	ee 24       	eor	r14, r14
    354c:	ff 24       	eor	r15, r15
    354e:	cc 24       	eor	r12, r12
    3550:	dd 24       	eor	r13, r13
    3552:	aa 24       	eor	r10, r10
    3554:	bb 24       	eor	r11, r11
    3556:	0e 94 25 22 	call	0x444a	; 0x444a <xTaskGenericCreate>
	xTaskCreate(&Task3, NULL, configMINIMAL_STACK_SIZE, NULL, 4, NULL);
    355a:	86 e2       	ldi	r24, 0x26	; 38
    355c:	98 e1       	ldi	r25, 0x18	; 24
    355e:	60 e0       	ldi	r22, 0x00	; 0
    3560:	70 e0       	ldi	r23, 0x00	; 0
    3562:	46 e9       	ldi	r20, 0x96	; 150
    3564:	50 e0       	ldi	r21, 0x00	; 0
    3566:	20 e0       	ldi	r18, 0x00	; 0
    3568:	30 e0       	ldi	r19, 0x00	; 0
    356a:	04 e0       	ldi	r16, 0x04	; 4
    356c:	ee 24       	eor	r14, r14
    356e:	ff 24       	eor	r15, r15
    3570:	cc 24       	eor	r12, r12
    3572:	dd 24       	eor	r13, r13
    3574:	aa 24       	eor	r10, r10
    3576:	bb 24       	eor	r11, r11
    3578:	0e 94 25 22 	call	0x444a	; 0x444a <xTaskGenericCreate>
	xTaskCreate(&Task4, NULL, configMINIMAL_STACK_SIZE, NULL, 3, NULL);
    357c:	81 eb       	ldi	r24, 0xB1	; 177
    357e:	99 e1       	ldi	r25, 0x19	; 25
    3580:	60 e0       	ldi	r22, 0x00	; 0
    3582:	70 e0       	ldi	r23, 0x00	; 0
    3584:	46 e9       	ldi	r20, 0x96	; 150
    3586:	50 e0       	ldi	r21, 0x00	; 0
    3588:	20 e0       	ldi	r18, 0x00	; 0
    358a:	30 e0       	ldi	r19, 0x00	; 0
    358c:	03 e0       	ldi	r16, 0x03	; 3
    358e:	ee 24       	eor	r14, r14
    3590:	ff 24       	eor	r15, r15
    3592:	cc 24       	eor	r12, r12
    3594:	dd 24       	eor	r13, r13
    3596:	aa 24       	eor	r10, r10
    3598:	bb 24       	eor	r11, r11
    359a:	0e 94 25 22 	call	0x444a	; 0x444a <xTaskGenericCreate>


	// Start the scheduler
	vTaskStartScheduler();
    359e:	0e 94 1e 24 	call	0x483c	; 0x483c <vTaskStartScheduler>
    35a2:	ff cf       	rjmp	.-2      	; 0x35a2 <main+0x152>

000035a4 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    35a4:	df 93       	push	r29
    35a6:	cf 93       	push	r28
    35a8:	cd b7       	in	r28, 0x3d	; 61
    35aa:	de b7       	in	r29, 0x3e	; 62
    35ac:	28 97       	sbiw	r28, 0x08	; 8
    35ae:	0f b6       	in	r0, 0x3f	; 63
    35b0:	f8 94       	cli
    35b2:	de bf       	out	0x3e, r29	; 62
    35b4:	0f be       	out	0x3f, r0	; 63
    35b6:	cd bf       	out	0x3d, r28	; 61
    35b8:	9c 83       	std	Y+4, r25	; 0x04
    35ba:	8b 83       	std	Y+3, r24	; 0x03
    35bc:	7e 83       	std	Y+6, r23	; 0x06
    35be:	6d 83       	std	Y+5, r22	; 0x05
    35c0:	58 87       	std	Y+8, r21	; 0x08
    35c2:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    35c4:	eb 81       	ldd	r30, Y+3	; 0x03
    35c6:	fc 81       	ldd	r31, Y+4	; 0x04
    35c8:	81 e1       	ldi	r24, 0x11	; 17
    35ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    35cc:	8b 81       	ldd	r24, Y+3	; 0x03
    35ce:	9c 81       	ldd	r25, Y+4	; 0x04
    35d0:	01 97       	sbiw	r24, 0x01	; 1
    35d2:	9c 83       	std	Y+4, r25	; 0x04
    35d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    35d6:	eb 81       	ldd	r30, Y+3	; 0x03
    35d8:	fc 81       	ldd	r31, Y+4	; 0x04
    35da:	82 e2       	ldi	r24, 0x22	; 34
    35dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    35de:	8b 81       	ldd	r24, Y+3	; 0x03
    35e0:	9c 81       	ldd	r25, Y+4	; 0x04
    35e2:	01 97       	sbiw	r24, 0x01	; 1
    35e4:	9c 83       	std	Y+4, r25	; 0x04
    35e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    35e8:	eb 81       	ldd	r30, Y+3	; 0x03
    35ea:	fc 81       	ldd	r31, Y+4	; 0x04
    35ec:	83 e3       	ldi	r24, 0x33	; 51
    35ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    35f0:	8b 81       	ldd	r24, Y+3	; 0x03
    35f2:	9c 81       	ldd	r25, Y+4	; 0x04
    35f4:	01 97       	sbiw	r24, 0x01	; 1
    35f6:	9c 83       	std	Y+4, r25	; 0x04
    35f8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    35fa:	8d 81       	ldd	r24, Y+5	; 0x05
    35fc:	9e 81       	ldd	r25, Y+6	; 0x06
    35fe:	9a 83       	std	Y+2, r25	; 0x02
    3600:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3602:	89 81       	ldd	r24, Y+1	; 0x01
    3604:	eb 81       	ldd	r30, Y+3	; 0x03
    3606:	fc 81       	ldd	r31, Y+4	; 0x04
    3608:	80 83       	st	Z, r24
	pxTopOfStack--;
    360a:	8b 81       	ldd	r24, Y+3	; 0x03
    360c:	9c 81       	ldd	r25, Y+4	; 0x04
    360e:	01 97       	sbiw	r24, 0x01	; 1
    3610:	9c 83       	std	Y+4, r25	; 0x04
    3612:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3614:	89 81       	ldd	r24, Y+1	; 0x01
    3616:	9a 81       	ldd	r25, Y+2	; 0x02
    3618:	89 2f       	mov	r24, r25
    361a:	99 27       	eor	r25, r25
    361c:	9a 83       	std	Y+2, r25	; 0x02
    361e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3620:	89 81       	ldd	r24, Y+1	; 0x01
    3622:	eb 81       	ldd	r30, Y+3	; 0x03
    3624:	fc 81       	ldd	r31, Y+4	; 0x04
    3626:	80 83       	st	Z, r24
	pxTopOfStack--;
    3628:	8b 81       	ldd	r24, Y+3	; 0x03
    362a:	9c 81       	ldd	r25, Y+4	; 0x04
    362c:	01 97       	sbiw	r24, 0x01	; 1
    362e:	9c 83       	std	Y+4, r25	; 0x04
    3630:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    3632:	eb 81       	ldd	r30, Y+3	; 0x03
    3634:	fc 81       	ldd	r31, Y+4	; 0x04
    3636:	10 82       	st	Z, r1
	pxTopOfStack--;
    3638:	8b 81       	ldd	r24, Y+3	; 0x03
    363a:	9c 81       	ldd	r25, Y+4	; 0x04
    363c:	01 97       	sbiw	r24, 0x01	; 1
    363e:	9c 83       	std	Y+4, r25	; 0x04
    3640:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3642:	eb 81       	ldd	r30, Y+3	; 0x03
    3644:	fc 81       	ldd	r31, Y+4	; 0x04
    3646:	80 e8       	ldi	r24, 0x80	; 128
    3648:	80 83       	st	Z, r24
	pxTopOfStack--;
    364a:	8b 81       	ldd	r24, Y+3	; 0x03
    364c:	9c 81       	ldd	r25, Y+4	; 0x04
    364e:	01 97       	sbiw	r24, 0x01	; 1
    3650:	9c 83       	std	Y+4, r25	; 0x04
    3652:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3654:	eb 81       	ldd	r30, Y+3	; 0x03
    3656:	fc 81       	ldd	r31, Y+4	; 0x04
    3658:	10 82       	st	Z, r1
	pxTopOfStack--;
    365a:	8b 81       	ldd	r24, Y+3	; 0x03
    365c:	9c 81       	ldd	r25, Y+4	; 0x04
    365e:	01 97       	sbiw	r24, 0x01	; 1
    3660:	9c 83       	std	Y+4, r25	; 0x04
    3662:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3664:	eb 81       	ldd	r30, Y+3	; 0x03
    3666:	fc 81       	ldd	r31, Y+4	; 0x04
    3668:	82 e0       	ldi	r24, 0x02	; 2
    366a:	80 83       	st	Z, r24
	pxTopOfStack--;
    366c:	8b 81       	ldd	r24, Y+3	; 0x03
    366e:	9c 81       	ldd	r25, Y+4	; 0x04
    3670:	01 97       	sbiw	r24, 0x01	; 1
    3672:	9c 83       	std	Y+4, r25	; 0x04
    3674:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3676:	eb 81       	ldd	r30, Y+3	; 0x03
    3678:	fc 81       	ldd	r31, Y+4	; 0x04
    367a:	83 e0       	ldi	r24, 0x03	; 3
    367c:	80 83       	st	Z, r24
	pxTopOfStack--;
    367e:	8b 81       	ldd	r24, Y+3	; 0x03
    3680:	9c 81       	ldd	r25, Y+4	; 0x04
    3682:	01 97       	sbiw	r24, 0x01	; 1
    3684:	9c 83       	std	Y+4, r25	; 0x04
    3686:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    3688:	eb 81       	ldd	r30, Y+3	; 0x03
    368a:	fc 81       	ldd	r31, Y+4	; 0x04
    368c:	84 e0       	ldi	r24, 0x04	; 4
    368e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3690:	8b 81       	ldd	r24, Y+3	; 0x03
    3692:	9c 81       	ldd	r25, Y+4	; 0x04
    3694:	01 97       	sbiw	r24, 0x01	; 1
    3696:	9c 83       	std	Y+4, r25	; 0x04
    3698:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    369a:	eb 81       	ldd	r30, Y+3	; 0x03
    369c:	fc 81       	ldd	r31, Y+4	; 0x04
    369e:	85 e0       	ldi	r24, 0x05	; 5
    36a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    36a2:	8b 81       	ldd	r24, Y+3	; 0x03
    36a4:	9c 81       	ldd	r25, Y+4	; 0x04
    36a6:	01 97       	sbiw	r24, 0x01	; 1
    36a8:	9c 83       	std	Y+4, r25	; 0x04
    36aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    36ac:	eb 81       	ldd	r30, Y+3	; 0x03
    36ae:	fc 81       	ldd	r31, Y+4	; 0x04
    36b0:	86 e0       	ldi	r24, 0x06	; 6
    36b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    36b4:	8b 81       	ldd	r24, Y+3	; 0x03
    36b6:	9c 81       	ldd	r25, Y+4	; 0x04
    36b8:	01 97       	sbiw	r24, 0x01	; 1
    36ba:	9c 83       	std	Y+4, r25	; 0x04
    36bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    36be:	eb 81       	ldd	r30, Y+3	; 0x03
    36c0:	fc 81       	ldd	r31, Y+4	; 0x04
    36c2:	87 e0       	ldi	r24, 0x07	; 7
    36c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    36c6:	8b 81       	ldd	r24, Y+3	; 0x03
    36c8:	9c 81       	ldd	r25, Y+4	; 0x04
    36ca:	01 97       	sbiw	r24, 0x01	; 1
    36cc:	9c 83       	std	Y+4, r25	; 0x04
    36ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    36d0:	eb 81       	ldd	r30, Y+3	; 0x03
    36d2:	fc 81       	ldd	r31, Y+4	; 0x04
    36d4:	88 e0       	ldi	r24, 0x08	; 8
    36d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    36d8:	8b 81       	ldd	r24, Y+3	; 0x03
    36da:	9c 81       	ldd	r25, Y+4	; 0x04
    36dc:	01 97       	sbiw	r24, 0x01	; 1
    36de:	9c 83       	std	Y+4, r25	; 0x04
    36e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    36e2:	eb 81       	ldd	r30, Y+3	; 0x03
    36e4:	fc 81       	ldd	r31, Y+4	; 0x04
    36e6:	89 e0       	ldi	r24, 0x09	; 9
    36e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    36ea:	8b 81       	ldd	r24, Y+3	; 0x03
    36ec:	9c 81       	ldd	r25, Y+4	; 0x04
    36ee:	01 97       	sbiw	r24, 0x01	; 1
    36f0:	9c 83       	std	Y+4, r25	; 0x04
    36f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    36f4:	eb 81       	ldd	r30, Y+3	; 0x03
    36f6:	fc 81       	ldd	r31, Y+4	; 0x04
    36f8:	80 e1       	ldi	r24, 0x10	; 16
    36fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    36fc:	8b 81       	ldd	r24, Y+3	; 0x03
    36fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3700:	01 97       	sbiw	r24, 0x01	; 1
    3702:	9c 83       	std	Y+4, r25	; 0x04
    3704:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    3706:	eb 81       	ldd	r30, Y+3	; 0x03
    3708:	fc 81       	ldd	r31, Y+4	; 0x04
    370a:	81 e1       	ldi	r24, 0x11	; 17
    370c:	80 83       	st	Z, r24
	pxTopOfStack--;
    370e:	8b 81       	ldd	r24, Y+3	; 0x03
    3710:	9c 81       	ldd	r25, Y+4	; 0x04
    3712:	01 97       	sbiw	r24, 0x01	; 1
    3714:	9c 83       	std	Y+4, r25	; 0x04
    3716:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    3718:	eb 81       	ldd	r30, Y+3	; 0x03
    371a:	fc 81       	ldd	r31, Y+4	; 0x04
    371c:	82 e1       	ldi	r24, 0x12	; 18
    371e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3720:	8b 81       	ldd	r24, Y+3	; 0x03
    3722:	9c 81       	ldd	r25, Y+4	; 0x04
    3724:	01 97       	sbiw	r24, 0x01	; 1
    3726:	9c 83       	std	Y+4, r25	; 0x04
    3728:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    372a:	eb 81       	ldd	r30, Y+3	; 0x03
    372c:	fc 81       	ldd	r31, Y+4	; 0x04
    372e:	83 e1       	ldi	r24, 0x13	; 19
    3730:	80 83       	st	Z, r24
	pxTopOfStack--;
    3732:	8b 81       	ldd	r24, Y+3	; 0x03
    3734:	9c 81       	ldd	r25, Y+4	; 0x04
    3736:	01 97       	sbiw	r24, 0x01	; 1
    3738:	9c 83       	std	Y+4, r25	; 0x04
    373a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    373c:	eb 81       	ldd	r30, Y+3	; 0x03
    373e:	fc 81       	ldd	r31, Y+4	; 0x04
    3740:	84 e1       	ldi	r24, 0x14	; 20
    3742:	80 83       	st	Z, r24
	pxTopOfStack--;
    3744:	8b 81       	ldd	r24, Y+3	; 0x03
    3746:	9c 81       	ldd	r25, Y+4	; 0x04
    3748:	01 97       	sbiw	r24, 0x01	; 1
    374a:	9c 83       	std	Y+4, r25	; 0x04
    374c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    374e:	eb 81       	ldd	r30, Y+3	; 0x03
    3750:	fc 81       	ldd	r31, Y+4	; 0x04
    3752:	85 e1       	ldi	r24, 0x15	; 21
    3754:	80 83       	st	Z, r24
	pxTopOfStack--;
    3756:	8b 81       	ldd	r24, Y+3	; 0x03
    3758:	9c 81       	ldd	r25, Y+4	; 0x04
    375a:	01 97       	sbiw	r24, 0x01	; 1
    375c:	9c 83       	std	Y+4, r25	; 0x04
    375e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    3760:	eb 81       	ldd	r30, Y+3	; 0x03
    3762:	fc 81       	ldd	r31, Y+4	; 0x04
    3764:	86 e1       	ldi	r24, 0x16	; 22
    3766:	80 83       	st	Z, r24
	pxTopOfStack--;
    3768:	8b 81       	ldd	r24, Y+3	; 0x03
    376a:	9c 81       	ldd	r25, Y+4	; 0x04
    376c:	01 97       	sbiw	r24, 0x01	; 1
    376e:	9c 83       	std	Y+4, r25	; 0x04
    3770:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    3772:	eb 81       	ldd	r30, Y+3	; 0x03
    3774:	fc 81       	ldd	r31, Y+4	; 0x04
    3776:	87 e1       	ldi	r24, 0x17	; 23
    3778:	80 83       	st	Z, r24
	pxTopOfStack--;
    377a:	8b 81       	ldd	r24, Y+3	; 0x03
    377c:	9c 81       	ldd	r25, Y+4	; 0x04
    377e:	01 97       	sbiw	r24, 0x01	; 1
    3780:	9c 83       	std	Y+4, r25	; 0x04
    3782:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3784:	eb 81       	ldd	r30, Y+3	; 0x03
    3786:	fc 81       	ldd	r31, Y+4	; 0x04
    3788:	88 e1       	ldi	r24, 0x18	; 24
    378a:	80 83       	st	Z, r24
	pxTopOfStack--;
    378c:	8b 81       	ldd	r24, Y+3	; 0x03
    378e:	9c 81       	ldd	r25, Y+4	; 0x04
    3790:	01 97       	sbiw	r24, 0x01	; 1
    3792:	9c 83       	std	Y+4, r25	; 0x04
    3794:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3796:	eb 81       	ldd	r30, Y+3	; 0x03
    3798:	fc 81       	ldd	r31, Y+4	; 0x04
    379a:	89 e1       	ldi	r24, 0x19	; 25
    379c:	80 83       	st	Z, r24
	pxTopOfStack--;
    379e:	8b 81       	ldd	r24, Y+3	; 0x03
    37a0:	9c 81       	ldd	r25, Y+4	; 0x04
    37a2:	01 97       	sbiw	r24, 0x01	; 1
    37a4:	9c 83       	std	Y+4, r25	; 0x04
    37a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    37a8:	eb 81       	ldd	r30, Y+3	; 0x03
    37aa:	fc 81       	ldd	r31, Y+4	; 0x04
    37ac:	80 e2       	ldi	r24, 0x20	; 32
    37ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    37b0:	8b 81       	ldd	r24, Y+3	; 0x03
    37b2:	9c 81       	ldd	r25, Y+4	; 0x04
    37b4:	01 97       	sbiw	r24, 0x01	; 1
    37b6:	9c 83       	std	Y+4, r25	; 0x04
    37b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    37ba:	eb 81       	ldd	r30, Y+3	; 0x03
    37bc:	fc 81       	ldd	r31, Y+4	; 0x04
    37be:	81 e2       	ldi	r24, 0x21	; 33
    37c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    37c2:	8b 81       	ldd	r24, Y+3	; 0x03
    37c4:	9c 81       	ldd	r25, Y+4	; 0x04
    37c6:	01 97       	sbiw	r24, 0x01	; 1
    37c8:	9c 83       	std	Y+4, r25	; 0x04
    37ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    37cc:	eb 81       	ldd	r30, Y+3	; 0x03
    37ce:	fc 81       	ldd	r31, Y+4	; 0x04
    37d0:	82 e2       	ldi	r24, 0x22	; 34
    37d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    37d4:	8b 81       	ldd	r24, Y+3	; 0x03
    37d6:	9c 81       	ldd	r25, Y+4	; 0x04
    37d8:	01 97       	sbiw	r24, 0x01	; 1
    37da:	9c 83       	std	Y+4, r25	; 0x04
    37dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    37de:	eb 81       	ldd	r30, Y+3	; 0x03
    37e0:	fc 81       	ldd	r31, Y+4	; 0x04
    37e2:	83 e2       	ldi	r24, 0x23	; 35
    37e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    37e6:	8b 81       	ldd	r24, Y+3	; 0x03
    37e8:	9c 81       	ldd	r25, Y+4	; 0x04
    37ea:	01 97       	sbiw	r24, 0x01	; 1
    37ec:	9c 83       	std	Y+4, r25	; 0x04
    37ee:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    37f0:	8f 81       	ldd	r24, Y+7	; 0x07
    37f2:	98 85       	ldd	r25, Y+8	; 0x08
    37f4:	9a 83       	std	Y+2, r25	; 0x02
    37f6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    37f8:	89 81       	ldd	r24, Y+1	; 0x01
    37fa:	eb 81       	ldd	r30, Y+3	; 0x03
    37fc:	fc 81       	ldd	r31, Y+4	; 0x04
    37fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    3800:	8b 81       	ldd	r24, Y+3	; 0x03
    3802:	9c 81       	ldd	r25, Y+4	; 0x04
    3804:	01 97       	sbiw	r24, 0x01	; 1
    3806:	9c 83       	std	Y+4, r25	; 0x04
    3808:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    380a:	89 81       	ldd	r24, Y+1	; 0x01
    380c:	9a 81       	ldd	r25, Y+2	; 0x02
    380e:	89 2f       	mov	r24, r25
    3810:	99 27       	eor	r25, r25
    3812:	9a 83       	std	Y+2, r25	; 0x02
    3814:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3816:	89 81       	ldd	r24, Y+1	; 0x01
    3818:	eb 81       	ldd	r30, Y+3	; 0x03
    381a:	fc 81       	ldd	r31, Y+4	; 0x04
    381c:	80 83       	st	Z, r24
	pxTopOfStack--;
    381e:	8b 81       	ldd	r24, Y+3	; 0x03
    3820:	9c 81       	ldd	r25, Y+4	; 0x04
    3822:	01 97       	sbiw	r24, 0x01	; 1
    3824:	9c 83       	std	Y+4, r25	; 0x04
    3826:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    3828:	eb 81       	ldd	r30, Y+3	; 0x03
    382a:	fc 81       	ldd	r31, Y+4	; 0x04
    382c:	86 e2       	ldi	r24, 0x26	; 38
    382e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3830:	8b 81       	ldd	r24, Y+3	; 0x03
    3832:	9c 81       	ldd	r25, Y+4	; 0x04
    3834:	01 97       	sbiw	r24, 0x01	; 1
    3836:	9c 83       	std	Y+4, r25	; 0x04
    3838:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    383a:	eb 81       	ldd	r30, Y+3	; 0x03
    383c:	fc 81       	ldd	r31, Y+4	; 0x04
    383e:	87 e2       	ldi	r24, 0x27	; 39
    3840:	80 83       	st	Z, r24
	pxTopOfStack--;
    3842:	8b 81       	ldd	r24, Y+3	; 0x03
    3844:	9c 81       	ldd	r25, Y+4	; 0x04
    3846:	01 97       	sbiw	r24, 0x01	; 1
    3848:	9c 83       	std	Y+4, r25	; 0x04
    384a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    384c:	eb 81       	ldd	r30, Y+3	; 0x03
    384e:	fc 81       	ldd	r31, Y+4	; 0x04
    3850:	88 e2       	ldi	r24, 0x28	; 40
    3852:	80 83       	st	Z, r24
	pxTopOfStack--;
    3854:	8b 81       	ldd	r24, Y+3	; 0x03
    3856:	9c 81       	ldd	r25, Y+4	; 0x04
    3858:	01 97       	sbiw	r24, 0x01	; 1
    385a:	9c 83       	std	Y+4, r25	; 0x04
    385c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    385e:	eb 81       	ldd	r30, Y+3	; 0x03
    3860:	fc 81       	ldd	r31, Y+4	; 0x04
    3862:	89 e2       	ldi	r24, 0x29	; 41
    3864:	80 83       	st	Z, r24
	pxTopOfStack--;
    3866:	8b 81       	ldd	r24, Y+3	; 0x03
    3868:	9c 81       	ldd	r25, Y+4	; 0x04
    386a:	01 97       	sbiw	r24, 0x01	; 1
    386c:	9c 83       	std	Y+4, r25	; 0x04
    386e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    3870:	eb 81       	ldd	r30, Y+3	; 0x03
    3872:	fc 81       	ldd	r31, Y+4	; 0x04
    3874:	80 e3       	ldi	r24, 0x30	; 48
    3876:	80 83       	st	Z, r24
	pxTopOfStack--;
    3878:	8b 81       	ldd	r24, Y+3	; 0x03
    387a:	9c 81       	ldd	r25, Y+4	; 0x04
    387c:	01 97       	sbiw	r24, 0x01	; 1
    387e:	9c 83       	std	Y+4, r25	; 0x04
    3880:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3882:	eb 81       	ldd	r30, Y+3	; 0x03
    3884:	fc 81       	ldd	r31, Y+4	; 0x04
    3886:	81 e3       	ldi	r24, 0x31	; 49
    3888:	80 83       	st	Z, r24
	pxTopOfStack--;
    388a:	8b 81       	ldd	r24, Y+3	; 0x03
    388c:	9c 81       	ldd	r25, Y+4	; 0x04
    388e:	01 97       	sbiw	r24, 0x01	; 1
    3890:	9c 83       	std	Y+4, r25	; 0x04
    3892:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3894:	8b 81       	ldd	r24, Y+3	; 0x03
    3896:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3898:	28 96       	adiw	r28, 0x08	; 8
    389a:	0f b6       	in	r0, 0x3f	; 63
    389c:	f8 94       	cli
    389e:	de bf       	out	0x3e, r29	; 62
    38a0:	0f be       	out	0x3f, r0	; 63
    38a2:	cd bf       	out	0x3d, r28	; 61
    38a4:	cf 91       	pop	r28
    38a6:	df 91       	pop	r29
    38a8:	08 95       	ret

000038aa <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    38aa:	df 93       	push	r29
    38ac:	cf 93       	push	r28
    38ae:	cd b7       	in	r28, 0x3d	; 61
    38b0:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    38b2:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    38b6:	a0 91 26 06 	lds	r26, 0x0626
    38ba:	b0 91 27 06 	lds	r27, 0x0627
    38be:	cd 91       	ld	r28, X+
    38c0:	cd bf       	out	0x3d, r28	; 61
    38c2:	dd 91       	ld	r29, X+
    38c4:	de bf       	out	0x3e, r29	; 62
    38c6:	ff 91       	pop	r31
    38c8:	ef 91       	pop	r30
    38ca:	df 91       	pop	r29
    38cc:	cf 91       	pop	r28
    38ce:	bf 91       	pop	r27
    38d0:	af 91       	pop	r26
    38d2:	9f 91       	pop	r25
    38d4:	8f 91       	pop	r24
    38d6:	7f 91       	pop	r23
    38d8:	6f 91       	pop	r22
    38da:	5f 91       	pop	r21
    38dc:	4f 91       	pop	r20
    38de:	3f 91       	pop	r19
    38e0:	2f 91       	pop	r18
    38e2:	1f 91       	pop	r17
    38e4:	0f 91       	pop	r16
    38e6:	ff 90       	pop	r15
    38e8:	ef 90       	pop	r14
    38ea:	df 90       	pop	r13
    38ec:	cf 90       	pop	r12
    38ee:	bf 90       	pop	r11
    38f0:	af 90       	pop	r10
    38f2:	9f 90       	pop	r9
    38f4:	8f 90       	pop	r8
    38f6:	7f 90       	pop	r7
    38f8:	6f 90       	pop	r6
    38fa:	5f 90       	pop	r5
    38fc:	4f 90       	pop	r4
    38fe:	3f 90       	pop	r3
    3900:	2f 90       	pop	r2
    3902:	1f 90       	pop	r1
    3904:	0f 90       	pop	r0
    3906:	0f be       	out	0x3f, r0	; 63
    3908:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    390a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    390c:	81 e0       	ldi	r24, 0x01	; 1
}
    390e:	cf 91       	pop	r28
    3910:	df 91       	pop	r29
    3912:	08 95       	ret

00003914 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3914:	df 93       	push	r29
    3916:	cf 93       	push	r28
    3918:	cd b7       	in	r28, 0x3d	; 61
    391a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    391c:	cf 91       	pop	r28
    391e:	df 91       	pop	r29
    3920:	08 95       	ret

00003922 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3922:	0f 92       	push	r0
    3924:	0f b6       	in	r0, 0x3f	; 63
    3926:	f8 94       	cli
    3928:	0f 92       	push	r0
    392a:	1f 92       	push	r1
    392c:	11 24       	eor	r1, r1
    392e:	2f 92       	push	r2
    3930:	3f 92       	push	r3
    3932:	4f 92       	push	r4
    3934:	5f 92       	push	r5
    3936:	6f 92       	push	r6
    3938:	7f 92       	push	r7
    393a:	8f 92       	push	r8
    393c:	9f 92       	push	r9
    393e:	af 92       	push	r10
    3940:	bf 92       	push	r11
    3942:	cf 92       	push	r12
    3944:	df 92       	push	r13
    3946:	ef 92       	push	r14
    3948:	ff 92       	push	r15
    394a:	0f 93       	push	r16
    394c:	1f 93       	push	r17
    394e:	2f 93       	push	r18
    3950:	3f 93       	push	r19
    3952:	4f 93       	push	r20
    3954:	5f 93       	push	r21
    3956:	6f 93       	push	r22
    3958:	7f 93       	push	r23
    395a:	8f 93       	push	r24
    395c:	9f 93       	push	r25
    395e:	af 93       	push	r26
    3960:	bf 93       	push	r27
    3962:	cf 93       	push	r28
    3964:	df 93       	push	r29
    3966:	ef 93       	push	r30
    3968:	ff 93       	push	r31
    396a:	a0 91 26 06 	lds	r26, 0x0626
    396e:	b0 91 27 06 	lds	r27, 0x0627
    3972:	0d b6       	in	r0, 0x3d	; 61
    3974:	0d 92       	st	X+, r0
    3976:	0e b6       	in	r0, 0x3e	; 62
    3978:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    397a:	0e 94 01 26 	call	0x4c02	; 0x4c02 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    397e:	a0 91 26 06 	lds	r26, 0x0626
    3982:	b0 91 27 06 	lds	r27, 0x0627
    3986:	cd 91       	ld	r28, X+
    3988:	cd bf       	out	0x3d, r28	; 61
    398a:	dd 91       	ld	r29, X+
    398c:	de bf       	out	0x3e, r29	; 62
    398e:	ff 91       	pop	r31
    3990:	ef 91       	pop	r30
    3992:	df 91       	pop	r29
    3994:	cf 91       	pop	r28
    3996:	bf 91       	pop	r27
    3998:	af 91       	pop	r26
    399a:	9f 91       	pop	r25
    399c:	8f 91       	pop	r24
    399e:	7f 91       	pop	r23
    39a0:	6f 91       	pop	r22
    39a2:	5f 91       	pop	r21
    39a4:	4f 91       	pop	r20
    39a6:	3f 91       	pop	r19
    39a8:	2f 91       	pop	r18
    39aa:	1f 91       	pop	r17
    39ac:	0f 91       	pop	r16
    39ae:	ff 90       	pop	r15
    39b0:	ef 90       	pop	r14
    39b2:	df 90       	pop	r13
    39b4:	cf 90       	pop	r12
    39b6:	bf 90       	pop	r11
    39b8:	af 90       	pop	r10
    39ba:	9f 90       	pop	r9
    39bc:	8f 90       	pop	r8
    39be:	7f 90       	pop	r7
    39c0:	6f 90       	pop	r6
    39c2:	5f 90       	pop	r5
    39c4:	4f 90       	pop	r4
    39c6:	3f 90       	pop	r3
    39c8:	2f 90       	pop	r2
    39ca:	1f 90       	pop	r1
    39cc:	0f 90       	pop	r0
    39ce:	0f be       	out	0x3f, r0	; 63
    39d0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    39d2:	08 95       	ret

000039d4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    39d4:	0f 92       	push	r0
    39d6:	0f b6       	in	r0, 0x3f	; 63
    39d8:	f8 94       	cli
    39da:	0f 92       	push	r0
    39dc:	1f 92       	push	r1
    39de:	11 24       	eor	r1, r1
    39e0:	2f 92       	push	r2
    39e2:	3f 92       	push	r3
    39e4:	4f 92       	push	r4
    39e6:	5f 92       	push	r5
    39e8:	6f 92       	push	r6
    39ea:	7f 92       	push	r7
    39ec:	8f 92       	push	r8
    39ee:	9f 92       	push	r9
    39f0:	af 92       	push	r10
    39f2:	bf 92       	push	r11
    39f4:	cf 92       	push	r12
    39f6:	df 92       	push	r13
    39f8:	ef 92       	push	r14
    39fa:	ff 92       	push	r15
    39fc:	0f 93       	push	r16
    39fe:	1f 93       	push	r17
    3a00:	2f 93       	push	r18
    3a02:	3f 93       	push	r19
    3a04:	4f 93       	push	r20
    3a06:	5f 93       	push	r21
    3a08:	6f 93       	push	r22
    3a0a:	7f 93       	push	r23
    3a0c:	8f 93       	push	r24
    3a0e:	9f 93       	push	r25
    3a10:	af 93       	push	r26
    3a12:	bf 93       	push	r27
    3a14:	cf 93       	push	r28
    3a16:	df 93       	push	r29
    3a18:	ef 93       	push	r30
    3a1a:	ff 93       	push	r31
    3a1c:	a0 91 26 06 	lds	r26, 0x0626
    3a20:	b0 91 27 06 	lds	r27, 0x0627
    3a24:	0d b6       	in	r0, 0x3d	; 61
    3a26:	0d 92       	st	X+, r0
    3a28:	0e b6       	in	r0, 0x3e	; 62
    3a2a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3a2c:	0e 94 2c 25 	call	0x4a58	; 0x4a58 <vTaskIncrementTick>
	vTaskSwitchContext();
    3a30:	0e 94 01 26 	call	0x4c02	; 0x4c02 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3a34:	a0 91 26 06 	lds	r26, 0x0626
    3a38:	b0 91 27 06 	lds	r27, 0x0627
    3a3c:	cd 91       	ld	r28, X+
    3a3e:	cd bf       	out	0x3d, r28	; 61
    3a40:	dd 91       	ld	r29, X+
    3a42:	de bf       	out	0x3e, r29	; 62
    3a44:	ff 91       	pop	r31
    3a46:	ef 91       	pop	r30
    3a48:	df 91       	pop	r29
    3a4a:	cf 91       	pop	r28
    3a4c:	bf 91       	pop	r27
    3a4e:	af 91       	pop	r26
    3a50:	9f 91       	pop	r25
    3a52:	8f 91       	pop	r24
    3a54:	7f 91       	pop	r23
    3a56:	6f 91       	pop	r22
    3a58:	5f 91       	pop	r21
    3a5a:	4f 91       	pop	r20
    3a5c:	3f 91       	pop	r19
    3a5e:	2f 91       	pop	r18
    3a60:	1f 91       	pop	r17
    3a62:	0f 91       	pop	r16
    3a64:	ff 90       	pop	r15
    3a66:	ef 90       	pop	r14
    3a68:	df 90       	pop	r13
    3a6a:	cf 90       	pop	r12
    3a6c:	bf 90       	pop	r11
    3a6e:	af 90       	pop	r10
    3a70:	9f 90       	pop	r9
    3a72:	8f 90       	pop	r8
    3a74:	7f 90       	pop	r7
    3a76:	6f 90       	pop	r6
    3a78:	5f 90       	pop	r5
    3a7a:	4f 90       	pop	r4
    3a7c:	3f 90       	pop	r3
    3a7e:	2f 90       	pop	r2
    3a80:	1f 90       	pop	r1
    3a82:	0f 90       	pop	r0
    3a84:	0f be       	out	0x3f, r0	; 63
    3a86:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3a88:	08 95       	ret

00003a8a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3a8a:	df 93       	push	r29
    3a8c:	cf 93       	push	r28
    3a8e:	00 d0       	rcall	.+0      	; 0x3a90 <prvSetupTimerInterrupt+0x6>
    3a90:	00 d0       	rcall	.+0      	; 0x3a92 <prvSetupTimerInterrupt+0x8>
    3a92:	00 d0       	rcall	.+0      	; 0x3a94 <prvSetupTimerInterrupt+0xa>
    3a94:	cd b7       	in	r28, 0x3d	; 61
    3a96:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3a98:	80 e8       	ldi	r24, 0x80	; 128
    3a9a:	9e e3       	ldi	r25, 0x3E	; 62
    3a9c:	a0 e0       	ldi	r26, 0x00	; 0
    3a9e:	b0 e0       	ldi	r27, 0x00	; 0
    3aa0:	8b 83       	std	Y+3, r24	; 0x03
    3aa2:	9c 83       	std	Y+4, r25	; 0x04
    3aa4:	ad 83       	std	Y+5, r26	; 0x05
    3aa6:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    3aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    3aac:	ad 81       	ldd	r26, Y+5	; 0x05
    3aae:	be 81       	ldd	r27, Y+6	; 0x06
    3ab0:	68 94       	set
    3ab2:	15 f8       	bld	r1, 5
    3ab4:	b6 95       	lsr	r27
    3ab6:	a7 95       	ror	r26
    3ab8:	97 95       	ror	r25
    3aba:	87 95       	ror	r24
    3abc:	16 94       	lsr	r1
    3abe:	d1 f7       	brne	.-12     	; 0x3ab4 <prvSetupTimerInterrupt+0x2a>
    3ac0:	8b 83       	std	Y+3, r24	; 0x03
    3ac2:	9c 83       	std	Y+4, r25	; 0x04
    3ac4:	ad 83       	std	Y+5, r26	; 0x05
    3ac6:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    3ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    3aca:	9c 81       	ldd	r25, Y+4	; 0x04
    3acc:	ad 81       	ldd	r26, Y+5	; 0x05
    3ace:	be 81       	ldd	r27, Y+6	; 0x06
    3ad0:	01 97       	sbiw	r24, 0x01	; 1
    3ad2:	a1 09       	sbc	r26, r1
    3ad4:	b1 09       	sbc	r27, r1
    3ad6:	8b 83       	std	Y+3, r24	; 0x03
    3ad8:	9c 83       	std	Y+4, r25	; 0x04
    3ada:	ad 83       	std	Y+5, r26	; 0x05
    3adc:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3ade:	8b 81       	ldd	r24, Y+3	; 0x03
    3ae0:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ae4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ae6:	ad 81       	ldd	r26, Y+5	; 0x05
    3ae8:	be 81       	ldd	r27, Y+6	; 0x06
    3aea:	89 2f       	mov	r24, r25
    3aec:	9a 2f       	mov	r25, r26
    3aee:	ab 2f       	mov	r26, r27
    3af0:	bb 27       	eor	r27, r27
    3af2:	8b 83       	std	Y+3, r24	; 0x03
    3af4:	9c 83       	std	Y+4, r25	; 0x04
    3af6:	ad 83       	std	Y+5, r26	; 0x05
    3af8:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3afa:	8b 81       	ldd	r24, Y+3	; 0x03
    3afc:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3afe:	eb e4       	ldi	r30, 0x4B	; 75
    3b00:	f0 e0       	ldi	r31, 0x00	; 0
    3b02:	8a 81       	ldd	r24, Y+2	; 0x02
    3b04:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3b06:	ea e4       	ldi	r30, 0x4A	; 74
    3b08:	f0 e0       	ldi	r31, 0x00	; 0
    3b0a:	89 81       	ldd	r24, Y+1	; 0x01
    3b0c:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3b0e:	8b e0       	ldi	r24, 0x0B	; 11
    3b10:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3b12:	ee e4       	ldi	r30, 0x4E	; 78
    3b14:	f0 e0       	ldi	r31, 0x00	; 0
    3b16:	89 81       	ldd	r24, Y+1	; 0x01
    3b18:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3b1a:	e9 e5       	ldi	r30, 0x59	; 89
    3b1c:	f0 e0       	ldi	r31, 0x00	; 0
    3b1e:	80 81       	ld	r24, Z
    3b20:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3b22:	89 81       	ldd	r24, Y+1	; 0x01
    3b24:	80 61       	ori	r24, 0x10	; 16
    3b26:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3b28:	e9 e5       	ldi	r30, 0x59	; 89
    3b2a:	f0 e0       	ldi	r31, 0x00	; 0
    3b2c:	89 81       	ldd	r24, Y+1	; 0x01
    3b2e:	80 83       	st	Z, r24
}
    3b30:	26 96       	adiw	r28, 0x06	; 6
    3b32:	0f b6       	in	r0, 0x3f	; 63
    3b34:	f8 94       	cli
    3b36:	de bf       	out	0x3e, r29	; 62
    3b38:	0f be       	out	0x3f, r0	; 63
    3b3a:	cd bf       	out	0x3d, r28	; 61
    3b3c:	cf 91       	pop	r28
    3b3e:	df 91       	pop	r29
    3b40:	08 95       	ret

00003b42 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    3b42:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3b46:	18 95       	reti

00003b48 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    3b48:	df 93       	push	r29
    3b4a:	cf 93       	push	r28
    3b4c:	cd b7       	in	r28, 0x3d	; 61
    3b4e:	de b7       	in	r29, 0x3e	; 62
    3b50:	28 97       	sbiw	r28, 0x08	; 8
    3b52:	0f b6       	in	r0, 0x3f	; 63
    3b54:	f8 94       	cli
    3b56:	de bf       	out	0x3e, r29	; 62
    3b58:	0f be       	out	0x3f, r0	; 63
    3b5a:	cd bf       	out	0x3d, r28	; 61
    3b5c:	8f 83       	std	Y+7, r24	; 0x07
    3b5e:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    3b60:	1a 82       	std	Y+2, r1	; 0x02
    3b62:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3b64:	8f 81       	ldd	r24, Y+7	; 0x07
    3b66:	88 23       	and	r24, r24
    3b68:	09 f4       	brne	.+2      	; 0x3b6c <xQueueCreate+0x24>
    3b6a:	8c c0       	rjmp	.+280    	; 0x3c84 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    3b6c:	8f e1       	ldi	r24, 0x1F	; 31
    3b6e:	90 e0       	ldi	r25, 0x00	; 0
    3b70:	0e 94 99 14 	call	0x2932	; 0x2932 <pvPortMalloc>
    3b74:	9e 83       	std	Y+6, r25	; 0x06
    3b76:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3b78:	8d 81       	ldd	r24, Y+5	; 0x05
    3b7a:	9e 81       	ldd	r25, Y+6	; 0x06
    3b7c:	00 97       	sbiw	r24, 0x00	; 0
    3b7e:	09 f4       	brne	.+2      	; 0x3b82 <xQueueCreate+0x3a>
    3b80:	81 c0       	rjmp	.+258    	; 0x3c84 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    3b82:	8f 81       	ldd	r24, Y+7	; 0x07
    3b84:	28 2f       	mov	r18, r24
    3b86:	30 e0       	ldi	r19, 0x00	; 0
    3b88:	88 85       	ldd	r24, Y+8	; 0x08
    3b8a:	88 2f       	mov	r24, r24
    3b8c:	90 e0       	ldi	r25, 0x00	; 0
    3b8e:	ac 01       	movw	r20, r24
    3b90:	24 9f       	mul	r18, r20
    3b92:	c0 01       	movw	r24, r0
    3b94:	25 9f       	mul	r18, r21
    3b96:	90 0d       	add	r25, r0
    3b98:	34 9f       	mul	r19, r20
    3b9a:	90 0d       	add	r25, r0
    3b9c:	11 24       	eor	r1, r1
    3b9e:	01 96       	adiw	r24, 0x01	; 1
    3ba0:	9c 83       	std	Y+4, r25	; 0x04
    3ba2:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    3ba4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ba6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ba8:	0e 94 99 14 	call	0x2932	; 0x2932 <pvPortMalloc>
    3bac:	ed 81       	ldd	r30, Y+5	; 0x05
    3bae:	fe 81       	ldd	r31, Y+6	; 0x06
    3bb0:	91 83       	std	Z+1, r25	; 0x01
    3bb2:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    3bb4:	ed 81       	ldd	r30, Y+5	; 0x05
    3bb6:	fe 81       	ldd	r31, Y+6	; 0x06
    3bb8:	80 81       	ld	r24, Z
    3bba:	91 81       	ldd	r25, Z+1	; 0x01
    3bbc:	00 97       	sbiw	r24, 0x00	; 0
    3bbe:	09 f4       	brne	.+2      	; 0x3bc2 <xQueueCreate+0x7a>
    3bc0:	5d c0       	rjmp	.+186    	; 0x3c7c <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    3bc2:	ed 81       	ldd	r30, Y+5	; 0x05
    3bc4:	fe 81       	ldd	r31, Y+6	; 0x06
    3bc6:	40 81       	ld	r20, Z
    3bc8:	51 81       	ldd	r21, Z+1	; 0x01
    3bca:	8f 81       	ldd	r24, Y+7	; 0x07
    3bcc:	28 2f       	mov	r18, r24
    3bce:	30 e0       	ldi	r19, 0x00	; 0
    3bd0:	88 85       	ldd	r24, Y+8	; 0x08
    3bd2:	88 2f       	mov	r24, r24
    3bd4:	90 e0       	ldi	r25, 0x00	; 0
    3bd6:	bc 01       	movw	r22, r24
    3bd8:	26 9f       	mul	r18, r22
    3bda:	c0 01       	movw	r24, r0
    3bdc:	27 9f       	mul	r18, r23
    3bde:	90 0d       	add	r25, r0
    3be0:	36 9f       	mul	r19, r22
    3be2:	90 0d       	add	r25, r0
    3be4:	11 24       	eor	r1, r1
    3be6:	84 0f       	add	r24, r20
    3be8:	95 1f       	adc	r25, r21
    3bea:	ed 81       	ldd	r30, Y+5	; 0x05
    3bec:	fe 81       	ldd	r31, Y+6	; 0x06
    3bee:	93 83       	std	Z+3, r25	; 0x03
    3bf0:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    3bf2:	ed 81       	ldd	r30, Y+5	; 0x05
    3bf4:	fe 81       	ldd	r31, Y+6	; 0x06
    3bf6:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    3bf8:	ed 81       	ldd	r30, Y+5	; 0x05
    3bfa:	fe 81       	ldd	r31, Y+6	; 0x06
    3bfc:	80 81       	ld	r24, Z
    3bfe:	91 81       	ldd	r25, Z+1	; 0x01
    3c00:	ed 81       	ldd	r30, Y+5	; 0x05
    3c02:	fe 81       	ldd	r31, Y+6	; 0x06
    3c04:	95 83       	std	Z+5, r25	; 0x05
    3c06:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    3c08:	ed 81       	ldd	r30, Y+5	; 0x05
    3c0a:	fe 81       	ldd	r31, Y+6	; 0x06
    3c0c:	40 81       	ld	r20, Z
    3c0e:	51 81       	ldd	r21, Z+1	; 0x01
    3c10:	8f 81       	ldd	r24, Y+7	; 0x07
    3c12:	88 2f       	mov	r24, r24
    3c14:	90 e0       	ldi	r25, 0x00	; 0
    3c16:	9c 01       	movw	r18, r24
    3c18:	21 50       	subi	r18, 0x01	; 1
    3c1a:	30 40       	sbci	r19, 0x00	; 0
    3c1c:	88 85       	ldd	r24, Y+8	; 0x08
    3c1e:	88 2f       	mov	r24, r24
    3c20:	90 e0       	ldi	r25, 0x00	; 0
    3c22:	bc 01       	movw	r22, r24
    3c24:	26 9f       	mul	r18, r22
    3c26:	c0 01       	movw	r24, r0
    3c28:	27 9f       	mul	r18, r23
    3c2a:	90 0d       	add	r25, r0
    3c2c:	36 9f       	mul	r19, r22
    3c2e:	90 0d       	add	r25, r0
    3c30:	11 24       	eor	r1, r1
    3c32:	84 0f       	add	r24, r20
    3c34:	95 1f       	adc	r25, r21
    3c36:	ed 81       	ldd	r30, Y+5	; 0x05
    3c38:	fe 81       	ldd	r31, Y+6	; 0x06
    3c3a:	97 83       	std	Z+7, r25	; 0x07
    3c3c:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    3c3e:	ed 81       	ldd	r30, Y+5	; 0x05
    3c40:	fe 81       	ldd	r31, Y+6	; 0x06
    3c42:	8f 81       	ldd	r24, Y+7	; 0x07
    3c44:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3c46:	ed 81       	ldd	r30, Y+5	; 0x05
    3c48:	fe 81       	ldd	r31, Y+6	; 0x06
    3c4a:	88 85       	ldd	r24, Y+8	; 0x08
    3c4c:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    3c4e:	ed 81       	ldd	r30, Y+5	; 0x05
    3c50:	fe 81       	ldd	r31, Y+6	; 0x06
    3c52:	8f ef       	ldi	r24, 0xFF	; 255
    3c54:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    3c56:	ed 81       	ldd	r30, Y+5	; 0x05
    3c58:	fe 81       	ldd	r31, Y+6	; 0x06
    3c5a:	8f ef       	ldi	r24, 0xFF	; 255
    3c5c:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3c5e:	8d 81       	ldd	r24, Y+5	; 0x05
    3c60:	9e 81       	ldd	r25, Y+6	; 0x06
    3c62:	08 96       	adiw	r24, 0x08	; 8
    3c64:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3c68:	8d 81       	ldd	r24, Y+5	; 0x05
    3c6a:	9e 81       	ldd	r25, Y+6	; 0x06
    3c6c:	41 96       	adiw	r24, 0x11	; 17
    3c6e:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3c72:	8d 81       	ldd	r24, Y+5	; 0x05
    3c74:	9e 81       	ldd	r25, Y+6	; 0x06
    3c76:	9a 83       	std	Y+2, r25	; 0x02
    3c78:	89 83       	std	Y+1, r24	; 0x01
    3c7a:	04 c0       	rjmp	.+8      	; 0x3c84 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    3c7c:	8d 81       	ldd	r24, Y+5	; 0x05
    3c7e:	9e 81       	ldd	r25, Y+6	; 0x06
    3c80:	0e 94 df 14 	call	0x29be	; 0x29be <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3c84:	89 81       	ldd	r24, Y+1	; 0x01
    3c86:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c88:	28 96       	adiw	r28, 0x08	; 8
    3c8a:	0f b6       	in	r0, 0x3f	; 63
    3c8c:	f8 94       	cli
    3c8e:	de bf       	out	0x3e, r29	; 62
    3c90:	0f be       	out	0x3f, r0	; 63
    3c92:	cd bf       	out	0x3d, r28	; 61
    3c94:	cf 91       	pop	r28
    3c96:	df 91       	pop	r29
    3c98:	08 95       	ret

00003c9a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    3c9a:	df 93       	push	r29
    3c9c:	cf 93       	push	r28
    3c9e:	cd b7       	in	r28, 0x3d	; 61
    3ca0:	de b7       	in	r29, 0x3e	; 62
    3ca2:	2c 97       	sbiw	r28, 0x0c	; 12
    3ca4:	0f b6       	in	r0, 0x3f	; 63
    3ca6:	f8 94       	cli
    3ca8:	de bf       	out	0x3e, r29	; 62
    3caa:	0f be       	out	0x3f, r0	; 63
    3cac:	cd bf       	out	0x3d, r28	; 61
    3cae:	9e 83       	std	Y+6, r25	; 0x06
    3cb0:	8d 83       	std	Y+5, r24	; 0x05
    3cb2:	78 87       	std	Y+8, r23	; 0x08
    3cb4:	6f 83       	std	Y+7, r22	; 0x07
    3cb6:	5a 87       	std	Y+10, r21	; 0x0a
    3cb8:	49 87       	std	Y+9, r20	; 0x09
    3cba:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3cbc:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3cbe:	0f b6       	in	r0, 0x3f	; 63
    3cc0:	f8 94       	cli
    3cc2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3cc4:	ed 81       	ldd	r30, Y+5	; 0x05
    3cc6:	fe 81       	ldd	r31, Y+6	; 0x06
    3cc8:	92 8d       	ldd	r25, Z+26	; 0x1a
    3cca:	ed 81       	ldd	r30, Y+5	; 0x05
    3ccc:	fe 81       	ldd	r31, Y+6	; 0x06
    3cce:	83 8d       	ldd	r24, Z+27	; 0x1b
    3cd0:	98 17       	cp	r25, r24
    3cd2:	d8 f4       	brcc	.+54     	; 0x3d0a <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3cd4:	8d 81       	ldd	r24, Y+5	; 0x05
    3cd6:	9e 81       	ldd	r25, Y+6	; 0x06
    3cd8:	2f 81       	ldd	r18, Y+7	; 0x07
    3cda:	38 85       	ldd	r19, Y+8	; 0x08
    3cdc:	b9 01       	movw	r22, r18
    3cde:	4b 85       	ldd	r20, Y+11	; 0x0b
    3ce0:	0e 94 88 20 	call	0x4110	; 0x4110 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ce4:	ed 81       	ldd	r30, Y+5	; 0x05
    3ce6:	fe 81       	ldd	r31, Y+6	; 0x06
    3ce8:	81 89       	ldd	r24, Z+17	; 0x11
    3cea:	88 23       	and	r24, r24
    3cec:	49 f0       	breq	.+18     	; 0x3d00 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    3cee:	8d 81       	ldd	r24, Y+5	; 0x05
    3cf0:	9e 81       	ldd	r25, Y+6	; 0x06
    3cf2:	41 96       	adiw	r24, 0x11	; 17
    3cf4:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <xTaskRemoveFromEventList>
    3cf8:	81 30       	cpi	r24, 0x01	; 1
    3cfa:	11 f4       	brne	.+4      	; 0x3d00 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    3cfc:	0e 94 91 1c 	call	0x3922	; 0x3922 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    3d00:	0f 90       	pop	r0
    3d02:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3d04:	81 e0       	ldi	r24, 0x01	; 1
    3d06:	8c 87       	std	Y+12, r24	; 0x0c
    3d08:	5c c0       	rjmp	.+184    	; 0x3dc2 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3d0a:	89 85       	ldd	r24, Y+9	; 0x09
    3d0c:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d0e:	00 97       	sbiw	r24, 0x00	; 0
    3d10:	21 f4       	brne	.+8      	; 0x3d1a <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3d12:	0f 90       	pop	r0
    3d14:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3d16:	1c 86       	std	Y+12, r1	; 0x0c
    3d18:	54 c0       	rjmp	.+168    	; 0x3dc2 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    3d1a:	89 81       	ldd	r24, Y+1	; 0x01
    3d1c:	88 23       	and	r24, r24
    3d1e:	31 f4       	brne	.+12     	; 0x3d2c <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3d20:	ce 01       	movw	r24, r28
    3d22:	02 96       	adiw	r24, 0x02	; 2
    3d24:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3d28:	81 e0       	ldi	r24, 0x01	; 1
    3d2a:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3d2c:	0f 90       	pop	r0
    3d2e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3d30:	0e 94 61 24 	call	0x48c2	; 0x48c2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3d34:	0f b6       	in	r0, 0x3f	; 63
    3d36:	f8 94       	cli
    3d38:	0f 92       	push	r0
    3d3a:	ed 81       	ldd	r30, Y+5	; 0x05
    3d3c:	fe 81       	ldd	r31, Y+6	; 0x06
    3d3e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d40:	8f 3f       	cpi	r24, 0xFF	; 255
    3d42:	19 f4       	brne	.+6      	; 0x3d4a <xQueueGenericSend+0xb0>
    3d44:	ed 81       	ldd	r30, Y+5	; 0x05
    3d46:	fe 81       	ldd	r31, Y+6	; 0x06
    3d48:	15 8e       	std	Z+29, r1	; 0x1d
    3d4a:	ed 81       	ldd	r30, Y+5	; 0x05
    3d4c:	fe 81       	ldd	r31, Y+6	; 0x06
    3d4e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d50:	8f 3f       	cpi	r24, 0xFF	; 255
    3d52:	19 f4       	brne	.+6      	; 0x3d5a <xQueueGenericSend+0xc0>
    3d54:	ed 81       	ldd	r30, Y+5	; 0x05
    3d56:	fe 81       	ldd	r31, Y+6	; 0x06
    3d58:	16 8e       	std	Z+30, r1	; 0x1e
    3d5a:	0f 90       	pop	r0
    3d5c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3d5e:	ce 01       	movw	r24, r28
    3d60:	02 96       	adiw	r24, 0x02	; 2
    3d62:	9e 01       	movw	r18, r28
    3d64:	27 5f       	subi	r18, 0xF7	; 247
    3d66:	3f 4f       	sbci	r19, 0xFF	; 255
    3d68:	b9 01       	movw	r22, r18
    3d6a:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <xTaskCheckForTimeOut>
    3d6e:	88 23       	and	r24, r24
    3d70:	09 f5       	brne	.+66     	; 0x3db4 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3d72:	8d 81       	ldd	r24, Y+5	; 0x05
    3d74:	9e 81       	ldd	r25, Y+6	; 0x06
    3d76:	0e 94 ec 21 	call	0x43d8	; 0x43d8 <prvIsQueueFull>
    3d7a:	88 23       	and	r24, r24
    3d7c:	a1 f0       	breq	.+40     	; 0x3da6 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3d7e:	8d 81       	ldd	r24, Y+5	; 0x05
    3d80:	9e 81       	ldd	r25, Y+6	; 0x06
    3d82:	08 96       	adiw	r24, 0x08	; 8
    3d84:	29 85       	ldd	r18, Y+9	; 0x09
    3d86:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d88:	b9 01       	movw	r22, r18
    3d8a:	0e 94 67 26 	call	0x4cce	; 0x4cce <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3d8e:	8d 81       	ldd	r24, Y+5	; 0x05
    3d90:	9e 81       	ldd	r25, Y+6	; 0x06
    3d92:	0e 94 65 21 	call	0x42ca	; 0x42ca <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3d96:	0e 94 6d 24 	call	0x48da	; 0x48da <xTaskResumeAll>
    3d9a:	88 23       	and	r24, r24
    3d9c:	09 f0       	breq	.+2      	; 0x3da0 <xQueueGenericSend+0x106>
    3d9e:	8f cf       	rjmp	.-226    	; 0x3cbe <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    3da0:	0e 94 91 1c 	call	0x3922	; 0x3922 <vPortYield>
    3da4:	8c cf       	rjmp	.-232    	; 0x3cbe <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3da6:	8d 81       	ldd	r24, Y+5	; 0x05
    3da8:	9e 81       	ldd	r25, Y+6	; 0x06
    3daa:	0e 94 65 21 	call	0x42ca	; 0x42ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3dae:	0e 94 6d 24 	call	0x48da	; 0x48da <xTaskResumeAll>
    3db2:	85 cf       	rjmp	.-246    	; 0x3cbe <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3db4:	8d 81       	ldd	r24, Y+5	; 0x05
    3db6:	9e 81       	ldd	r25, Y+6	; 0x06
    3db8:	0e 94 65 21 	call	0x42ca	; 0x42ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3dbc:	0e 94 6d 24 	call	0x48da	; 0x48da <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3dc0:	1c 86       	std	Y+12, r1	; 0x0c
    3dc2:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    3dc4:	2c 96       	adiw	r28, 0x0c	; 12
    3dc6:	0f b6       	in	r0, 0x3f	; 63
    3dc8:	f8 94       	cli
    3dca:	de bf       	out	0x3e, r29	; 62
    3dcc:	0f be       	out	0x3f, r0	; 63
    3dce:	cd bf       	out	0x3d, r28	; 61
    3dd0:	cf 91       	pop	r28
    3dd2:	df 91       	pop	r29
    3dd4:	08 95       	ret

00003dd6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    3dd6:	df 93       	push	r29
    3dd8:	cf 93       	push	r28
    3dda:	cd b7       	in	r28, 0x3d	; 61
    3ddc:	de b7       	in	r29, 0x3e	; 62
    3dde:	29 97       	sbiw	r28, 0x09	; 9
    3de0:	0f b6       	in	r0, 0x3f	; 63
    3de2:	f8 94       	cli
    3de4:	de bf       	out	0x3e, r29	; 62
    3de6:	0f be       	out	0x3f, r0	; 63
    3de8:	cd bf       	out	0x3d, r28	; 61
    3dea:	9c 83       	std	Y+4, r25	; 0x04
    3dec:	8b 83       	std	Y+3, r24	; 0x03
    3dee:	7e 83       	std	Y+6, r23	; 0x06
    3df0:	6d 83       	std	Y+5, r22	; 0x05
    3df2:	58 87       	std	Y+8, r21	; 0x08
    3df4:	4f 83       	std	Y+7, r20	; 0x07
    3df6:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3df8:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3dfa:	eb 81       	ldd	r30, Y+3	; 0x03
    3dfc:	fc 81       	ldd	r31, Y+4	; 0x04
    3dfe:	92 8d       	ldd	r25, Z+26	; 0x1a
    3e00:	eb 81       	ldd	r30, Y+3	; 0x03
    3e02:	fc 81       	ldd	r31, Y+4	; 0x04
    3e04:	83 8d       	ldd	r24, Z+27	; 0x1b
    3e06:	98 17       	cp	r25, r24
    3e08:	40 f5       	brcc	.+80     	; 0x3e5a <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3e0a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e0c:	9c 81       	ldd	r25, Y+4	; 0x04
    3e0e:	2d 81       	ldd	r18, Y+5	; 0x05
    3e10:	3e 81       	ldd	r19, Y+6	; 0x06
    3e12:	b9 01       	movw	r22, r18
    3e14:	49 85       	ldd	r20, Y+9	; 0x09
    3e16:	0e 94 88 20 	call	0x4110	; 0x4110 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3e1a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e1c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e20:	8f 3f       	cpi	r24, 0xFF	; 255
    3e22:	89 f4       	brne	.+34     	; 0x3e46 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3e24:	eb 81       	ldd	r30, Y+3	; 0x03
    3e26:	fc 81       	ldd	r31, Y+4	; 0x04
    3e28:	81 89       	ldd	r24, Z+17	; 0x11
    3e2a:	88 23       	and	r24, r24
    3e2c:	99 f0       	breq	.+38     	; 0x3e54 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e30:	9c 81       	ldd	r25, Y+4	; 0x04
    3e32:	41 96       	adiw	r24, 0x11	; 17
    3e34:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <xTaskRemoveFromEventList>
    3e38:	88 23       	and	r24, r24
    3e3a:	61 f0       	breq	.+24     	; 0x3e54 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3e3c:	ef 81       	ldd	r30, Y+7	; 0x07
    3e3e:	f8 85       	ldd	r31, Y+8	; 0x08
    3e40:	81 e0       	ldi	r24, 0x01	; 1
    3e42:	80 83       	st	Z, r24
    3e44:	07 c0       	rjmp	.+14     	; 0x3e54 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3e46:	eb 81       	ldd	r30, Y+3	; 0x03
    3e48:	fc 81       	ldd	r31, Y+4	; 0x04
    3e4a:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e4c:	8f 5f       	subi	r24, 0xFF	; 255
    3e4e:	eb 81       	ldd	r30, Y+3	; 0x03
    3e50:	fc 81       	ldd	r31, Y+4	; 0x04
    3e52:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3e54:	81 e0       	ldi	r24, 0x01	; 1
    3e56:	8a 83       	std	Y+2, r24	; 0x02
    3e58:	01 c0       	rjmp	.+2      	; 0x3e5c <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3e5a:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3e5c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3e5e:	29 96       	adiw	r28, 0x09	; 9
    3e60:	0f b6       	in	r0, 0x3f	; 63
    3e62:	f8 94       	cli
    3e64:	de bf       	out	0x3e, r29	; 62
    3e66:	0f be       	out	0x3f, r0	; 63
    3e68:	cd bf       	out	0x3d, r28	; 61
    3e6a:	cf 91       	pop	r28
    3e6c:	df 91       	pop	r29
    3e6e:	08 95       	ret

00003e70 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3e70:	df 93       	push	r29
    3e72:	cf 93       	push	r28
    3e74:	cd b7       	in	r28, 0x3d	; 61
    3e76:	de b7       	in	r29, 0x3e	; 62
    3e78:	2e 97       	sbiw	r28, 0x0e	; 14
    3e7a:	0f b6       	in	r0, 0x3f	; 63
    3e7c:	f8 94       	cli
    3e7e:	de bf       	out	0x3e, r29	; 62
    3e80:	0f be       	out	0x3f, r0	; 63
    3e82:	cd bf       	out	0x3d, r28	; 61
    3e84:	98 87       	std	Y+8, r25	; 0x08
    3e86:	8f 83       	std	Y+7, r24	; 0x07
    3e88:	7a 87       	std	Y+10, r23	; 0x0a
    3e8a:	69 87       	std	Y+9, r22	; 0x09
    3e8c:	5c 87       	std	Y+12, r21	; 0x0c
    3e8e:	4b 87       	std	Y+11, r20	; 0x0b
    3e90:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3e92:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3e94:	0f b6       	in	r0, 0x3f	; 63
    3e96:	f8 94       	cli
    3e98:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3e9a:	ef 81       	ldd	r30, Y+7	; 0x07
    3e9c:	f8 85       	ldd	r31, Y+8	; 0x08
    3e9e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ea0:	88 23       	and	r24, r24
    3ea2:	09 f4       	brne	.+2      	; 0x3ea6 <xQueueGenericReceive+0x36>
    3ea4:	3f c0       	rjmp	.+126    	; 0x3f24 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    3ea6:	ef 81       	ldd	r30, Y+7	; 0x07
    3ea8:	f8 85       	ldd	r31, Y+8	; 0x08
    3eaa:	86 81       	ldd	r24, Z+6	; 0x06
    3eac:	97 81       	ldd	r25, Z+7	; 0x07
    3eae:	9a 83       	std	Y+2, r25	; 0x02
    3eb0:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3eb2:	8f 81       	ldd	r24, Y+7	; 0x07
    3eb4:	98 85       	ldd	r25, Y+8	; 0x08
    3eb6:	29 85       	ldd	r18, Y+9	; 0x09
    3eb8:	3a 85       	ldd	r19, Y+10	; 0x0a
    3eba:	b9 01       	movw	r22, r18
    3ebc:	0e 94 1d 21 	call	0x423a	; 0x423a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3ec0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ec2:	88 23       	and	r24, r24
    3ec4:	b1 f4       	brne	.+44     	; 0x3ef2 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    3ec6:	ef 81       	ldd	r30, Y+7	; 0x07
    3ec8:	f8 85       	ldd	r31, Y+8	; 0x08
    3eca:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ecc:	81 50       	subi	r24, 0x01	; 1
    3ece:	ef 81       	ldd	r30, Y+7	; 0x07
    3ed0:	f8 85       	ldd	r31, Y+8	; 0x08
    3ed2:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3ed4:	ef 81       	ldd	r30, Y+7	; 0x07
    3ed6:	f8 85       	ldd	r31, Y+8	; 0x08
    3ed8:	80 85       	ldd	r24, Z+8	; 0x08
    3eda:	88 23       	and	r24, r24
    3edc:	f1 f0       	breq	.+60     	; 0x3f1a <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3ede:	8f 81       	ldd	r24, Y+7	; 0x07
    3ee0:	98 85       	ldd	r25, Y+8	; 0x08
    3ee2:	08 96       	adiw	r24, 0x08	; 8
    3ee4:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <xTaskRemoveFromEventList>
    3ee8:	81 30       	cpi	r24, 0x01	; 1
    3eea:	b9 f4       	brne	.+46     	; 0x3f1a <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    3eec:	0e 94 91 1c 	call	0x3922	; 0x3922 <vPortYield>
    3ef0:	14 c0       	rjmp	.+40     	; 0x3f1a <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3ef2:	ef 81       	ldd	r30, Y+7	; 0x07
    3ef4:	f8 85       	ldd	r31, Y+8	; 0x08
    3ef6:	89 81       	ldd	r24, Y+1	; 0x01
    3ef8:	9a 81       	ldd	r25, Y+2	; 0x02
    3efa:	97 83       	std	Z+7, r25	; 0x07
    3efc:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3efe:	ef 81       	ldd	r30, Y+7	; 0x07
    3f00:	f8 85       	ldd	r31, Y+8	; 0x08
    3f02:	81 89       	ldd	r24, Z+17	; 0x11
    3f04:	88 23       	and	r24, r24
    3f06:	49 f0       	breq	.+18     	; 0x3f1a <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3f08:	8f 81       	ldd	r24, Y+7	; 0x07
    3f0a:	98 85       	ldd	r25, Y+8	; 0x08
    3f0c:	41 96       	adiw	r24, 0x11	; 17
    3f0e:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <xTaskRemoveFromEventList>
    3f12:	88 23       	and	r24, r24
    3f14:	11 f0       	breq	.+4      	; 0x3f1a <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3f16:	0e 94 91 1c 	call	0x3922	; 0x3922 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3f1a:	0f 90       	pop	r0
    3f1c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3f1e:	81 e0       	ldi	r24, 0x01	; 1
    3f20:	8e 87       	std	Y+14, r24	; 0x0e
    3f22:	5c c0       	rjmp	.+184    	; 0x3fdc <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3f24:	8b 85       	ldd	r24, Y+11	; 0x0b
    3f26:	9c 85       	ldd	r25, Y+12	; 0x0c
    3f28:	00 97       	sbiw	r24, 0x00	; 0
    3f2a:	21 f4       	brne	.+8      	; 0x3f34 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3f2c:	0f 90       	pop	r0
    3f2e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3f30:	1e 86       	std	Y+14, r1	; 0x0e
    3f32:	54 c0       	rjmp	.+168    	; 0x3fdc <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3f34:	8b 81       	ldd	r24, Y+3	; 0x03
    3f36:	88 23       	and	r24, r24
    3f38:	31 f4       	brne	.+12     	; 0x3f46 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3f3a:	ce 01       	movw	r24, r28
    3f3c:	04 96       	adiw	r24, 0x04	; 4
    3f3e:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3f42:	81 e0       	ldi	r24, 0x01	; 1
    3f44:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3f46:	0f 90       	pop	r0
    3f48:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3f4a:	0e 94 61 24 	call	0x48c2	; 0x48c2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3f4e:	0f b6       	in	r0, 0x3f	; 63
    3f50:	f8 94       	cli
    3f52:	0f 92       	push	r0
    3f54:	ef 81       	ldd	r30, Y+7	; 0x07
    3f56:	f8 85       	ldd	r31, Y+8	; 0x08
    3f58:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f5a:	8f 3f       	cpi	r24, 0xFF	; 255
    3f5c:	19 f4       	brne	.+6      	; 0x3f64 <xQueueGenericReceive+0xf4>
    3f5e:	ef 81       	ldd	r30, Y+7	; 0x07
    3f60:	f8 85       	ldd	r31, Y+8	; 0x08
    3f62:	15 8e       	std	Z+29, r1	; 0x1d
    3f64:	ef 81       	ldd	r30, Y+7	; 0x07
    3f66:	f8 85       	ldd	r31, Y+8	; 0x08
    3f68:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f6a:	8f 3f       	cpi	r24, 0xFF	; 255
    3f6c:	19 f4       	brne	.+6      	; 0x3f74 <xQueueGenericReceive+0x104>
    3f6e:	ef 81       	ldd	r30, Y+7	; 0x07
    3f70:	f8 85       	ldd	r31, Y+8	; 0x08
    3f72:	16 8e       	std	Z+30, r1	; 0x1e
    3f74:	0f 90       	pop	r0
    3f76:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3f78:	ce 01       	movw	r24, r28
    3f7a:	04 96       	adiw	r24, 0x04	; 4
    3f7c:	9e 01       	movw	r18, r28
    3f7e:	25 5f       	subi	r18, 0xF5	; 245
    3f80:	3f 4f       	sbci	r19, 0xFF	; 255
    3f82:	b9 01       	movw	r22, r18
    3f84:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <xTaskCheckForTimeOut>
    3f88:	88 23       	and	r24, r24
    3f8a:	09 f5       	brne	.+66     	; 0x3fce <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3f8c:	8f 81       	ldd	r24, Y+7	; 0x07
    3f8e:	98 85       	ldd	r25, Y+8	; 0x08
    3f90:	0e 94 b9 21 	call	0x4372	; 0x4372 <prvIsQueueEmpty>
    3f94:	88 23       	and	r24, r24
    3f96:	a1 f0       	breq	.+40     	; 0x3fc0 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3f98:	8f 81       	ldd	r24, Y+7	; 0x07
    3f9a:	98 85       	ldd	r25, Y+8	; 0x08
    3f9c:	41 96       	adiw	r24, 0x11	; 17
    3f9e:	2b 85       	ldd	r18, Y+11	; 0x0b
    3fa0:	3c 85       	ldd	r19, Y+12	; 0x0c
    3fa2:	b9 01       	movw	r22, r18
    3fa4:	0e 94 67 26 	call	0x4cce	; 0x4cce <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3fa8:	8f 81       	ldd	r24, Y+7	; 0x07
    3faa:	98 85       	ldd	r25, Y+8	; 0x08
    3fac:	0e 94 65 21 	call	0x42ca	; 0x42ca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3fb0:	0e 94 6d 24 	call	0x48da	; 0x48da <xTaskResumeAll>
    3fb4:	88 23       	and	r24, r24
    3fb6:	09 f0       	breq	.+2      	; 0x3fba <xQueueGenericReceive+0x14a>
    3fb8:	6d cf       	rjmp	.-294    	; 0x3e94 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    3fba:	0e 94 91 1c 	call	0x3922	; 0x3922 <vPortYield>
    3fbe:	6a cf       	rjmp	.-300    	; 0x3e94 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3fc0:	8f 81       	ldd	r24, Y+7	; 0x07
    3fc2:	98 85       	ldd	r25, Y+8	; 0x08
    3fc4:	0e 94 65 21 	call	0x42ca	; 0x42ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3fc8:	0e 94 6d 24 	call	0x48da	; 0x48da <xTaskResumeAll>
    3fcc:	63 cf       	rjmp	.-314    	; 0x3e94 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3fce:	8f 81       	ldd	r24, Y+7	; 0x07
    3fd0:	98 85       	ldd	r25, Y+8	; 0x08
    3fd2:	0e 94 65 21 	call	0x42ca	; 0x42ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3fd6:	0e 94 6d 24 	call	0x48da	; 0x48da <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3fda:	1e 86       	std	Y+14, r1	; 0x0e
    3fdc:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    3fde:	2e 96       	adiw	r28, 0x0e	; 14
    3fe0:	0f b6       	in	r0, 0x3f	; 63
    3fe2:	f8 94       	cli
    3fe4:	de bf       	out	0x3e, r29	; 62
    3fe6:	0f be       	out	0x3f, r0	; 63
    3fe8:	cd bf       	out	0x3d, r28	; 61
    3fea:	cf 91       	pop	r28
    3fec:	df 91       	pop	r29
    3fee:	08 95       	ret

00003ff0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3ff0:	df 93       	push	r29
    3ff2:	cf 93       	push	r28
    3ff4:	cd b7       	in	r28, 0x3d	; 61
    3ff6:	de b7       	in	r29, 0x3e	; 62
    3ff8:	28 97       	sbiw	r28, 0x08	; 8
    3ffa:	0f b6       	in	r0, 0x3f	; 63
    3ffc:	f8 94       	cli
    3ffe:	de bf       	out	0x3e, r29	; 62
    4000:	0f be       	out	0x3f, r0	; 63
    4002:	cd bf       	out	0x3d, r28	; 61
    4004:	9c 83       	std	Y+4, r25	; 0x04
    4006:	8b 83       	std	Y+3, r24	; 0x03
    4008:	7e 83       	std	Y+6, r23	; 0x06
    400a:	6d 83       	std	Y+5, r22	; 0x05
    400c:	58 87       	std	Y+8, r21	; 0x08
    400e:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4010:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    4012:	eb 81       	ldd	r30, Y+3	; 0x03
    4014:	fc 81       	ldd	r31, Y+4	; 0x04
    4016:	82 8d       	ldd	r24, Z+26	; 0x1a
    4018:	88 23       	and	r24, r24
    401a:	71 f1       	breq	.+92     	; 0x4078 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    401c:	8b 81       	ldd	r24, Y+3	; 0x03
    401e:	9c 81       	ldd	r25, Y+4	; 0x04
    4020:	2d 81       	ldd	r18, Y+5	; 0x05
    4022:	3e 81       	ldd	r19, Y+6	; 0x06
    4024:	b9 01       	movw	r22, r18
    4026:	0e 94 1d 21 	call	0x423a	; 0x423a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    402a:	eb 81       	ldd	r30, Y+3	; 0x03
    402c:	fc 81       	ldd	r31, Y+4	; 0x04
    402e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4030:	81 50       	subi	r24, 0x01	; 1
    4032:	eb 81       	ldd	r30, Y+3	; 0x03
    4034:	fc 81       	ldd	r31, Y+4	; 0x04
    4036:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    4038:	eb 81       	ldd	r30, Y+3	; 0x03
    403a:	fc 81       	ldd	r31, Y+4	; 0x04
    403c:	85 8d       	ldd	r24, Z+29	; 0x1d
    403e:	8f 3f       	cpi	r24, 0xFF	; 255
    4040:	89 f4       	brne	.+34     	; 0x4064 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4042:	eb 81       	ldd	r30, Y+3	; 0x03
    4044:	fc 81       	ldd	r31, Y+4	; 0x04
    4046:	80 85       	ldd	r24, Z+8	; 0x08
    4048:	88 23       	and	r24, r24
    404a:	99 f0       	breq	.+38     	; 0x4072 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    404c:	8b 81       	ldd	r24, Y+3	; 0x03
    404e:	9c 81       	ldd	r25, Y+4	; 0x04
    4050:	08 96       	adiw	r24, 0x08	; 8
    4052:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <xTaskRemoveFromEventList>
    4056:	88 23       	and	r24, r24
    4058:	61 f0       	breq	.+24     	; 0x4072 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    405a:	ef 81       	ldd	r30, Y+7	; 0x07
    405c:	f8 85       	ldd	r31, Y+8	; 0x08
    405e:	81 e0       	ldi	r24, 0x01	; 1
    4060:	80 83       	st	Z, r24
    4062:	07 c0       	rjmp	.+14     	; 0x4072 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    4064:	eb 81       	ldd	r30, Y+3	; 0x03
    4066:	fc 81       	ldd	r31, Y+4	; 0x04
    4068:	85 8d       	ldd	r24, Z+29	; 0x1d
    406a:	8f 5f       	subi	r24, 0xFF	; 255
    406c:	eb 81       	ldd	r30, Y+3	; 0x03
    406e:	fc 81       	ldd	r31, Y+4	; 0x04
    4070:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    4072:	81 e0       	ldi	r24, 0x01	; 1
    4074:	8a 83       	std	Y+2, r24	; 0x02
    4076:	01 c0       	rjmp	.+2      	; 0x407a <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    4078:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    407a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    407c:	28 96       	adiw	r28, 0x08	; 8
    407e:	0f b6       	in	r0, 0x3f	; 63
    4080:	f8 94       	cli
    4082:	de bf       	out	0x3e, r29	; 62
    4084:	0f be       	out	0x3f, r0	; 63
    4086:	cd bf       	out	0x3d, r28	; 61
    4088:	cf 91       	pop	r28
    408a:	df 91       	pop	r29
    408c:	08 95       	ret

0000408e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    408e:	df 93       	push	r29
    4090:	cf 93       	push	r28
    4092:	00 d0       	rcall	.+0      	; 0x4094 <uxQueueMessagesWaiting+0x6>
    4094:	0f 92       	push	r0
    4096:	cd b7       	in	r28, 0x3d	; 61
    4098:	de b7       	in	r29, 0x3e	; 62
    409a:	9b 83       	std	Y+3, r25	; 0x03
    409c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    409e:	0f b6       	in	r0, 0x3f	; 63
    40a0:	f8 94       	cli
    40a2:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    40a4:	ea 81       	ldd	r30, Y+2	; 0x02
    40a6:	fb 81       	ldd	r31, Y+3	; 0x03
    40a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    40aa:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    40ac:	0f 90       	pop	r0
    40ae:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    40b0:	89 81       	ldd	r24, Y+1	; 0x01
}
    40b2:	0f 90       	pop	r0
    40b4:	0f 90       	pop	r0
    40b6:	0f 90       	pop	r0
    40b8:	cf 91       	pop	r28
    40ba:	df 91       	pop	r29
    40bc:	08 95       	ret

000040be <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    40be:	df 93       	push	r29
    40c0:	cf 93       	push	r28
    40c2:	00 d0       	rcall	.+0      	; 0x40c4 <uxQueueMessagesWaitingFromISR+0x6>
    40c4:	0f 92       	push	r0
    40c6:	cd b7       	in	r28, 0x3d	; 61
    40c8:	de b7       	in	r29, 0x3e	; 62
    40ca:	9b 83       	std	Y+3, r25	; 0x03
    40cc:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    40ce:	ea 81       	ldd	r30, Y+2	; 0x02
    40d0:	fb 81       	ldd	r31, Y+3	; 0x03
    40d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    40d4:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    40d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    40d8:	0f 90       	pop	r0
    40da:	0f 90       	pop	r0
    40dc:	0f 90       	pop	r0
    40de:	cf 91       	pop	r28
    40e0:	df 91       	pop	r29
    40e2:	08 95       	ret

000040e4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    40e4:	df 93       	push	r29
    40e6:	cf 93       	push	r28
    40e8:	00 d0       	rcall	.+0      	; 0x40ea <vQueueDelete+0x6>
    40ea:	cd b7       	in	r28, 0x3d	; 61
    40ec:	de b7       	in	r29, 0x3e	; 62
    40ee:	9a 83       	std	Y+2, r25	; 0x02
    40f0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    40f2:	e9 81       	ldd	r30, Y+1	; 0x01
    40f4:	fa 81       	ldd	r31, Y+2	; 0x02
    40f6:	80 81       	ld	r24, Z
    40f8:	91 81       	ldd	r25, Z+1	; 0x01
    40fa:	0e 94 df 14 	call	0x29be	; 0x29be <vPortFree>
	vPortFree( pxQueue );
    40fe:	89 81       	ldd	r24, Y+1	; 0x01
    4100:	9a 81       	ldd	r25, Y+2	; 0x02
    4102:	0e 94 df 14 	call	0x29be	; 0x29be <vPortFree>
}
    4106:	0f 90       	pop	r0
    4108:	0f 90       	pop	r0
    410a:	cf 91       	pop	r28
    410c:	df 91       	pop	r29
    410e:	08 95       	ret

00004110 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    4110:	df 93       	push	r29
    4112:	cf 93       	push	r28
    4114:	00 d0       	rcall	.+0      	; 0x4116 <prvCopyDataToQueue+0x6>
    4116:	00 d0       	rcall	.+0      	; 0x4118 <prvCopyDataToQueue+0x8>
    4118:	0f 92       	push	r0
    411a:	cd b7       	in	r28, 0x3d	; 61
    411c:	de b7       	in	r29, 0x3e	; 62
    411e:	9a 83       	std	Y+2, r25	; 0x02
    4120:	89 83       	std	Y+1, r24	; 0x01
    4122:	7c 83       	std	Y+4, r23	; 0x04
    4124:	6b 83       	std	Y+3, r22	; 0x03
    4126:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    4128:	e9 81       	ldd	r30, Y+1	; 0x01
    412a:	fa 81       	ldd	r31, Y+2	; 0x02
    412c:	84 8d       	ldd	r24, Z+28	; 0x1c
    412e:	88 23       	and	r24, r24
    4130:	09 f4       	brne	.+2      	; 0x4134 <prvCopyDataToQueue+0x24>
    4132:	74 c0       	rjmp	.+232    	; 0x421c <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    4134:	8d 81       	ldd	r24, Y+5	; 0x05
    4136:	88 23       	and	r24, r24
    4138:	99 f5       	brne	.+102    	; 0x41a0 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    413a:	e9 81       	ldd	r30, Y+1	; 0x01
    413c:	fa 81       	ldd	r31, Y+2	; 0x02
    413e:	64 81       	ldd	r22, Z+4	; 0x04
    4140:	75 81       	ldd	r23, Z+5	; 0x05
    4142:	e9 81       	ldd	r30, Y+1	; 0x01
    4144:	fa 81       	ldd	r31, Y+2	; 0x02
    4146:	84 8d       	ldd	r24, Z+28	; 0x1c
    4148:	48 2f       	mov	r20, r24
    414a:	50 e0       	ldi	r21, 0x00	; 0
    414c:	2b 81       	ldd	r18, Y+3	; 0x03
    414e:	3c 81       	ldd	r19, Y+4	; 0x04
    4150:	cb 01       	movw	r24, r22
    4152:	b9 01       	movw	r22, r18
    4154:	0e 94 47 29 	call	0x528e	; 0x528e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    4158:	e9 81       	ldd	r30, Y+1	; 0x01
    415a:	fa 81       	ldd	r31, Y+2	; 0x02
    415c:	24 81       	ldd	r18, Z+4	; 0x04
    415e:	35 81       	ldd	r19, Z+5	; 0x05
    4160:	e9 81       	ldd	r30, Y+1	; 0x01
    4162:	fa 81       	ldd	r31, Y+2	; 0x02
    4164:	84 8d       	ldd	r24, Z+28	; 0x1c
    4166:	88 2f       	mov	r24, r24
    4168:	90 e0       	ldi	r25, 0x00	; 0
    416a:	82 0f       	add	r24, r18
    416c:	93 1f       	adc	r25, r19
    416e:	e9 81       	ldd	r30, Y+1	; 0x01
    4170:	fa 81       	ldd	r31, Y+2	; 0x02
    4172:	95 83       	std	Z+5, r25	; 0x05
    4174:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    4176:	e9 81       	ldd	r30, Y+1	; 0x01
    4178:	fa 81       	ldd	r31, Y+2	; 0x02
    417a:	24 81       	ldd	r18, Z+4	; 0x04
    417c:	35 81       	ldd	r19, Z+5	; 0x05
    417e:	e9 81       	ldd	r30, Y+1	; 0x01
    4180:	fa 81       	ldd	r31, Y+2	; 0x02
    4182:	82 81       	ldd	r24, Z+2	; 0x02
    4184:	93 81       	ldd	r25, Z+3	; 0x03
    4186:	28 17       	cp	r18, r24
    4188:	39 07       	cpc	r19, r25
    418a:	08 f4       	brcc	.+2      	; 0x418e <prvCopyDataToQueue+0x7e>
    418c:	47 c0       	rjmp	.+142    	; 0x421c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    418e:	e9 81       	ldd	r30, Y+1	; 0x01
    4190:	fa 81       	ldd	r31, Y+2	; 0x02
    4192:	80 81       	ld	r24, Z
    4194:	91 81       	ldd	r25, Z+1	; 0x01
    4196:	e9 81       	ldd	r30, Y+1	; 0x01
    4198:	fa 81       	ldd	r31, Y+2	; 0x02
    419a:	95 83       	std	Z+5, r25	; 0x05
    419c:	84 83       	std	Z+4, r24	; 0x04
    419e:	3e c0       	rjmp	.+124    	; 0x421c <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    41a0:	e9 81       	ldd	r30, Y+1	; 0x01
    41a2:	fa 81       	ldd	r31, Y+2	; 0x02
    41a4:	66 81       	ldd	r22, Z+6	; 0x06
    41a6:	77 81       	ldd	r23, Z+7	; 0x07
    41a8:	e9 81       	ldd	r30, Y+1	; 0x01
    41aa:	fa 81       	ldd	r31, Y+2	; 0x02
    41ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    41ae:	48 2f       	mov	r20, r24
    41b0:	50 e0       	ldi	r21, 0x00	; 0
    41b2:	2b 81       	ldd	r18, Y+3	; 0x03
    41b4:	3c 81       	ldd	r19, Y+4	; 0x04
    41b6:	cb 01       	movw	r24, r22
    41b8:	b9 01       	movw	r22, r18
    41ba:	0e 94 47 29 	call	0x528e	; 0x528e <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    41be:	e9 81       	ldd	r30, Y+1	; 0x01
    41c0:	fa 81       	ldd	r31, Y+2	; 0x02
    41c2:	26 81       	ldd	r18, Z+6	; 0x06
    41c4:	37 81       	ldd	r19, Z+7	; 0x07
    41c6:	e9 81       	ldd	r30, Y+1	; 0x01
    41c8:	fa 81       	ldd	r31, Y+2	; 0x02
    41ca:	84 8d       	ldd	r24, Z+28	; 0x1c
    41cc:	88 2f       	mov	r24, r24
    41ce:	90 e0       	ldi	r25, 0x00	; 0
    41d0:	90 95       	com	r25
    41d2:	81 95       	neg	r24
    41d4:	9f 4f       	sbci	r25, 0xFF	; 255
    41d6:	82 0f       	add	r24, r18
    41d8:	93 1f       	adc	r25, r19
    41da:	e9 81       	ldd	r30, Y+1	; 0x01
    41dc:	fa 81       	ldd	r31, Y+2	; 0x02
    41de:	97 83       	std	Z+7, r25	; 0x07
    41e0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    41e2:	e9 81       	ldd	r30, Y+1	; 0x01
    41e4:	fa 81       	ldd	r31, Y+2	; 0x02
    41e6:	26 81       	ldd	r18, Z+6	; 0x06
    41e8:	37 81       	ldd	r19, Z+7	; 0x07
    41ea:	e9 81       	ldd	r30, Y+1	; 0x01
    41ec:	fa 81       	ldd	r31, Y+2	; 0x02
    41ee:	80 81       	ld	r24, Z
    41f0:	91 81       	ldd	r25, Z+1	; 0x01
    41f2:	28 17       	cp	r18, r24
    41f4:	39 07       	cpc	r19, r25
    41f6:	90 f4       	brcc	.+36     	; 0x421c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    41f8:	e9 81       	ldd	r30, Y+1	; 0x01
    41fa:	fa 81       	ldd	r31, Y+2	; 0x02
    41fc:	22 81       	ldd	r18, Z+2	; 0x02
    41fe:	33 81       	ldd	r19, Z+3	; 0x03
    4200:	e9 81       	ldd	r30, Y+1	; 0x01
    4202:	fa 81       	ldd	r31, Y+2	; 0x02
    4204:	84 8d       	ldd	r24, Z+28	; 0x1c
    4206:	88 2f       	mov	r24, r24
    4208:	90 e0       	ldi	r25, 0x00	; 0
    420a:	90 95       	com	r25
    420c:	81 95       	neg	r24
    420e:	9f 4f       	sbci	r25, 0xFF	; 255
    4210:	82 0f       	add	r24, r18
    4212:	93 1f       	adc	r25, r19
    4214:	e9 81       	ldd	r30, Y+1	; 0x01
    4216:	fa 81       	ldd	r31, Y+2	; 0x02
    4218:	97 83       	std	Z+7, r25	; 0x07
    421a:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    421c:	e9 81       	ldd	r30, Y+1	; 0x01
    421e:	fa 81       	ldd	r31, Y+2	; 0x02
    4220:	82 8d       	ldd	r24, Z+26	; 0x1a
    4222:	8f 5f       	subi	r24, 0xFF	; 255
    4224:	e9 81       	ldd	r30, Y+1	; 0x01
    4226:	fa 81       	ldd	r31, Y+2	; 0x02
    4228:	82 8f       	std	Z+26, r24	; 0x1a
}
    422a:	0f 90       	pop	r0
    422c:	0f 90       	pop	r0
    422e:	0f 90       	pop	r0
    4230:	0f 90       	pop	r0
    4232:	0f 90       	pop	r0
    4234:	cf 91       	pop	r28
    4236:	df 91       	pop	r29
    4238:	08 95       	ret

0000423a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    423a:	df 93       	push	r29
    423c:	cf 93       	push	r28
    423e:	00 d0       	rcall	.+0      	; 0x4240 <prvCopyDataFromQueue+0x6>
    4240:	00 d0       	rcall	.+0      	; 0x4242 <prvCopyDataFromQueue+0x8>
    4242:	cd b7       	in	r28, 0x3d	; 61
    4244:	de b7       	in	r29, 0x3e	; 62
    4246:	9a 83       	std	Y+2, r25	; 0x02
    4248:	89 83       	std	Y+1, r24	; 0x01
    424a:	7c 83       	std	Y+4, r23	; 0x04
    424c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    424e:	e9 81       	ldd	r30, Y+1	; 0x01
    4250:	fa 81       	ldd	r31, Y+2	; 0x02
    4252:	80 81       	ld	r24, Z
    4254:	91 81       	ldd	r25, Z+1	; 0x01
    4256:	00 97       	sbiw	r24, 0x00	; 0
    4258:	89 f1       	breq	.+98     	; 0x42bc <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    425a:	e9 81       	ldd	r30, Y+1	; 0x01
    425c:	fa 81       	ldd	r31, Y+2	; 0x02
    425e:	26 81       	ldd	r18, Z+6	; 0x06
    4260:	37 81       	ldd	r19, Z+7	; 0x07
    4262:	e9 81       	ldd	r30, Y+1	; 0x01
    4264:	fa 81       	ldd	r31, Y+2	; 0x02
    4266:	84 8d       	ldd	r24, Z+28	; 0x1c
    4268:	88 2f       	mov	r24, r24
    426a:	90 e0       	ldi	r25, 0x00	; 0
    426c:	82 0f       	add	r24, r18
    426e:	93 1f       	adc	r25, r19
    4270:	e9 81       	ldd	r30, Y+1	; 0x01
    4272:	fa 81       	ldd	r31, Y+2	; 0x02
    4274:	97 83       	std	Z+7, r25	; 0x07
    4276:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    4278:	e9 81       	ldd	r30, Y+1	; 0x01
    427a:	fa 81       	ldd	r31, Y+2	; 0x02
    427c:	26 81       	ldd	r18, Z+6	; 0x06
    427e:	37 81       	ldd	r19, Z+7	; 0x07
    4280:	e9 81       	ldd	r30, Y+1	; 0x01
    4282:	fa 81       	ldd	r31, Y+2	; 0x02
    4284:	82 81       	ldd	r24, Z+2	; 0x02
    4286:	93 81       	ldd	r25, Z+3	; 0x03
    4288:	28 17       	cp	r18, r24
    428a:	39 07       	cpc	r19, r25
    428c:	40 f0       	brcs	.+16     	; 0x429e <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    428e:	e9 81       	ldd	r30, Y+1	; 0x01
    4290:	fa 81       	ldd	r31, Y+2	; 0x02
    4292:	80 81       	ld	r24, Z
    4294:	91 81       	ldd	r25, Z+1	; 0x01
    4296:	e9 81       	ldd	r30, Y+1	; 0x01
    4298:	fa 81       	ldd	r31, Y+2	; 0x02
    429a:	97 83       	std	Z+7, r25	; 0x07
    429c:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    429e:	e9 81       	ldd	r30, Y+1	; 0x01
    42a0:	fa 81       	ldd	r31, Y+2	; 0x02
    42a2:	46 81       	ldd	r20, Z+6	; 0x06
    42a4:	57 81       	ldd	r21, Z+7	; 0x07
    42a6:	e9 81       	ldd	r30, Y+1	; 0x01
    42a8:	fa 81       	ldd	r31, Y+2	; 0x02
    42aa:	84 8d       	ldd	r24, Z+28	; 0x1c
    42ac:	28 2f       	mov	r18, r24
    42ae:	30 e0       	ldi	r19, 0x00	; 0
    42b0:	8b 81       	ldd	r24, Y+3	; 0x03
    42b2:	9c 81       	ldd	r25, Y+4	; 0x04
    42b4:	ba 01       	movw	r22, r20
    42b6:	a9 01       	movw	r20, r18
    42b8:	0e 94 47 29 	call	0x528e	; 0x528e <memcpy>
	}
}
    42bc:	0f 90       	pop	r0
    42be:	0f 90       	pop	r0
    42c0:	0f 90       	pop	r0
    42c2:	0f 90       	pop	r0
    42c4:	cf 91       	pop	r28
    42c6:	df 91       	pop	r29
    42c8:	08 95       	ret

000042ca <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    42ca:	df 93       	push	r29
    42cc:	cf 93       	push	r28
    42ce:	00 d0       	rcall	.+0      	; 0x42d0 <prvUnlockQueue+0x6>
    42d0:	cd b7       	in	r28, 0x3d	; 61
    42d2:	de b7       	in	r29, 0x3e	; 62
    42d4:	9a 83       	std	Y+2, r25	; 0x02
    42d6:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    42d8:	0f b6       	in	r0, 0x3f	; 63
    42da:	f8 94       	cli
    42dc:	0f 92       	push	r0
    42de:	15 c0       	rjmp	.+42     	; 0x430a <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    42e0:	e9 81       	ldd	r30, Y+1	; 0x01
    42e2:	fa 81       	ldd	r31, Y+2	; 0x02
    42e4:	81 89       	ldd	r24, Z+17	; 0x11
    42e6:	88 23       	and	r24, r24
    42e8:	a9 f0       	breq	.+42     	; 0x4314 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    42ea:	89 81       	ldd	r24, Y+1	; 0x01
    42ec:	9a 81       	ldd	r25, Y+2	; 0x02
    42ee:	41 96       	adiw	r24, 0x11	; 17
    42f0:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <xTaskRemoveFromEventList>
    42f4:	88 23       	and	r24, r24
    42f6:	11 f0       	breq	.+4      	; 0x42fc <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    42f8:	0e 94 7b 27 	call	0x4ef6	; 0x4ef6 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    42fc:	e9 81       	ldd	r30, Y+1	; 0x01
    42fe:	fa 81       	ldd	r31, Y+2	; 0x02
    4300:	86 8d       	ldd	r24, Z+30	; 0x1e
    4302:	81 50       	subi	r24, 0x01	; 1
    4304:	e9 81       	ldd	r30, Y+1	; 0x01
    4306:	fa 81       	ldd	r31, Y+2	; 0x02
    4308:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    430a:	e9 81       	ldd	r30, Y+1	; 0x01
    430c:	fa 81       	ldd	r31, Y+2	; 0x02
    430e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4310:	18 16       	cp	r1, r24
    4312:	34 f3       	brlt	.-52     	; 0x42e0 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4314:	e9 81       	ldd	r30, Y+1	; 0x01
    4316:	fa 81       	ldd	r31, Y+2	; 0x02
    4318:	8f ef       	ldi	r24, 0xFF	; 255
    431a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    431c:	0f 90       	pop	r0
    431e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4320:	0f b6       	in	r0, 0x3f	; 63
    4322:	f8 94       	cli
    4324:	0f 92       	push	r0
    4326:	15 c0       	rjmp	.+42     	; 0x4352 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4328:	e9 81       	ldd	r30, Y+1	; 0x01
    432a:	fa 81       	ldd	r31, Y+2	; 0x02
    432c:	80 85       	ldd	r24, Z+8	; 0x08
    432e:	88 23       	and	r24, r24
    4330:	a9 f0       	breq	.+42     	; 0x435c <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4332:	89 81       	ldd	r24, Y+1	; 0x01
    4334:	9a 81       	ldd	r25, Y+2	; 0x02
    4336:	08 96       	adiw	r24, 0x08	; 8
    4338:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <xTaskRemoveFromEventList>
    433c:	88 23       	and	r24, r24
    433e:	11 f0       	breq	.+4      	; 0x4344 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    4340:	0e 94 7b 27 	call	0x4ef6	; 0x4ef6 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    4344:	e9 81       	ldd	r30, Y+1	; 0x01
    4346:	fa 81       	ldd	r31, Y+2	; 0x02
    4348:	85 8d       	ldd	r24, Z+29	; 0x1d
    434a:	81 50       	subi	r24, 0x01	; 1
    434c:	e9 81       	ldd	r30, Y+1	; 0x01
    434e:	fa 81       	ldd	r31, Y+2	; 0x02
    4350:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4352:	e9 81       	ldd	r30, Y+1	; 0x01
    4354:	fa 81       	ldd	r31, Y+2	; 0x02
    4356:	85 8d       	ldd	r24, Z+29	; 0x1d
    4358:	18 16       	cp	r1, r24
    435a:	34 f3       	brlt	.-52     	; 0x4328 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    435c:	e9 81       	ldd	r30, Y+1	; 0x01
    435e:	fa 81       	ldd	r31, Y+2	; 0x02
    4360:	8f ef       	ldi	r24, 0xFF	; 255
    4362:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4364:	0f 90       	pop	r0
    4366:	0f be       	out	0x3f, r0	; 63
}
    4368:	0f 90       	pop	r0
    436a:	0f 90       	pop	r0
    436c:	cf 91       	pop	r28
    436e:	df 91       	pop	r29
    4370:	08 95       	ret

00004372 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    4372:	df 93       	push	r29
    4374:	cf 93       	push	r28
    4376:	00 d0       	rcall	.+0      	; 0x4378 <prvIsQueueEmpty+0x6>
    4378:	0f 92       	push	r0
    437a:	cd b7       	in	r28, 0x3d	; 61
    437c:	de b7       	in	r29, 0x3e	; 62
    437e:	9b 83       	std	Y+3, r25	; 0x03
    4380:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    4382:	0f b6       	in	r0, 0x3f	; 63
    4384:	f8 94       	cli
    4386:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    4388:	ea 81       	ldd	r30, Y+2	; 0x02
    438a:	fb 81       	ldd	r31, Y+3	; 0x03
    438c:	82 8d       	ldd	r24, Z+26	; 0x1a
    438e:	19 82       	std	Y+1, r1	; 0x01
    4390:	88 23       	and	r24, r24
    4392:	11 f4       	brne	.+4      	; 0x4398 <prvIsQueueEmpty+0x26>
    4394:	81 e0       	ldi	r24, 0x01	; 1
    4396:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    4398:	0f 90       	pop	r0
    439a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    439c:	89 81       	ldd	r24, Y+1	; 0x01
}
    439e:	0f 90       	pop	r0
    43a0:	0f 90       	pop	r0
    43a2:	0f 90       	pop	r0
    43a4:	cf 91       	pop	r28
    43a6:	df 91       	pop	r29
    43a8:	08 95       	ret

000043aa <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    43aa:	df 93       	push	r29
    43ac:	cf 93       	push	r28
    43ae:	00 d0       	rcall	.+0      	; 0x43b0 <xQueueIsQueueEmptyFromISR+0x6>
    43b0:	0f 92       	push	r0
    43b2:	cd b7       	in	r28, 0x3d	; 61
    43b4:	de b7       	in	r29, 0x3e	; 62
    43b6:	9b 83       	std	Y+3, r25	; 0x03
    43b8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    43ba:	ea 81       	ldd	r30, Y+2	; 0x02
    43bc:	fb 81       	ldd	r31, Y+3	; 0x03
    43be:	82 8d       	ldd	r24, Z+26	; 0x1a
    43c0:	19 82       	std	Y+1, r1	; 0x01
    43c2:	88 23       	and	r24, r24
    43c4:	11 f4       	brne	.+4      	; 0x43ca <xQueueIsQueueEmptyFromISR+0x20>
    43c6:	81 e0       	ldi	r24, 0x01	; 1
    43c8:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    43ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    43cc:	0f 90       	pop	r0
    43ce:	0f 90       	pop	r0
    43d0:	0f 90       	pop	r0
    43d2:	cf 91       	pop	r28
    43d4:	df 91       	pop	r29
    43d6:	08 95       	ret

000043d8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    43d8:	df 93       	push	r29
    43da:	cf 93       	push	r28
    43dc:	00 d0       	rcall	.+0      	; 0x43de <prvIsQueueFull+0x6>
    43de:	0f 92       	push	r0
    43e0:	cd b7       	in	r28, 0x3d	; 61
    43e2:	de b7       	in	r29, 0x3e	; 62
    43e4:	9b 83       	std	Y+3, r25	; 0x03
    43e6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    43e8:	0f b6       	in	r0, 0x3f	; 63
    43ea:	f8 94       	cli
    43ec:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    43ee:	ea 81       	ldd	r30, Y+2	; 0x02
    43f0:	fb 81       	ldd	r31, Y+3	; 0x03
    43f2:	92 8d       	ldd	r25, Z+26	; 0x1a
    43f4:	ea 81       	ldd	r30, Y+2	; 0x02
    43f6:	fb 81       	ldd	r31, Y+3	; 0x03
    43f8:	83 8d       	ldd	r24, Z+27	; 0x1b
    43fa:	19 82       	std	Y+1, r1	; 0x01
    43fc:	98 17       	cp	r25, r24
    43fe:	11 f4       	brne	.+4      	; 0x4404 <prvIsQueueFull+0x2c>
    4400:	81 e0       	ldi	r24, 0x01	; 1
    4402:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    4404:	0f 90       	pop	r0
    4406:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4408:	89 81       	ldd	r24, Y+1	; 0x01
}
    440a:	0f 90       	pop	r0
    440c:	0f 90       	pop	r0
    440e:	0f 90       	pop	r0
    4410:	cf 91       	pop	r28
    4412:	df 91       	pop	r29
    4414:	08 95       	ret

00004416 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    4416:	df 93       	push	r29
    4418:	cf 93       	push	r28
    441a:	00 d0       	rcall	.+0      	; 0x441c <xQueueIsQueueFullFromISR+0x6>
    441c:	0f 92       	push	r0
    441e:	cd b7       	in	r28, 0x3d	; 61
    4420:	de b7       	in	r29, 0x3e	; 62
    4422:	9b 83       	std	Y+3, r25	; 0x03
    4424:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    4426:	ea 81       	ldd	r30, Y+2	; 0x02
    4428:	fb 81       	ldd	r31, Y+3	; 0x03
    442a:	92 8d       	ldd	r25, Z+26	; 0x1a
    442c:	ea 81       	ldd	r30, Y+2	; 0x02
    442e:	fb 81       	ldd	r31, Y+3	; 0x03
    4430:	83 8d       	ldd	r24, Z+27	; 0x1b
    4432:	19 82       	std	Y+1, r1	; 0x01
    4434:	98 17       	cp	r25, r24
    4436:	11 f4       	brne	.+4      	; 0x443c <xQueueIsQueueFullFromISR+0x26>
    4438:	81 e0       	ldi	r24, 0x01	; 1
    443a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    443c:	89 81       	ldd	r24, Y+1	; 0x01
}
    443e:	0f 90       	pop	r0
    4440:	0f 90       	pop	r0
    4442:	0f 90       	pop	r0
    4444:	cf 91       	pop	r28
    4446:	df 91       	pop	r29
    4448:	08 95       	ret

0000444a <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    444a:	af 92       	push	r10
    444c:	bf 92       	push	r11
    444e:	cf 92       	push	r12
    4450:	df 92       	push	r13
    4452:	ef 92       	push	r14
    4454:	ff 92       	push	r15
    4456:	0f 93       	push	r16
    4458:	1f 93       	push	r17
    445a:	df 93       	push	r29
    445c:	cf 93       	push	r28
    445e:	cd b7       	in	r28, 0x3d	; 61
    4460:	de b7       	in	r29, 0x3e	; 62
    4462:	64 97       	sbiw	r28, 0x14	; 20
    4464:	0f b6       	in	r0, 0x3f	; 63
    4466:	f8 94       	cli
    4468:	de bf       	out	0x3e, r29	; 62
    446a:	0f be       	out	0x3f, r0	; 63
    446c:	cd bf       	out	0x3d, r28	; 61
    446e:	9f 83       	std	Y+7, r25	; 0x07
    4470:	8e 83       	std	Y+6, r24	; 0x06
    4472:	79 87       	std	Y+9, r23	; 0x09
    4474:	68 87       	std	Y+8, r22	; 0x08
    4476:	5b 87       	std	Y+11, r21	; 0x0b
    4478:	4a 87       	std	Y+10, r20	; 0x0a
    447a:	3d 87       	std	Y+13, r19	; 0x0d
    447c:	2c 87       	std	Y+12, r18	; 0x0c
    447e:	0e 87       	std	Y+14, r16	; 0x0e
    4480:	f8 8a       	std	Y+16, r15	; 0x10
    4482:	ef 86       	std	Y+15, r14	; 0x0f
    4484:	da 8a       	std	Y+18, r13	; 0x12
    4486:	c9 8a       	std	Y+17, r12	; 0x11
    4488:	bc 8a       	std	Y+20, r11	; 0x14
    448a:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    448c:	8a 85       	ldd	r24, Y+10	; 0x0a
    448e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4490:	29 89       	ldd	r18, Y+17	; 0x11
    4492:	3a 89       	ldd	r19, Y+18	; 0x12
    4494:	b9 01       	movw	r22, r18
    4496:	0e 94 aa 28 	call	0x5154	; 0x5154 <prvAllocateTCBAndStack>
    449a:	9c 83       	std	Y+4, r25	; 0x04
    449c:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    449e:	8b 81       	ldd	r24, Y+3	; 0x03
    44a0:	9c 81       	ldd	r25, Y+4	; 0x04
    44a2:	00 97       	sbiw	r24, 0x00	; 0
    44a4:	09 f4       	brne	.+2      	; 0x44a8 <xTaskGenericCreate+0x5e>
    44a6:	99 c0       	rjmp	.+306    	; 0x45da <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    44a8:	eb 81       	ldd	r30, Y+3	; 0x03
    44aa:	fc 81       	ldd	r31, Y+4	; 0x04
    44ac:	27 89       	ldd	r18, Z+23	; 0x17
    44ae:	30 8d       	ldd	r19, Z+24	; 0x18
    44b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    44b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    44b4:	01 97       	sbiw	r24, 0x01	; 1
    44b6:	82 0f       	add	r24, r18
    44b8:	93 1f       	adc	r25, r19
    44ba:	9a 83       	std	Y+2, r25	; 0x02
    44bc:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    44be:	8b 81       	ldd	r24, Y+3	; 0x03
    44c0:	9c 81       	ldd	r25, Y+4	; 0x04
    44c2:	28 85       	ldd	r18, Y+8	; 0x08
    44c4:	39 85       	ldd	r19, Y+9	; 0x09
    44c6:	eb 89       	ldd	r30, Y+19	; 0x13
    44c8:	fc 89       	ldd	r31, Y+20	; 0x14
    44ca:	aa 85       	ldd	r26, Y+10	; 0x0a
    44cc:	bb 85       	ldd	r27, Y+11	; 0x0b
    44ce:	b9 01       	movw	r22, r18
    44d0:	4e 85       	ldd	r20, Y+14	; 0x0e
    44d2:	9f 01       	movw	r18, r30
    44d4:	8d 01       	movw	r16, r26
    44d6:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    44da:	89 81       	ldd	r24, Y+1	; 0x01
    44dc:	9a 81       	ldd	r25, Y+2	; 0x02
    44de:	2e 81       	ldd	r18, Y+6	; 0x06
    44e0:	3f 81       	ldd	r19, Y+7	; 0x07
    44e2:	4c 85       	ldd	r20, Y+12	; 0x0c
    44e4:	5d 85       	ldd	r21, Y+13	; 0x0d
    44e6:	b9 01       	movw	r22, r18
    44e8:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <pxPortInitialiseStack>
    44ec:	eb 81       	ldd	r30, Y+3	; 0x03
    44ee:	fc 81       	ldd	r31, Y+4	; 0x04
    44f0:	91 83       	std	Z+1, r25	; 0x01
    44f2:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    44f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    44f6:	98 89       	ldd	r25, Y+16	; 0x10
    44f8:	00 97       	sbiw	r24, 0x00	; 0
    44fa:	31 f0       	breq	.+12     	; 0x4508 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    44fc:	ef 85       	ldd	r30, Y+15	; 0x0f
    44fe:	f8 89       	ldd	r31, Y+16	; 0x10
    4500:	8b 81       	ldd	r24, Y+3	; 0x03
    4502:	9c 81       	ldd	r25, Y+4	; 0x04
    4504:	91 83       	std	Z+1, r25	; 0x01
    4506:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    4508:	0f b6       	in	r0, 0x3f	; 63
    450a:	f8 94       	cli
    450c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    450e:	80 91 29 06 	lds	r24, 0x0629
    4512:	8f 5f       	subi	r24, 0xFF	; 255
    4514:	80 93 29 06 	sts	0x0629, r24
			if( pxCurrentTCB == NULL )
    4518:	80 91 26 06 	lds	r24, 0x0626
    451c:	90 91 27 06 	lds	r25, 0x0627
    4520:	00 97       	sbiw	r24, 0x00	; 0
    4522:	69 f4       	brne	.+26     	; 0x453e <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4524:	8b 81       	ldd	r24, Y+3	; 0x03
    4526:	9c 81       	ldd	r25, Y+4	; 0x04
    4528:	90 93 27 06 	sts	0x0627, r25
    452c:	80 93 26 06 	sts	0x0626, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    4530:	80 91 29 06 	lds	r24, 0x0629
    4534:	81 30       	cpi	r24, 0x01	; 1
    4536:	a9 f4       	brne	.+42     	; 0x4562 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4538:	0e 94 e6 27 	call	0x4fcc	; 0x4fcc <prvInitialiseTaskLists>
    453c:	12 c0       	rjmp	.+36     	; 0x4562 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    453e:	80 91 2e 06 	lds	r24, 0x062E
    4542:	88 23       	and	r24, r24
    4544:	71 f4       	brne	.+28     	; 0x4562 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4546:	e0 91 26 06 	lds	r30, 0x0626
    454a:	f0 91 27 06 	lds	r31, 0x0627
    454e:	96 89       	ldd	r25, Z+22	; 0x16
    4550:	8e 85       	ldd	r24, Y+14	; 0x0e
    4552:	89 17       	cp	r24, r25
    4554:	30 f0       	brcs	.+12     	; 0x4562 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4556:	8b 81       	ldd	r24, Y+3	; 0x03
    4558:	9c 81       	ldd	r25, Y+4	; 0x04
    455a:	90 93 27 06 	sts	0x0627, r25
    455e:	80 93 26 06 	sts	0x0626, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    4562:	eb 81       	ldd	r30, Y+3	; 0x03
    4564:	fc 81       	ldd	r31, Y+4	; 0x04
    4566:	96 89       	ldd	r25, Z+22	; 0x16
    4568:	80 91 2c 06 	lds	r24, 0x062C
    456c:	89 17       	cp	r24, r25
    456e:	28 f4       	brcc	.+10     	; 0x457a <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    4570:	eb 81       	ldd	r30, Y+3	; 0x03
    4572:	fc 81       	ldd	r31, Y+4	; 0x04
    4574:	86 89       	ldd	r24, Z+22	; 0x16
    4576:	80 93 2c 06 	sts	0x062C, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    457a:	80 91 33 06 	lds	r24, 0x0633
    457e:	8f 5f       	subi	r24, 0xFF	; 255
    4580:	80 93 33 06 	sts	0x0633, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    4584:	eb 81       	ldd	r30, Y+3	; 0x03
    4586:	fc 81       	ldd	r31, Y+4	; 0x04
    4588:	96 89       	ldd	r25, Z+22	; 0x16
    458a:	80 91 2d 06 	lds	r24, 0x062D
    458e:	89 17       	cp	r24, r25
    4590:	28 f4       	brcc	.+10     	; 0x459c <xTaskGenericCreate+0x152>
    4592:	eb 81       	ldd	r30, Y+3	; 0x03
    4594:	fc 81       	ldd	r31, Y+4	; 0x04
    4596:	86 89       	ldd	r24, Z+22	; 0x16
    4598:	80 93 2d 06 	sts	0x062D, r24
    459c:	eb 81       	ldd	r30, Y+3	; 0x03
    459e:	fc 81       	ldd	r31, Y+4	; 0x04
    45a0:	86 89       	ldd	r24, Z+22	; 0x16
    45a2:	28 2f       	mov	r18, r24
    45a4:	30 e0       	ldi	r19, 0x00	; 0
    45a6:	c9 01       	movw	r24, r18
    45a8:	88 0f       	add	r24, r24
    45aa:	99 1f       	adc	r25, r25
    45ac:	88 0f       	add	r24, r24
    45ae:	99 1f       	adc	r25, r25
    45b0:	88 0f       	add	r24, r24
    45b2:	99 1f       	adc	r25, r25
    45b4:	82 0f       	add	r24, r18
    45b6:	93 1f       	adc	r25, r19
    45b8:	ac 01       	movw	r20, r24
    45ba:	4c 5c       	subi	r20, 0xCC	; 204
    45bc:	59 4f       	sbci	r21, 0xF9	; 249
    45be:	8b 81       	ldd	r24, Y+3	; 0x03
    45c0:	9c 81       	ldd	r25, Y+4	; 0x04
    45c2:	9c 01       	movw	r18, r24
    45c4:	2e 5f       	subi	r18, 0xFE	; 254
    45c6:	3f 4f       	sbci	r19, 0xFF	; 255
    45c8:	ca 01       	movw	r24, r20
    45ca:	b9 01       	movw	r22, r18
    45cc:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <vListInsertEnd>

			xReturn = pdPASS;
    45d0:	81 e0       	ldi	r24, 0x01	; 1
    45d2:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    45d4:	0f 90       	pop	r0
    45d6:	0f be       	out	0x3f, r0	; 63
    45d8:	02 c0       	rjmp	.+4      	; 0x45de <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    45da:	8f ef       	ldi	r24, 0xFF	; 255
    45dc:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    45de:	8d 81       	ldd	r24, Y+5	; 0x05
    45e0:	81 30       	cpi	r24, 0x01	; 1
    45e2:	71 f4       	brne	.+28     	; 0x4600 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    45e4:	80 91 2e 06 	lds	r24, 0x062E
    45e8:	88 23       	and	r24, r24
    45ea:	51 f0       	breq	.+20     	; 0x4600 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    45ec:	e0 91 26 06 	lds	r30, 0x0626
    45f0:	f0 91 27 06 	lds	r31, 0x0627
    45f4:	96 89       	ldd	r25, Z+22	; 0x16
    45f6:	8e 85       	ldd	r24, Y+14	; 0x0e
    45f8:	98 17       	cp	r25, r24
    45fa:	10 f4       	brcc	.+4      	; 0x4600 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    45fc:	0e 94 91 1c 	call	0x3922	; 0x3922 <vPortYield>
			}
		}
	}

	return xReturn;
    4600:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4602:	64 96       	adiw	r28, 0x14	; 20
    4604:	0f b6       	in	r0, 0x3f	; 63
    4606:	f8 94       	cli
    4608:	de bf       	out	0x3e, r29	; 62
    460a:	0f be       	out	0x3f, r0	; 63
    460c:	cd bf       	out	0x3d, r28	; 61
    460e:	cf 91       	pop	r28
    4610:	df 91       	pop	r29
    4612:	1f 91       	pop	r17
    4614:	0f 91       	pop	r16
    4616:	ff 90       	pop	r15
    4618:	ef 90       	pop	r14
    461a:	df 90       	pop	r13
    461c:	cf 90       	pop	r12
    461e:	bf 90       	pop	r11
    4620:	af 90       	pop	r10
    4622:	08 95       	ret

00004624 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    4624:	df 93       	push	r29
    4626:	cf 93       	push	r28
    4628:	00 d0       	rcall	.+0      	; 0x462a <vTaskDelete+0x6>
    462a:	00 d0       	rcall	.+0      	; 0x462c <vTaskDelete+0x8>
    462c:	00 d0       	rcall	.+0      	; 0x462e <vTaskDelete+0xa>
    462e:	cd b7       	in	r28, 0x3d	; 61
    4630:	de b7       	in	r29, 0x3e	; 62
    4632:	9c 83       	std	Y+4, r25	; 0x04
    4634:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    4636:	0f b6       	in	r0, 0x3f	; 63
    4638:	f8 94       	cli
    463a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    463c:	20 91 26 06 	lds	r18, 0x0626
    4640:	30 91 27 06 	lds	r19, 0x0627
    4644:	8b 81       	ldd	r24, Y+3	; 0x03
    4646:	9c 81       	ldd	r25, Y+4	; 0x04
    4648:	82 17       	cp	r24, r18
    464a:	93 07       	cpc	r25, r19
    464c:	11 f4       	brne	.+4      	; 0x4652 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    464e:	1c 82       	std	Y+4, r1	; 0x04
    4650:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    4652:	8b 81       	ldd	r24, Y+3	; 0x03
    4654:	9c 81       	ldd	r25, Y+4	; 0x04
    4656:	00 97       	sbiw	r24, 0x00	; 0
    4658:	39 f4       	brne	.+14     	; 0x4668 <vTaskDelete+0x44>
    465a:	80 91 26 06 	lds	r24, 0x0626
    465e:	90 91 27 06 	lds	r25, 0x0627
    4662:	9e 83       	std	Y+6, r25	; 0x06
    4664:	8d 83       	std	Y+5, r24	; 0x05
    4666:	04 c0       	rjmp	.+8      	; 0x4670 <vTaskDelete+0x4c>
    4668:	8b 81       	ldd	r24, Y+3	; 0x03
    466a:	9c 81       	ldd	r25, Y+4	; 0x04
    466c:	9e 83       	std	Y+6, r25	; 0x06
    466e:	8d 83       	std	Y+5, r24	; 0x05
    4670:	8d 81       	ldd	r24, Y+5	; 0x05
    4672:	9e 81       	ldd	r25, Y+6	; 0x06
    4674:	9a 83       	std	Y+2, r25	; 0x02
    4676:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    4678:	89 81       	ldd	r24, Y+1	; 0x01
    467a:	9a 81       	ldd	r25, Y+2	; 0x02
    467c:	02 96       	adiw	r24, 0x02	; 2
    467e:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    4682:	e9 81       	ldd	r30, Y+1	; 0x01
    4684:	fa 81       	ldd	r31, Y+2	; 0x02
    4686:	84 89       	ldd	r24, Z+20	; 0x14
    4688:	95 89       	ldd	r25, Z+21	; 0x15
    468a:	00 97       	sbiw	r24, 0x00	; 0
    468c:	29 f0       	breq	.+10     	; 0x4698 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    468e:	89 81       	ldd	r24, Y+1	; 0x01
    4690:	9a 81       	ldd	r25, Y+2	; 0x02
    4692:	0c 96       	adiw	r24, 0x0c	; 12
    4694:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4698:	89 81       	ldd	r24, Y+1	; 0x01
    469a:	9a 81       	ldd	r25, Y+2	; 0x02
    469c:	9c 01       	movw	r18, r24
    469e:	2e 5f       	subi	r18, 0xFE	; 254
    46a0:	3f 4f       	sbci	r19, 0xFF	; 255
    46a2:	80 e8       	ldi	r24, 0x80	; 128
    46a4:	96 e0       	ldi	r25, 0x06	; 6
    46a6:	b9 01       	movw	r22, r18
    46a8:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    46ac:	80 91 28 06 	lds	r24, 0x0628
    46b0:	8f 5f       	subi	r24, 0xFF	; 255
    46b2:	80 93 28 06 	sts	0x0628, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    46b6:	80 91 33 06 	lds	r24, 0x0633
    46ba:	8f 5f       	subi	r24, 0xFF	; 255
    46bc:	80 93 33 06 	sts	0x0633, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    46c0:	0f 90       	pop	r0
    46c2:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    46c4:	80 91 2e 06 	lds	r24, 0x062E
    46c8:	88 23       	and	r24, r24
    46ca:	31 f0       	breq	.+12     	; 0x46d8 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    46cc:	8b 81       	ldd	r24, Y+3	; 0x03
    46ce:	9c 81       	ldd	r25, Y+4	; 0x04
    46d0:	00 97       	sbiw	r24, 0x00	; 0
    46d2:	11 f4       	brne	.+4      	; 0x46d8 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    46d4:	0e 94 91 1c 	call	0x3922	; 0x3922 <vPortYield>
			}
		}
	}
    46d8:	26 96       	adiw	r28, 0x06	; 6
    46da:	0f b6       	in	r0, 0x3f	; 63
    46dc:	f8 94       	cli
    46de:	de bf       	out	0x3e, r29	; 62
    46e0:	0f be       	out	0x3f, r0	; 63
    46e2:	cd bf       	out	0x3d, r28	; 61
    46e4:	cf 91       	pop	r28
    46e6:	df 91       	pop	r29
    46e8:	08 95       	ret

000046ea <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    46ea:	df 93       	push	r29
    46ec:	cf 93       	push	r28
    46ee:	cd b7       	in	r28, 0x3d	; 61
    46f0:	de b7       	in	r29, 0x3e	; 62
    46f2:	28 97       	sbiw	r28, 0x08	; 8
    46f4:	0f b6       	in	r0, 0x3f	; 63
    46f6:	f8 94       	cli
    46f8:	de bf       	out	0x3e, r29	; 62
    46fa:	0f be       	out	0x3f, r0	; 63
    46fc:	cd bf       	out	0x3d, r28	; 61
    46fe:	9e 83       	std	Y+6, r25	; 0x06
    4700:	8d 83       	std	Y+5, r24	; 0x05
    4702:	78 87       	std	Y+8, r23	; 0x08
    4704:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    4706:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    4708:	0e 94 61 24 	call	0x48c2	; 0x48c2 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    470c:	ed 81       	ldd	r30, Y+5	; 0x05
    470e:	fe 81       	ldd	r31, Y+6	; 0x06
    4710:	20 81       	ld	r18, Z
    4712:	31 81       	ldd	r19, Z+1	; 0x01
    4714:	8f 81       	ldd	r24, Y+7	; 0x07
    4716:	98 85       	ldd	r25, Y+8	; 0x08
    4718:	82 0f       	add	r24, r18
    471a:	93 1f       	adc	r25, r19
    471c:	9c 83       	std	Y+4, r25	; 0x04
    471e:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    4720:	ed 81       	ldd	r30, Y+5	; 0x05
    4722:	fe 81       	ldd	r31, Y+6	; 0x06
    4724:	20 81       	ld	r18, Z
    4726:	31 81       	ldd	r19, Z+1	; 0x01
    4728:	80 91 2a 06 	lds	r24, 0x062A
    472c:	90 91 2b 06 	lds	r25, 0x062B
    4730:	82 17       	cp	r24, r18
    4732:	93 07       	cpc	r25, r19
    4734:	a8 f4       	brcc	.+42     	; 0x4760 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    4736:	ed 81       	ldd	r30, Y+5	; 0x05
    4738:	fe 81       	ldd	r31, Y+6	; 0x06
    473a:	20 81       	ld	r18, Z
    473c:	31 81       	ldd	r19, Z+1	; 0x01
    473e:	8b 81       	ldd	r24, Y+3	; 0x03
    4740:	9c 81       	ldd	r25, Y+4	; 0x04
    4742:	82 17       	cp	r24, r18
    4744:	93 07       	cpc	r25, r19
    4746:	00 f5       	brcc	.+64     	; 0x4788 <vTaskDelayUntil+0x9e>
    4748:	20 91 2a 06 	lds	r18, 0x062A
    474c:	30 91 2b 06 	lds	r19, 0x062B
    4750:	8b 81       	ldd	r24, Y+3	; 0x03
    4752:	9c 81       	ldd	r25, Y+4	; 0x04
    4754:	28 17       	cp	r18, r24
    4756:	39 07       	cpc	r19, r25
    4758:	b8 f4       	brcc	.+46     	; 0x4788 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    475a:	81 e0       	ldi	r24, 0x01	; 1
    475c:	89 83       	std	Y+1, r24	; 0x01
    475e:	14 c0       	rjmp	.+40     	; 0x4788 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    4760:	ed 81       	ldd	r30, Y+5	; 0x05
    4762:	fe 81       	ldd	r31, Y+6	; 0x06
    4764:	20 81       	ld	r18, Z
    4766:	31 81       	ldd	r19, Z+1	; 0x01
    4768:	8b 81       	ldd	r24, Y+3	; 0x03
    476a:	9c 81       	ldd	r25, Y+4	; 0x04
    476c:	82 17       	cp	r24, r18
    476e:	93 07       	cpc	r25, r19
    4770:	48 f0       	brcs	.+18     	; 0x4784 <vTaskDelayUntil+0x9a>
    4772:	20 91 2a 06 	lds	r18, 0x062A
    4776:	30 91 2b 06 	lds	r19, 0x062B
    477a:	8b 81       	ldd	r24, Y+3	; 0x03
    477c:	9c 81       	ldd	r25, Y+4	; 0x04
    477e:	28 17       	cp	r18, r24
    4780:	39 07       	cpc	r19, r25
    4782:	10 f4       	brcc	.+4      	; 0x4788 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4784:	81 e0       	ldi	r24, 0x01	; 1
    4786:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4788:	ed 81       	ldd	r30, Y+5	; 0x05
    478a:	fe 81       	ldd	r31, Y+6	; 0x06
    478c:	8b 81       	ldd	r24, Y+3	; 0x03
    478e:	9c 81       	ldd	r25, Y+4	; 0x04
    4790:	91 83       	std	Z+1, r25	; 0x01
    4792:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4794:	89 81       	ldd	r24, Y+1	; 0x01
    4796:	88 23       	and	r24, r24
    4798:	59 f0       	breq	.+22     	; 0x47b0 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    479a:	80 91 26 06 	lds	r24, 0x0626
    479e:	90 91 27 06 	lds	r25, 0x0627
    47a2:	02 96       	adiw	r24, 0x02	; 2
    47a4:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    47a8:	8b 81       	ldd	r24, Y+3	; 0x03
    47aa:	9c 81       	ldd	r25, Y+4	; 0x04
    47ac:	0e 94 61 28 	call	0x50c2	; 0x50c2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    47b0:	0e 94 6d 24 	call	0x48da	; 0x48da <xTaskResumeAll>
    47b4:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    47b6:	8a 81       	ldd	r24, Y+2	; 0x02
    47b8:	88 23       	and	r24, r24
    47ba:	11 f4       	brne	.+4      	; 0x47c0 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    47bc:	0e 94 91 1c 	call	0x3922	; 0x3922 <vPortYield>
		}
	}
    47c0:	28 96       	adiw	r28, 0x08	; 8
    47c2:	0f b6       	in	r0, 0x3f	; 63
    47c4:	f8 94       	cli
    47c6:	de bf       	out	0x3e, r29	; 62
    47c8:	0f be       	out	0x3f, r0	; 63
    47ca:	cd bf       	out	0x3d, r28	; 61
    47cc:	cf 91       	pop	r28
    47ce:	df 91       	pop	r29
    47d0:	08 95       	ret

000047d2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    47d2:	df 93       	push	r29
    47d4:	cf 93       	push	r28
    47d6:	00 d0       	rcall	.+0      	; 0x47d8 <vTaskDelay+0x6>
    47d8:	00 d0       	rcall	.+0      	; 0x47da <vTaskDelay+0x8>
    47da:	0f 92       	push	r0
    47dc:	cd b7       	in	r28, 0x3d	; 61
    47de:	de b7       	in	r29, 0x3e	; 62
    47e0:	9d 83       	std	Y+5, r25	; 0x05
    47e2:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    47e4:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    47e6:	8c 81       	ldd	r24, Y+4	; 0x04
    47e8:	9d 81       	ldd	r25, Y+5	; 0x05
    47ea:	00 97       	sbiw	r24, 0x00	; 0
    47ec:	d1 f0       	breq	.+52     	; 0x4822 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    47ee:	0e 94 61 24 	call	0x48c2	; 0x48c2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    47f2:	20 91 2a 06 	lds	r18, 0x062A
    47f6:	30 91 2b 06 	lds	r19, 0x062B
    47fa:	8c 81       	ldd	r24, Y+4	; 0x04
    47fc:	9d 81       	ldd	r25, Y+5	; 0x05
    47fe:	82 0f       	add	r24, r18
    4800:	93 1f       	adc	r25, r19
    4802:	9b 83       	std	Y+3, r25	; 0x03
    4804:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4806:	80 91 26 06 	lds	r24, 0x0626
    480a:	90 91 27 06 	lds	r25, 0x0627
    480e:	02 96       	adiw	r24, 0x02	; 2
    4810:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4814:	8a 81       	ldd	r24, Y+2	; 0x02
    4816:	9b 81       	ldd	r25, Y+3	; 0x03
    4818:	0e 94 61 28 	call	0x50c2	; 0x50c2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    481c:	0e 94 6d 24 	call	0x48da	; 0x48da <xTaskResumeAll>
    4820:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4822:	89 81       	ldd	r24, Y+1	; 0x01
    4824:	88 23       	and	r24, r24
    4826:	11 f4       	brne	.+4      	; 0x482c <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4828:	0e 94 91 1c 	call	0x3922	; 0x3922 <vPortYield>
		}
	}
    482c:	0f 90       	pop	r0
    482e:	0f 90       	pop	r0
    4830:	0f 90       	pop	r0
    4832:	0f 90       	pop	r0
    4834:	0f 90       	pop	r0
    4836:	cf 91       	pop	r28
    4838:	df 91       	pop	r29
    483a:	08 95       	ret

0000483c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    483c:	af 92       	push	r10
    483e:	bf 92       	push	r11
    4840:	cf 92       	push	r12
    4842:	df 92       	push	r13
    4844:	ef 92       	push	r14
    4846:	ff 92       	push	r15
    4848:	0f 93       	push	r16
    484a:	df 93       	push	r29
    484c:	cf 93       	push	r28
    484e:	0f 92       	push	r0
    4850:	cd b7       	in	r28, 0x3d	; 61
    4852:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    4854:	25 e0       	ldi	r18, 0x05	; 5
    4856:	31 e0       	ldi	r19, 0x01	; 1
    4858:	85 e8       	ldi	r24, 0x85	; 133
    485a:	97 e2       	ldi	r25, 0x27	; 39
    485c:	b9 01       	movw	r22, r18
    485e:	46 e9       	ldi	r20, 0x96	; 150
    4860:	50 e0       	ldi	r21, 0x00	; 0
    4862:	20 e0       	ldi	r18, 0x00	; 0
    4864:	30 e0       	ldi	r19, 0x00	; 0
    4866:	00 e0       	ldi	r16, 0x00	; 0
    4868:	ee 24       	eor	r14, r14
    486a:	ff 24       	eor	r15, r15
    486c:	cc 24       	eor	r12, r12
    486e:	dd 24       	eor	r13, r13
    4870:	aa 24       	eor	r10, r10
    4872:	bb 24       	eor	r11, r11
    4874:	0e 94 25 22 	call	0x444a	; 0x444a <xTaskGenericCreate>
    4878:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    487a:	89 81       	ldd	r24, Y+1	; 0x01
    487c:	81 30       	cpi	r24, 0x01	; 1
    487e:	51 f4       	brne	.+20     	; 0x4894 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    4880:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    4882:	81 e0       	ldi	r24, 0x01	; 1
    4884:	80 93 2e 06 	sts	0x062E, r24
		xTickCount = ( portTickType ) 0U;
    4888:	10 92 2b 06 	sts	0x062B, r1
    488c:	10 92 2a 06 	sts	0x062A, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4890:	0e 94 55 1c 	call	0x38aa	; 0x38aa <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    4894:	0f 90       	pop	r0
    4896:	cf 91       	pop	r28
    4898:	df 91       	pop	r29
    489a:	0f 91       	pop	r16
    489c:	ff 90       	pop	r15
    489e:	ef 90       	pop	r14
    48a0:	df 90       	pop	r13
    48a2:	cf 90       	pop	r12
    48a4:	bf 90       	pop	r11
    48a6:	af 90       	pop	r10
    48a8:	08 95       	ret

000048aa <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    48aa:	df 93       	push	r29
    48ac:	cf 93       	push	r28
    48ae:	cd b7       	in	r28, 0x3d	; 61
    48b0:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    48b2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    48b4:	10 92 2e 06 	sts	0x062E, r1
	vPortEndScheduler();
    48b8:	0e 94 8a 1c 	call	0x3914	; 0x3914 <vPortEndScheduler>
}
    48bc:	cf 91       	pop	r28
    48be:	df 91       	pop	r29
    48c0:	08 95       	ret

000048c2 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    48c2:	df 93       	push	r29
    48c4:	cf 93       	push	r28
    48c6:	cd b7       	in	r28, 0x3d	; 61
    48c8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    48ca:	80 91 2f 06 	lds	r24, 0x062F
    48ce:	8f 5f       	subi	r24, 0xFF	; 255
    48d0:	80 93 2f 06 	sts	0x062F, r24
}
    48d4:	cf 91       	pop	r28
    48d6:	df 91       	pop	r29
    48d8:	08 95       	ret

000048da <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    48da:	df 93       	push	r29
    48dc:	cf 93       	push	r28
    48de:	00 d0       	rcall	.+0      	; 0x48e0 <xTaskResumeAll+0x6>
    48e0:	00 d0       	rcall	.+0      	; 0x48e2 <xTaskResumeAll+0x8>
    48e2:	cd b7       	in	r28, 0x3d	; 61
    48e4:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    48e6:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    48e8:	0f b6       	in	r0, 0x3f	; 63
    48ea:	f8 94       	cli
    48ec:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    48ee:	80 91 2f 06 	lds	r24, 0x062F
    48f2:	81 50       	subi	r24, 0x01	; 1
    48f4:	80 93 2f 06 	sts	0x062F, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    48f8:	80 91 2f 06 	lds	r24, 0x062F
    48fc:	88 23       	and	r24, r24
    48fe:	09 f0       	breq	.+2      	; 0x4902 <xTaskResumeAll+0x28>
    4900:	6c c0       	rjmp	.+216    	; 0x49da <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    4902:	80 91 29 06 	lds	r24, 0x0629
    4906:	88 23       	and	r24, r24
    4908:	09 f4       	brne	.+2      	; 0x490c <xTaskResumeAll+0x32>
    490a:	67 c0       	rjmp	.+206    	; 0x49da <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    490c:	19 82       	std	Y+1, r1	; 0x01
    490e:	41 c0       	rjmp	.+130    	; 0x4992 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    4910:	e0 91 7c 06 	lds	r30, 0x067C
    4914:	f0 91 7d 06 	lds	r31, 0x067D
    4918:	86 81       	ldd	r24, Z+6	; 0x06
    491a:	97 81       	ldd	r25, Z+7	; 0x07
    491c:	9c 83       	std	Y+4, r25	; 0x04
    491e:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    4920:	8b 81       	ldd	r24, Y+3	; 0x03
    4922:	9c 81       	ldd	r25, Y+4	; 0x04
    4924:	0c 96       	adiw	r24, 0x0c	; 12
    4926:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    492a:	8b 81       	ldd	r24, Y+3	; 0x03
    492c:	9c 81       	ldd	r25, Y+4	; 0x04
    492e:	02 96       	adiw	r24, 0x02	; 2
    4930:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    4934:	eb 81       	ldd	r30, Y+3	; 0x03
    4936:	fc 81       	ldd	r31, Y+4	; 0x04
    4938:	96 89       	ldd	r25, Z+22	; 0x16
    493a:	80 91 2d 06 	lds	r24, 0x062D
    493e:	89 17       	cp	r24, r25
    4940:	28 f4       	brcc	.+10     	; 0x494c <xTaskResumeAll+0x72>
    4942:	eb 81       	ldd	r30, Y+3	; 0x03
    4944:	fc 81       	ldd	r31, Y+4	; 0x04
    4946:	86 89       	ldd	r24, Z+22	; 0x16
    4948:	80 93 2d 06 	sts	0x062D, r24
    494c:	eb 81       	ldd	r30, Y+3	; 0x03
    494e:	fc 81       	ldd	r31, Y+4	; 0x04
    4950:	86 89       	ldd	r24, Z+22	; 0x16
    4952:	28 2f       	mov	r18, r24
    4954:	30 e0       	ldi	r19, 0x00	; 0
    4956:	c9 01       	movw	r24, r18
    4958:	88 0f       	add	r24, r24
    495a:	99 1f       	adc	r25, r25
    495c:	88 0f       	add	r24, r24
    495e:	99 1f       	adc	r25, r25
    4960:	88 0f       	add	r24, r24
    4962:	99 1f       	adc	r25, r25
    4964:	82 0f       	add	r24, r18
    4966:	93 1f       	adc	r25, r19
    4968:	8c 5c       	subi	r24, 0xCC	; 204
    496a:	99 4f       	sbci	r25, 0xF9	; 249
    496c:	2b 81       	ldd	r18, Y+3	; 0x03
    496e:	3c 81       	ldd	r19, Y+4	; 0x04
    4970:	2e 5f       	subi	r18, 0xFE	; 254
    4972:	3f 4f       	sbci	r19, 0xFF	; 255
    4974:	b9 01       	movw	r22, r18
    4976:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    497a:	eb 81       	ldd	r30, Y+3	; 0x03
    497c:	fc 81       	ldd	r31, Y+4	; 0x04
    497e:	96 89       	ldd	r25, Z+22	; 0x16
    4980:	e0 91 26 06 	lds	r30, 0x0626
    4984:	f0 91 27 06 	lds	r31, 0x0627
    4988:	86 89       	ldd	r24, Z+22	; 0x16
    498a:	98 17       	cp	r25, r24
    498c:	10 f0       	brcs	.+4      	; 0x4992 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    498e:	81 e0       	ldi	r24, 0x01	; 1
    4990:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    4992:	80 91 77 06 	lds	r24, 0x0677
    4996:	88 23       	and	r24, r24
    4998:	09 f0       	breq	.+2      	; 0x499c <xTaskResumeAll+0xc2>
    499a:	ba cf       	rjmp	.-140    	; 0x4910 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    499c:	80 91 30 06 	lds	r24, 0x0630
    49a0:	88 23       	and	r24, r24
    49a2:	71 f0       	breq	.+28     	; 0x49c0 <xTaskResumeAll+0xe6>
    49a4:	07 c0       	rjmp	.+14     	; 0x49b4 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    49a6:	0e 94 2c 25 	call	0x4a58	; 0x4a58 <vTaskIncrementTick>
						--uxMissedTicks;
    49aa:	80 91 30 06 	lds	r24, 0x0630
    49ae:	81 50       	subi	r24, 0x01	; 1
    49b0:	80 93 30 06 	sts	0x0630, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    49b4:	80 91 30 06 	lds	r24, 0x0630
    49b8:	88 23       	and	r24, r24
    49ba:	a9 f7       	brne	.-22     	; 0x49a6 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    49bc:	81 e0       	ldi	r24, 0x01	; 1
    49be:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    49c0:	89 81       	ldd	r24, Y+1	; 0x01
    49c2:	81 30       	cpi	r24, 0x01	; 1
    49c4:	21 f0       	breq	.+8      	; 0x49ce <xTaskResumeAll+0xf4>
    49c6:	80 91 31 06 	lds	r24, 0x0631
    49ca:	81 30       	cpi	r24, 0x01	; 1
    49cc:	31 f4       	brne	.+12     	; 0x49da <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    49ce:	81 e0       	ldi	r24, 0x01	; 1
    49d0:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    49d2:	10 92 31 06 	sts	0x0631, r1
					portYIELD_WITHIN_API();
    49d6:	0e 94 91 1c 	call	0x3922	; 0x3922 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    49da:	0f 90       	pop	r0
    49dc:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    49de:	8a 81       	ldd	r24, Y+2	; 0x02
}
    49e0:	0f 90       	pop	r0
    49e2:	0f 90       	pop	r0
    49e4:	0f 90       	pop	r0
    49e6:	0f 90       	pop	r0
    49e8:	cf 91       	pop	r28
    49ea:	df 91       	pop	r29
    49ec:	08 95       	ret

000049ee <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    49ee:	df 93       	push	r29
    49f0:	cf 93       	push	r28
    49f2:	00 d0       	rcall	.+0      	; 0x49f4 <xTaskGetTickCount+0x6>
    49f4:	cd b7       	in	r28, 0x3d	; 61
    49f6:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    49f8:	0f b6       	in	r0, 0x3f	; 63
    49fa:	f8 94       	cli
    49fc:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    49fe:	80 91 2a 06 	lds	r24, 0x062A
    4a02:	90 91 2b 06 	lds	r25, 0x062B
    4a06:	9a 83       	std	Y+2, r25	; 0x02
    4a08:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4a0a:	0f 90       	pop	r0
    4a0c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4a0e:	89 81       	ldd	r24, Y+1	; 0x01
    4a10:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4a12:	0f 90       	pop	r0
    4a14:	0f 90       	pop	r0
    4a16:	cf 91       	pop	r28
    4a18:	df 91       	pop	r29
    4a1a:	08 95       	ret

00004a1c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    4a1c:	df 93       	push	r29
    4a1e:	cf 93       	push	r28
    4a20:	00 d0       	rcall	.+0      	; 0x4a22 <xTaskGetTickCountFromISR+0x6>
    4a22:	0f 92       	push	r0
    4a24:	cd b7       	in	r28, 0x3d	; 61
    4a26:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4a28:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    4a2a:	80 91 2a 06 	lds	r24, 0x062A
    4a2e:	90 91 2b 06 	lds	r25, 0x062B
    4a32:	9b 83       	std	Y+3, r25	; 0x03
    4a34:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4a36:	8a 81       	ldd	r24, Y+2	; 0x02
    4a38:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4a3a:	0f 90       	pop	r0
    4a3c:	0f 90       	pop	r0
    4a3e:	0f 90       	pop	r0
    4a40:	cf 91       	pop	r28
    4a42:	df 91       	pop	r29
    4a44:	08 95       	ret

00004a46 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4a46:	df 93       	push	r29
    4a48:	cf 93       	push	r28
    4a4a:	cd b7       	in	r28, 0x3d	; 61
    4a4c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    4a4e:	80 91 29 06 	lds	r24, 0x0629
}
    4a52:	cf 91       	pop	r28
    4a54:	df 91       	pop	r29
    4a56:	08 95       	ret

00004a58 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4a58:	df 93       	push	r29
    4a5a:	cf 93       	push	r28
    4a5c:	00 d0       	rcall	.+0      	; 0x4a5e <vTaskIncrementTick+0x6>
    4a5e:	00 d0       	rcall	.+0      	; 0x4a60 <vTaskIncrementTick+0x8>
    4a60:	00 d0       	rcall	.+0      	; 0x4a62 <vTaskIncrementTick+0xa>
    4a62:	cd b7       	in	r28, 0x3d	; 61
    4a64:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4a66:	80 91 2f 06 	lds	r24, 0x062F
    4a6a:	88 23       	and	r24, r24
    4a6c:	09 f0       	breq	.+2      	; 0x4a70 <vTaskIncrementTick+0x18>
    4a6e:	bb c0       	rjmp	.+374    	; 0x4be6 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    4a70:	80 91 2a 06 	lds	r24, 0x062A
    4a74:	90 91 2b 06 	lds	r25, 0x062B
    4a78:	01 96       	adiw	r24, 0x01	; 1
    4a7a:	90 93 2b 06 	sts	0x062B, r25
    4a7e:	80 93 2a 06 	sts	0x062A, r24
		if( xTickCount == ( portTickType ) 0U )
    4a82:	80 91 2a 06 	lds	r24, 0x062A
    4a86:	90 91 2b 06 	lds	r25, 0x062B
    4a8a:	00 97       	sbiw	r24, 0x00	; 0
    4a8c:	d1 f5       	brne	.+116    	; 0x4b02 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    4a8e:	80 91 73 06 	lds	r24, 0x0673
    4a92:	90 91 74 06 	lds	r25, 0x0674
    4a96:	9c 83       	std	Y+4, r25	; 0x04
    4a98:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    4a9a:	80 91 75 06 	lds	r24, 0x0675
    4a9e:	90 91 76 06 	lds	r25, 0x0676
    4aa2:	90 93 74 06 	sts	0x0674, r25
    4aa6:	80 93 73 06 	sts	0x0673, r24
			pxOverflowDelayedTaskList = pxTemp;
    4aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    4aac:	9c 81       	ldd	r25, Y+4	; 0x04
    4aae:	90 93 76 06 	sts	0x0676, r25
    4ab2:	80 93 75 06 	sts	0x0675, r24
			xNumOfOverflows++;
    4ab6:	80 91 32 06 	lds	r24, 0x0632
    4aba:	8f 5f       	subi	r24, 0xFF	; 255
    4abc:	80 93 32 06 	sts	0x0632, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4ac0:	e0 91 73 06 	lds	r30, 0x0673
    4ac4:	f0 91 74 06 	lds	r31, 0x0674
    4ac8:	80 81       	ld	r24, Z
    4aca:	88 23       	and	r24, r24
    4acc:	39 f4       	brne	.+14     	; 0x4adc <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    4ace:	8f ef       	ldi	r24, 0xFF	; 255
    4ad0:	9f ef       	ldi	r25, 0xFF	; 255
    4ad2:	90 93 26 01 	sts	0x0126, r25
    4ad6:	80 93 25 01 	sts	0x0125, r24
    4ada:	13 c0       	rjmp	.+38     	; 0x4b02 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4adc:	e0 91 73 06 	lds	r30, 0x0673
    4ae0:	f0 91 74 06 	lds	r31, 0x0674
    4ae4:	05 80       	ldd	r0, Z+5	; 0x05
    4ae6:	f6 81       	ldd	r31, Z+6	; 0x06
    4ae8:	e0 2d       	mov	r30, r0
    4aea:	86 81       	ldd	r24, Z+6	; 0x06
    4aec:	97 81       	ldd	r25, Z+7	; 0x07
    4aee:	9e 83       	std	Y+6, r25	; 0x06
    4af0:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    4af2:	ed 81       	ldd	r30, Y+5	; 0x05
    4af4:	fe 81       	ldd	r31, Y+6	; 0x06
    4af6:	82 81       	ldd	r24, Z+2	; 0x02
    4af8:	93 81       	ldd	r25, Z+3	; 0x03
    4afa:	90 93 26 01 	sts	0x0126, r25
    4afe:	80 93 25 01 	sts	0x0125, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    4b02:	20 91 2a 06 	lds	r18, 0x062A
    4b06:	30 91 2b 06 	lds	r19, 0x062B
    4b0a:	80 91 25 01 	lds	r24, 0x0125
    4b0e:	90 91 26 01 	lds	r25, 0x0126
    4b12:	28 17       	cp	r18, r24
    4b14:	39 07       	cpc	r19, r25
    4b16:	08 f4       	brcc	.+2      	; 0x4b1a <vTaskIncrementTick+0xc2>
    4b18:	6b c0       	rjmp	.+214    	; 0x4bf0 <vTaskIncrementTick+0x198>
    4b1a:	e0 91 73 06 	lds	r30, 0x0673
    4b1e:	f0 91 74 06 	lds	r31, 0x0674
    4b22:	80 81       	ld	r24, Z
    4b24:	88 23       	and	r24, r24
    4b26:	39 f4       	brne	.+14     	; 0x4b36 <vTaskIncrementTick+0xde>
    4b28:	8f ef       	ldi	r24, 0xFF	; 255
    4b2a:	9f ef       	ldi	r25, 0xFF	; 255
    4b2c:	90 93 26 01 	sts	0x0126, r25
    4b30:	80 93 25 01 	sts	0x0125, r24
    4b34:	5d c0       	rjmp	.+186    	; 0x4bf0 <vTaskIncrementTick+0x198>
    4b36:	e0 91 73 06 	lds	r30, 0x0673
    4b3a:	f0 91 74 06 	lds	r31, 0x0674
    4b3e:	05 80       	ldd	r0, Z+5	; 0x05
    4b40:	f6 81       	ldd	r31, Z+6	; 0x06
    4b42:	e0 2d       	mov	r30, r0
    4b44:	86 81       	ldd	r24, Z+6	; 0x06
    4b46:	97 81       	ldd	r25, Z+7	; 0x07
    4b48:	9e 83       	std	Y+6, r25	; 0x06
    4b4a:	8d 83       	std	Y+5, r24	; 0x05
    4b4c:	ed 81       	ldd	r30, Y+5	; 0x05
    4b4e:	fe 81       	ldd	r31, Y+6	; 0x06
    4b50:	82 81       	ldd	r24, Z+2	; 0x02
    4b52:	93 81       	ldd	r25, Z+3	; 0x03
    4b54:	9a 83       	std	Y+2, r25	; 0x02
    4b56:	89 83       	std	Y+1, r24	; 0x01
    4b58:	20 91 2a 06 	lds	r18, 0x062A
    4b5c:	30 91 2b 06 	lds	r19, 0x062B
    4b60:	89 81       	ldd	r24, Y+1	; 0x01
    4b62:	9a 81       	ldd	r25, Y+2	; 0x02
    4b64:	28 17       	cp	r18, r24
    4b66:	39 07       	cpc	r19, r25
    4b68:	38 f4       	brcc	.+14     	; 0x4b78 <vTaskIncrementTick+0x120>
    4b6a:	89 81       	ldd	r24, Y+1	; 0x01
    4b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    4b6e:	90 93 26 01 	sts	0x0126, r25
    4b72:	80 93 25 01 	sts	0x0125, r24
    4b76:	3c c0       	rjmp	.+120    	; 0x4bf0 <vTaskIncrementTick+0x198>
    4b78:	8d 81       	ldd	r24, Y+5	; 0x05
    4b7a:	9e 81       	ldd	r25, Y+6	; 0x06
    4b7c:	02 96       	adiw	r24, 0x02	; 2
    4b7e:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
    4b82:	ed 81       	ldd	r30, Y+5	; 0x05
    4b84:	fe 81       	ldd	r31, Y+6	; 0x06
    4b86:	84 89       	ldd	r24, Z+20	; 0x14
    4b88:	95 89       	ldd	r25, Z+21	; 0x15
    4b8a:	00 97       	sbiw	r24, 0x00	; 0
    4b8c:	29 f0       	breq	.+10     	; 0x4b98 <vTaskIncrementTick+0x140>
    4b8e:	8d 81       	ldd	r24, Y+5	; 0x05
    4b90:	9e 81       	ldd	r25, Y+6	; 0x06
    4b92:	0c 96       	adiw	r24, 0x0c	; 12
    4b94:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
    4b98:	ed 81       	ldd	r30, Y+5	; 0x05
    4b9a:	fe 81       	ldd	r31, Y+6	; 0x06
    4b9c:	96 89       	ldd	r25, Z+22	; 0x16
    4b9e:	80 91 2d 06 	lds	r24, 0x062D
    4ba2:	89 17       	cp	r24, r25
    4ba4:	28 f4       	brcc	.+10     	; 0x4bb0 <vTaskIncrementTick+0x158>
    4ba6:	ed 81       	ldd	r30, Y+5	; 0x05
    4ba8:	fe 81       	ldd	r31, Y+6	; 0x06
    4baa:	86 89       	ldd	r24, Z+22	; 0x16
    4bac:	80 93 2d 06 	sts	0x062D, r24
    4bb0:	ed 81       	ldd	r30, Y+5	; 0x05
    4bb2:	fe 81       	ldd	r31, Y+6	; 0x06
    4bb4:	86 89       	ldd	r24, Z+22	; 0x16
    4bb6:	28 2f       	mov	r18, r24
    4bb8:	30 e0       	ldi	r19, 0x00	; 0
    4bba:	c9 01       	movw	r24, r18
    4bbc:	88 0f       	add	r24, r24
    4bbe:	99 1f       	adc	r25, r25
    4bc0:	88 0f       	add	r24, r24
    4bc2:	99 1f       	adc	r25, r25
    4bc4:	88 0f       	add	r24, r24
    4bc6:	99 1f       	adc	r25, r25
    4bc8:	82 0f       	add	r24, r18
    4bca:	93 1f       	adc	r25, r19
    4bcc:	ac 01       	movw	r20, r24
    4bce:	4c 5c       	subi	r20, 0xCC	; 204
    4bd0:	59 4f       	sbci	r21, 0xF9	; 249
    4bd2:	8d 81       	ldd	r24, Y+5	; 0x05
    4bd4:	9e 81       	ldd	r25, Y+6	; 0x06
    4bd6:	9c 01       	movw	r18, r24
    4bd8:	2e 5f       	subi	r18, 0xFE	; 254
    4bda:	3f 4f       	sbci	r19, 0xFF	; 255
    4bdc:	ca 01       	movw	r24, r20
    4bde:	b9 01       	movw	r22, r18
    4be0:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <vListInsertEnd>
    4be4:	9a cf       	rjmp	.-204    	; 0x4b1a <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    4be6:	80 91 30 06 	lds	r24, 0x0630
    4bea:	8f 5f       	subi	r24, 0xFF	; 255
    4bec:	80 93 30 06 	sts	0x0630, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    4bf0:	26 96       	adiw	r28, 0x06	; 6
    4bf2:	0f b6       	in	r0, 0x3f	; 63
    4bf4:	f8 94       	cli
    4bf6:	de bf       	out	0x3e, r29	; 62
    4bf8:	0f be       	out	0x3f, r0	; 63
    4bfa:	cd bf       	out	0x3d, r28	; 61
    4bfc:	cf 91       	pop	r28
    4bfe:	df 91       	pop	r29
    4c00:	08 95       	ret

00004c02 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4c02:	df 93       	push	r29
    4c04:	cf 93       	push	r28
    4c06:	00 d0       	rcall	.+0      	; 0x4c08 <vTaskSwitchContext+0x6>
    4c08:	cd b7       	in	r28, 0x3d	; 61
    4c0a:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    4c0c:	80 91 2f 06 	lds	r24, 0x062F
    4c10:	88 23       	and	r24, r24
    4c12:	49 f0       	breq	.+18     	; 0x4c26 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    4c14:	81 e0       	ldi	r24, 0x01	; 1
    4c16:	80 93 31 06 	sts	0x0631, r24
    4c1a:	54 c0       	rjmp	.+168    	; 0x4cc4 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    4c1c:	80 91 2d 06 	lds	r24, 0x062D
    4c20:	81 50       	subi	r24, 0x01	; 1
    4c22:	80 93 2d 06 	sts	0x062D, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    4c26:	80 91 2d 06 	lds	r24, 0x062D
    4c2a:	28 2f       	mov	r18, r24
    4c2c:	30 e0       	ldi	r19, 0x00	; 0
    4c2e:	c9 01       	movw	r24, r18
    4c30:	88 0f       	add	r24, r24
    4c32:	99 1f       	adc	r25, r25
    4c34:	88 0f       	add	r24, r24
    4c36:	99 1f       	adc	r25, r25
    4c38:	88 0f       	add	r24, r24
    4c3a:	99 1f       	adc	r25, r25
    4c3c:	82 0f       	add	r24, r18
    4c3e:	93 1f       	adc	r25, r19
    4c40:	fc 01       	movw	r30, r24
    4c42:	ec 5c       	subi	r30, 0xCC	; 204
    4c44:	f9 4f       	sbci	r31, 0xF9	; 249
    4c46:	80 81       	ld	r24, Z
    4c48:	88 23       	and	r24, r24
    4c4a:	41 f3       	breq	.-48     	; 0x4c1c <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    4c4c:	80 91 2d 06 	lds	r24, 0x062D
    4c50:	28 2f       	mov	r18, r24
    4c52:	30 e0       	ldi	r19, 0x00	; 0
    4c54:	c9 01       	movw	r24, r18
    4c56:	88 0f       	add	r24, r24
    4c58:	99 1f       	adc	r25, r25
    4c5a:	88 0f       	add	r24, r24
    4c5c:	99 1f       	adc	r25, r25
    4c5e:	88 0f       	add	r24, r24
    4c60:	99 1f       	adc	r25, r25
    4c62:	82 0f       	add	r24, r18
    4c64:	93 1f       	adc	r25, r19
    4c66:	8c 5c       	subi	r24, 0xCC	; 204
    4c68:	99 4f       	sbci	r25, 0xF9	; 249
    4c6a:	9a 83       	std	Y+2, r25	; 0x02
    4c6c:	89 83       	std	Y+1, r24	; 0x01
    4c6e:	e9 81       	ldd	r30, Y+1	; 0x01
    4c70:	fa 81       	ldd	r31, Y+2	; 0x02
    4c72:	01 80       	ldd	r0, Z+1	; 0x01
    4c74:	f2 81       	ldd	r31, Z+2	; 0x02
    4c76:	e0 2d       	mov	r30, r0
    4c78:	82 81       	ldd	r24, Z+2	; 0x02
    4c7a:	93 81       	ldd	r25, Z+3	; 0x03
    4c7c:	e9 81       	ldd	r30, Y+1	; 0x01
    4c7e:	fa 81       	ldd	r31, Y+2	; 0x02
    4c80:	92 83       	std	Z+2, r25	; 0x02
    4c82:	81 83       	std	Z+1, r24	; 0x01
    4c84:	e9 81       	ldd	r30, Y+1	; 0x01
    4c86:	fa 81       	ldd	r31, Y+2	; 0x02
    4c88:	21 81       	ldd	r18, Z+1	; 0x01
    4c8a:	32 81       	ldd	r19, Z+2	; 0x02
    4c8c:	89 81       	ldd	r24, Y+1	; 0x01
    4c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    4c90:	03 96       	adiw	r24, 0x03	; 3
    4c92:	28 17       	cp	r18, r24
    4c94:	39 07       	cpc	r19, r25
    4c96:	59 f4       	brne	.+22     	; 0x4cae <vTaskSwitchContext+0xac>
    4c98:	e9 81       	ldd	r30, Y+1	; 0x01
    4c9a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c9c:	01 80       	ldd	r0, Z+1	; 0x01
    4c9e:	f2 81       	ldd	r31, Z+2	; 0x02
    4ca0:	e0 2d       	mov	r30, r0
    4ca2:	82 81       	ldd	r24, Z+2	; 0x02
    4ca4:	93 81       	ldd	r25, Z+3	; 0x03
    4ca6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ca8:	fa 81       	ldd	r31, Y+2	; 0x02
    4caa:	92 83       	std	Z+2, r25	; 0x02
    4cac:	81 83       	std	Z+1, r24	; 0x01
    4cae:	e9 81       	ldd	r30, Y+1	; 0x01
    4cb0:	fa 81       	ldd	r31, Y+2	; 0x02
    4cb2:	01 80       	ldd	r0, Z+1	; 0x01
    4cb4:	f2 81       	ldd	r31, Z+2	; 0x02
    4cb6:	e0 2d       	mov	r30, r0
    4cb8:	86 81       	ldd	r24, Z+6	; 0x06
    4cba:	97 81       	ldd	r25, Z+7	; 0x07
    4cbc:	90 93 27 06 	sts	0x0627, r25
    4cc0:	80 93 26 06 	sts	0x0626, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    4cc4:	0f 90       	pop	r0
    4cc6:	0f 90       	pop	r0
    4cc8:	cf 91       	pop	r28
    4cca:	df 91       	pop	r29
    4ccc:	08 95       	ret

00004cce <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    4cce:	df 93       	push	r29
    4cd0:	cf 93       	push	r28
    4cd2:	00 d0       	rcall	.+0      	; 0x4cd4 <vTaskPlaceOnEventList+0x6>
    4cd4:	00 d0       	rcall	.+0      	; 0x4cd6 <vTaskPlaceOnEventList+0x8>
    4cd6:	00 d0       	rcall	.+0      	; 0x4cd8 <vTaskPlaceOnEventList+0xa>
    4cd8:	cd b7       	in	r28, 0x3d	; 61
    4cda:	de b7       	in	r29, 0x3e	; 62
    4cdc:	9c 83       	std	Y+4, r25	; 0x04
    4cde:	8b 83       	std	Y+3, r24	; 0x03
    4ce0:	7e 83       	std	Y+6, r23	; 0x06
    4ce2:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    4ce4:	4b 81       	ldd	r20, Y+3	; 0x03
    4ce6:	5c 81       	ldd	r21, Y+4	; 0x04
    4ce8:	80 91 26 06 	lds	r24, 0x0626
    4cec:	90 91 27 06 	lds	r25, 0x0627
    4cf0:	9c 01       	movw	r18, r24
    4cf2:	24 5f       	subi	r18, 0xF4	; 244
    4cf4:	3f 4f       	sbci	r19, 0xFF	; 255
    4cf6:	ca 01       	movw	r24, r20
    4cf8:	b9 01       	movw	r22, r18
    4cfa:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4cfe:	80 91 26 06 	lds	r24, 0x0626
    4d02:	90 91 27 06 	lds	r25, 0x0627
    4d06:	02 96       	adiw	r24, 0x02	; 2
    4d08:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    4d0c:	20 91 2a 06 	lds	r18, 0x062A
    4d10:	30 91 2b 06 	lds	r19, 0x062B
    4d14:	8d 81       	ldd	r24, Y+5	; 0x05
    4d16:	9e 81       	ldd	r25, Y+6	; 0x06
    4d18:	82 0f       	add	r24, r18
    4d1a:	93 1f       	adc	r25, r19
    4d1c:	9a 83       	std	Y+2, r25	; 0x02
    4d1e:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4d20:	89 81       	ldd	r24, Y+1	; 0x01
    4d22:	9a 81       	ldd	r25, Y+2	; 0x02
    4d24:	0e 94 61 28 	call	0x50c2	; 0x50c2 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    4d28:	26 96       	adiw	r28, 0x06	; 6
    4d2a:	0f b6       	in	r0, 0x3f	; 63
    4d2c:	f8 94       	cli
    4d2e:	de bf       	out	0x3e, r29	; 62
    4d30:	0f be       	out	0x3f, r0	; 63
    4d32:	cd bf       	out	0x3d, r28	; 61
    4d34:	cf 91       	pop	r28
    4d36:	df 91       	pop	r29
    4d38:	08 95       	ret

00004d3a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    4d3a:	df 93       	push	r29
    4d3c:	cf 93       	push	r28
    4d3e:	00 d0       	rcall	.+0      	; 0x4d40 <xTaskRemoveFromEventList+0x6>
    4d40:	00 d0       	rcall	.+0      	; 0x4d42 <xTaskRemoveFromEventList+0x8>
    4d42:	0f 92       	push	r0
    4d44:	cd b7       	in	r28, 0x3d	; 61
    4d46:	de b7       	in	r29, 0x3e	; 62
    4d48:	9d 83       	std	Y+5, r25	; 0x05
    4d4a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4d4c:	ec 81       	ldd	r30, Y+4	; 0x04
    4d4e:	fd 81       	ldd	r31, Y+5	; 0x05
    4d50:	05 80       	ldd	r0, Z+5	; 0x05
    4d52:	f6 81       	ldd	r31, Z+6	; 0x06
    4d54:	e0 2d       	mov	r30, r0
    4d56:	86 81       	ldd	r24, Z+6	; 0x06
    4d58:	97 81       	ldd	r25, Z+7	; 0x07
    4d5a:	9b 83       	std	Y+3, r25	; 0x03
    4d5c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4d5e:	8a 81       	ldd	r24, Y+2	; 0x02
    4d60:	9b 81       	ldd	r25, Y+3	; 0x03
    4d62:	0c 96       	adiw	r24, 0x0c	; 12
    4d64:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4d68:	80 91 2f 06 	lds	r24, 0x062F
    4d6c:	88 23       	and	r24, r24
    4d6e:	61 f5       	brne	.+88     	; 0x4dc8 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4d70:	8a 81       	ldd	r24, Y+2	; 0x02
    4d72:	9b 81       	ldd	r25, Y+3	; 0x03
    4d74:	02 96       	adiw	r24, 0x02	; 2
    4d76:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    4d7a:	ea 81       	ldd	r30, Y+2	; 0x02
    4d7c:	fb 81       	ldd	r31, Y+3	; 0x03
    4d7e:	96 89       	ldd	r25, Z+22	; 0x16
    4d80:	80 91 2d 06 	lds	r24, 0x062D
    4d84:	89 17       	cp	r24, r25
    4d86:	28 f4       	brcc	.+10     	; 0x4d92 <xTaskRemoveFromEventList+0x58>
    4d88:	ea 81       	ldd	r30, Y+2	; 0x02
    4d8a:	fb 81       	ldd	r31, Y+3	; 0x03
    4d8c:	86 89       	ldd	r24, Z+22	; 0x16
    4d8e:	80 93 2d 06 	sts	0x062D, r24
    4d92:	ea 81       	ldd	r30, Y+2	; 0x02
    4d94:	fb 81       	ldd	r31, Y+3	; 0x03
    4d96:	86 89       	ldd	r24, Z+22	; 0x16
    4d98:	28 2f       	mov	r18, r24
    4d9a:	30 e0       	ldi	r19, 0x00	; 0
    4d9c:	c9 01       	movw	r24, r18
    4d9e:	88 0f       	add	r24, r24
    4da0:	99 1f       	adc	r25, r25
    4da2:	88 0f       	add	r24, r24
    4da4:	99 1f       	adc	r25, r25
    4da6:	88 0f       	add	r24, r24
    4da8:	99 1f       	adc	r25, r25
    4daa:	82 0f       	add	r24, r18
    4dac:	93 1f       	adc	r25, r19
    4dae:	ac 01       	movw	r20, r24
    4db0:	4c 5c       	subi	r20, 0xCC	; 204
    4db2:	59 4f       	sbci	r21, 0xF9	; 249
    4db4:	8a 81       	ldd	r24, Y+2	; 0x02
    4db6:	9b 81       	ldd	r25, Y+3	; 0x03
    4db8:	9c 01       	movw	r18, r24
    4dba:	2e 5f       	subi	r18, 0xFE	; 254
    4dbc:	3f 4f       	sbci	r19, 0xFF	; 255
    4dbe:	ca 01       	movw	r24, r20
    4dc0:	b9 01       	movw	r22, r18
    4dc2:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <vListInsertEnd>
    4dc6:	0a c0       	rjmp	.+20     	; 0x4ddc <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4dc8:	8a 81       	ldd	r24, Y+2	; 0x02
    4dca:	9b 81       	ldd	r25, Y+3	; 0x03
    4dcc:	9c 01       	movw	r18, r24
    4dce:	24 5f       	subi	r18, 0xF4	; 244
    4dd0:	3f 4f       	sbci	r19, 0xFF	; 255
    4dd2:	87 e7       	ldi	r24, 0x77	; 119
    4dd4:	96 e0       	ldi	r25, 0x06	; 6
    4dd6:	b9 01       	movw	r22, r18
    4dd8:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4ddc:	ea 81       	ldd	r30, Y+2	; 0x02
    4dde:	fb 81       	ldd	r31, Y+3	; 0x03
    4de0:	96 89       	ldd	r25, Z+22	; 0x16
    4de2:	e0 91 26 06 	lds	r30, 0x0626
    4de6:	f0 91 27 06 	lds	r31, 0x0627
    4dea:	86 89       	ldd	r24, Z+22	; 0x16
    4dec:	98 17       	cp	r25, r24
    4dee:	18 f0       	brcs	.+6      	; 0x4df6 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4df0:	81 e0       	ldi	r24, 0x01	; 1
    4df2:	89 83       	std	Y+1, r24	; 0x01
    4df4:	01 c0       	rjmp	.+2      	; 0x4df8 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    4df6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4df8:	89 81       	ldd	r24, Y+1	; 0x01
}
    4dfa:	0f 90       	pop	r0
    4dfc:	0f 90       	pop	r0
    4dfe:	0f 90       	pop	r0
    4e00:	0f 90       	pop	r0
    4e02:	0f 90       	pop	r0
    4e04:	cf 91       	pop	r28
    4e06:	df 91       	pop	r29
    4e08:	08 95       	ret

00004e0a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    4e0a:	df 93       	push	r29
    4e0c:	cf 93       	push	r28
    4e0e:	00 d0       	rcall	.+0      	; 0x4e10 <vTaskSetTimeOutState+0x6>
    4e10:	cd b7       	in	r28, 0x3d	; 61
    4e12:	de b7       	in	r29, 0x3e	; 62
    4e14:	9a 83       	std	Y+2, r25	; 0x02
    4e16:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4e18:	80 91 32 06 	lds	r24, 0x0632
    4e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4e20:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4e22:	80 91 2a 06 	lds	r24, 0x062A
    4e26:	90 91 2b 06 	lds	r25, 0x062B
    4e2a:	e9 81       	ldd	r30, Y+1	; 0x01
    4e2c:	fa 81       	ldd	r31, Y+2	; 0x02
    4e2e:	92 83       	std	Z+2, r25	; 0x02
    4e30:	81 83       	std	Z+1, r24	; 0x01
}
    4e32:	0f 90       	pop	r0
    4e34:	0f 90       	pop	r0
    4e36:	cf 91       	pop	r28
    4e38:	df 91       	pop	r29
    4e3a:	08 95       	ret

00004e3c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    4e3c:	df 93       	push	r29
    4e3e:	cf 93       	push	r28
    4e40:	00 d0       	rcall	.+0      	; 0x4e42 <xTaskCheckForTimeOut+0x6>
    4e42:	00 d0       	rcall	.+0      	; 0x4e44 <xTaskCheckForTimeOut+0x8>
    4e44:	0f 92       	push	r0
    4e46:	cd b7       	in	r28, 0x3d	; 61
    4e48:	de b7       	in	r29, 0x3e	; 62
    4e4a:	9b 83       	std	Y+3, r25	; 0x03
    4e4c:	8a 83       	std	Y+2, r24	; 0x02
    4e4e:	7d 83       	std	Y+5, r23	; 0x05
    4e50:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4e52:	0f b6       	in	r0, 0x3f	; 63
    4e54:	f8 94       	cli
    4e56:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    4e58:	ea 81       	ldd	r30, Y+2	; 0x02
    4e5a:	fb 81       	ldd	r31, Y+3	; 0x03
    4e5c:	90 81       	ld	r25, Z
    4e5e:	80 91 32 06 	lds	r24, 0x0632
    4e62:	98 17       	cp	r25, r24
    4e64:	71 f0       	breq	.+28     	; 0x4e82 <xTaskCheckForTimeOut+0x46>
    4e66:	ea 81       	ldd	r30, Y+2	; 0x02
    4e68:	fb 81       	ldd	r31, Y+3	; 0x03
    4e6a:	21 81       	ldd	r18, Z+1	; 0x01
    4e6c:	32 81       	ldd	r19, Z+2	; 0x02
    4e6e:	80 91 2a 06 	lds	r24, 0x062A
    4e72:	90 91 2b 06 	lds	r25, 0x062B
    4e76:	82 17       	cp	r24, r18
    4e78:	93 07       	cpc	r25, r19
    4e7a:	18 f0       	brcs	.+6      	; 0x4e82 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4e7c:	81 e0       	ldi	r24, 0x01	; 1
    4e7e:	89 83       	std	Y+1, r24	; 0x01
    4e80:	2f c0       	rjmp	.+94     	; 0x4ee0 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4e82:	20 91 2a 06 	lds	r18, 0x062A
    4e86:	30 91 2b 06 	lds	r19, 0x062B
    4e8a:	ea 81       	ldd	r30, Y+2	; 0x02
    4e8c:	fb 81       	ldd	r31, Y+3	; 0x03
    4e8e:	81 81       	ldd	r24, Z+1	; 0x01
    4e90:	92 81       	ldd	r25, Z+2	; 0x02
    4e92:	28 1b       	sub	r18, r24
    4e94:	39 0b       	sbc	r19, r25
    4e96:	ec 81       	ldd	r30, Y+4	; 0x04
    4e98:	fd 81       	ldd	r31, Y+5	; 0x05
    4e9a:	80 81       	ld	r24, Z
    4e9c:	91 81       	ldd	r25, Z+1	; 0x01
    4e9e:	28 17       	cp	r18, r24
    4ea0:	39 07       	cpc	r19, r25
    4ea2:	e0 f4       	brcc	.+56     	; 0x4edc <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    4ea4:	ec 81       	ldd	r30, Y+4	; 0x04
    4ea6:	fd 81       	ldd	r31, Y+5	; 0x05
    4ea8:	40 81       	ld	r20, Z
    4eaa:	51 81       	ldd	r21, Z+1	; 0x01
    4eac:	ea 81       	ldd	r30, Y+2	; 0x02
    4eae:	fb 81       	ldd	r31, Y+3	; 0x03
    4eb0:	21 81       	ldd	r18, Z+1	; 0x01
    4eb2:	32 81       	ldd	r19, Z+2	; 0x02
    4eb4:	80 91 2a 06 	lds	r24, 0x062A
    4eb8:	90 91 2b 06 	lds	r25, 0x062B
    4ebc:	b9 01       	movw	r22, r18
    4ebe:	68 1b       	sub	r22, r24
    4ec0:	79 0b       	sbc	r23, r25
    4ec2:	cb 01       	movw	r24, r22
    4ec4:	84 0f       	add	r24, r20
    4ec6:	95 1f       	adc	r25, r21
    4ec8:	ec 81       	ldd	r30, Y+4	; 0x04
    4eca:	fd 81       	ldd	r31, Y+5	; 0x05
    4ecc:	91 83       	std	Z+1, r25	; 0x01
    4ece:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    4ed0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ed2:	9b 81       	ldd	r25, Y+3	; 0x03
    4ed4:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    4ed8:	19 82       	std	Y+1, r1	; 0x01
    4eda:	02 c0       	rjmp	.+4      	; 0x4ee0 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    4edc:	81 e0       	ldi	r24, 0x01	; 1
    4ede:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4ee0:	0f 90       	pop	r0
    4ee2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4ee4:	89 81       	ldd	r24, Y+1	; 0x01
}
    4ee6:	0f 90       	pop	r0
    4ee8:	0f 90       	pop	r0
    4eea:	0f 90       	pop	r0
    4eec:	0f 90       	pop	r0
    4eee:	0f 90       	pop	r0
    4ef0:	cf 91       	pop	r28
    4ef2:	df 91       	pop	r29
    4ef4:	08 95       	ret

00004ef6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4ef6:	df 93       	push	r29
    4ef8:	cf 93       	push	r28
    4efa:	cd b7       	in	r28, 0x3d	; 61
    4efc:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4efe:	81 e0       	ldi	r24, 0x01	; 1
    4f00:	80 93 31 06 	sts	0x0631, r24
}
    4f04:	cf 91       	pop	r28
    4f06:	df 91       	pop	r29
    4f08:	08 95       	ret

00004f0a <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4f0a:	df 93       	push	r29
    4f0c:	cf 93       	push	r28
    4f0e:	00 d0       	rcall	.+0      	; 0x4f10 <prvIdleTask+0x6>
    4f10:	cd b7       	in	r28, 0x3d	; 61
    4f12:	de b7       	in	r29, 0x3e	; 62
    4f14:	9a 83       	std	Y+2, r25	; 0x02
    4f16:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    4f18:	0e 94 23 28 	call	0x5046	; 0x5046 <prvCheckTasksWaitingTermination>
    4f1c:	fd cf       	rjmp	.-6      	; 0x4f18 <prvIdleTask+0xe>

00004f1e <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    4f1e:	0f 93       	push	r16
    4f20:	1f 93       	push	r17
    4f22:	df 93       	push	r29
    4f24:	cf 93       	push	r28
    4f26:	cd b7       	in	r28, 0x3d	; 61
    4f28:	de b7       	in	r29, 0x3e	; 62
    4f2a:	29 97       	sbiw	r28, 0x09	; 9
    4f2c:	0f b6       	in	r0, 0x3f	; 63
    4f2e:	f8 94       	cli
    4f30:	de bf       	out	0x3e, r29	; 62
    4f32:	0f be       	out	0x3f, r0	; 63
    4f34:	cd bf       	out	0x3d, r28	; 61
    4f36:	9a 83       	std	Y+2, r25	; 0x02
    4f38:	89 83       	std	Y+1, r24	; 0x01
    4f3a:	7c 83       	std	Y+4, r23	; 0x04
    4f3c:	6b 83       	std	Y+3, r22	; 0x03
    4f3e:	4d 83       	std	Y+5, r20	; 0x05
    4f40:	3f 83       	std	Y+7, r19	; 0x07
    4f42:	2e 83       	std	Y+6, r18	; 0x06
    4f44:	19 87       	std	Y+9, r17	; 0x09
    4f46:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    4f48:	89 81       	ldd	r24, Y+1	; 0x01
    4f4a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f4c:	49 96       	adiw	r24, 0x19	; 25
    4f4e:	2b 81       	ldd	r18, Y+3	; 0x03
    4f50:	3c 81       	ldd	r19, Y+4	; 0x04
    4f52:	b9 01       	movw	r22, r18
    4f54:	48 e0       	ldi	r20, 0x08	; 8
    4f56:	50 e0       	ldi	r21, 0x00	; 0
    4f58:	0e 94 57 29 	call	0x52ae	; 0x52ae <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    4f5c:	e9 81       	ldd	r30, Y+1	; 0x01
    4f5e:	fa 81       	ldd	r31, Y+2	; 0x02
    4f60:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4f62:	8d 81       	ldd	r24, Y+5	; 0x05
    4f64:	85 30       	cpi	r24, 0x05	; 5
    4f66:	10 f0       	brcs	.+4      	; 0x4f6c <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    4f68:	84 e0       	ldi	r24, 0x04	; 4
    4f6a:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    4f6c:	e9 81       	ldd	r30, Y+1	; 0x01
    4f6e:	fa 81       	ldd	r31, Y+2	; 0x02
    4f70:	8d 81       	ldd	r24, Y+5	; 0x05
    4f72:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4f74:	89 81       	ldd	r24, Y+1	; 0x01
    4f76:	9a 81       	ldd	r25, Y+2	; 0x02
    4f78:	02 96       	adiw	r24, 0x02	; 2
    4f7a:	0e 94 2f 15 	call	0x2a5e	; 0x2a5e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4f7e:	89 81       	ldd	r24, Y+1	; 0x01
    4f80:	9a 81       	ldd	r25, Y+2	; 0x02
    4f82:	0c 96       	adiw	r24, 0x0c	; 12
    4f84:	0e 94 2f 15 	call	0x2a5e	; 0x2a5e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4f88:	e9 81       	ldd	r30, Y+1	; 0x01
    4f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    4f8c:	89 81       	ldd	r24, Y+1	; 0x01
    4f8e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f90:	91 87       	std	Z+9, r25	; 0x09
    4f92:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4f94:	8d 81       	ldd	r24, Y+5	; 0x05
    4f96:	28 2f       	mov	r18, r24
    4f98:	30 e0       	ldi	r19, 0x00	; 0
    4f9a:	85 e0       	ldi	r24, 0x05	; 5
    4f9c:	90 e0       	ldi	r25, 0x00	; 0
    4f9e:	82 1b       	sub	r24, r18
    4fa0:	93 0b       	sbc	r25, r19
    4fa2:	e9 81       	ldd	r30, Y+1	; 0x01
    4fa4:	fa 81       	ldd	r31, Y+2	; 0x02
    4fa6:	95 87       	std	Z+13, r25	; 0x0d
    4fa8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4faa:	e9 81       	ldd	r30, Y+1	; 0x01
    4fac:	fa 81       	ldd	r31, Y+2	; 0x02
    4fae:	89 81       	ldd	r24, Y+1	; 0x01
    4fb0:	9a 81       	ldd	r25, Y+2	; 0x02
    4fb2:	93 8b       	std	Z+19, r25	; 0x13
    4fb4:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    4fb6:	29 96       	adiw	r28, 0x09	; 9
    4fb8:	0f b6       	in	r0, 0x3f	; 63
    4fba:	f8 94       	cli
    4fbc:	de bf       	out	0x3e, r29	; 62
    4fbe:	0f be       	out	0x3f, r0	; 63
    4fc0:	cd bf       	out	0x3d, r28	; 61
    4fc2:	cf 91       	pop	r28
    4fc4:	df 91       	pop	r29
    4fc6:	1f 91       	pop	r17
    4fc8:	0f 91       	pop	r16
    4fca:	08 95       	ret

00004fcc <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    4fcc:	df 93       	push	r29
    4fce:	cf 93       	push	r28
    4fd0:	0f 92       	push	r0
    4fd2:	cd b7       	in	r28, 0x3d	; 61
    4fd4:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4fd6:	19 82       	std	Y+1, r1	; 0x01
    4fd8:	13 c0       	rjmp	.+38     	; 0x5000 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    4fda:	89 81       	ldd	r24, Y+1	; 0x01
    4fdc:	28 2f       	mov	r18, r24
    4fde:	30 e0       	ldi	r19, 0x00	; 0
    4fe0:	c9 01       	movw	r24, r18
    4fe2:	88 0f       	add	r24, r24
    4fe4:	99 1f       	adc	r25, r25
    4fe6:	88 0f       	add	r24, r24
    4fe8:	99 1f       	adc	r25, r25
    4fea:	88 0f       	add	r24, r24
    4fec:	99 1f       	adc	r25, r25
    4fee:	82 0f       	add	r24, r18
    4ff0:	93 1f       	adc	r25, r19
    4ff2:	8c 5c       	subi	r24, 0xCC	; 204
    4ff4:	99 4f       	sbci	r25, 0xF9	; 249
    4ff6:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4ffa:	89 81       	ldd	r24, Y+1	; 0x01
    4ffc:	8f 5f       	subi	r24, 0xFF	; 255
    4ffe:	89 83       	std	Y+1, r24	; 0x01
    5000:	89 81       	ldd	r24, Y+1	; 0x01
    5002:	85 30       	cpi	r24, 0x05	; 5
    5004:	50 f3       	brcs	.-44     	; 0x4fda <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    5006:	81 e6       	ldi	r24, 0x61	; 97
    5008:	96 e0       	ldi	r25, 0x06	; 6
    500a:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    500e:	8a e6       	ldi	r24, 0x6A	; 106
    5010:	96 e0       	ldi	r25, 0x06	; 6
    5012:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    5016:	87 e7       	ldi	r24, 0x77	; 119
    5018:	96 e0       	ldi	r25, 0x06	; 6
    501a:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    501e:	80 e8       	ldi	r24, 0x80	; 128
    5020:	96 e0       	ldi	r25, 0x06	; 6
    5022:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5026:	81 e6       	ldi	r24, 0x61	; 97
    5028:	96 e0       	ldi	r25, 0x06	; 6
    502a:	90 93 74 06 	sts	0x0674, r25
    502e:	80 93 73 06 	sts	0x0673, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5032:	8a e6       	ldi	r24, 0x6A	; 106
    5034:	96 e0       	ldi	r25, 0x06	; 6
    5036:	90 93 76 06 	sts	0x0676, r25
    503a:	80 93 75 06 	sts	0x0675, r24
}
    503e:	0f 90       	pop	r0
    5040:	cf 91       	pop	r28
    5042:	df 91       	pop	r29
    5044:	08 95       	ret

00005046 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5046:	df 93       	push	r29
    5048:	cf 93       	push	r28
    504a:	00 d0       	rcall	.+0      	; 0x504c <prvCheckTasksWaitingTermination+0x6>
    504c:	0f 92       	push	r0
    504e:	cd b7       	in	r28, 0x3d	; 61
    5050:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    5052:	80 91 28 06 	lds	r24, 0x0628
    5056:	88 23       	and	r24, r24
    5058:	71 f1       	breq	.+92     	; 0x50b6 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    505a:	0e 94 61 24 	call	0x48c2	; 0x48c2 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    505e:	80 91 80 06 	lds	r24, 0x0680
    5062:	1b 82       	std	Y+3, r1	; 0x03
    5064:	88 23       	and	r24, r24
    5066:	11 f4       	brne	.+4      	; 0x506c <prvCheckTasksWaitingTermination+0x26>
    5068:	81 e0       	ldi	r24, 0x01	; 1
    506a:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    506c:	0e 94 6d 24 	call	0x48da	; 0x48da <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    5070:	8b 81       	ldd	r24, Y+3	; 0x03
    5072:	88 23       	and	r24, r24
    5074:	01 f5       	brne	.+64     	; 0x50b6 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    5076:	0f b6       	in	r0, 0x3f	; 63
    5078:	f8 94       	cli
    507a:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    507c:	e0 91 85 06 	lds	r30, 0x0685
    5080:	f0 91 86 06 	lds	r31, 0x0686
    5084:	86 81       	ldd	r24, Z+6	; 0x06
    5086:	97 81       	ldd	r25, Z+7	; 0x07
    5088:	9a 83       	std	Y+2, r25	; 0x02
    508a:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    508c:	89 81       	ldd	r24, Y+1	; 0x01
    508e:	9a 81       	ldd	r25, Y+2	; 0x02
    5090:	02 96       	adiw	r24, 0x02	; 2
    5092:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vListRemove>
					--uxCurrentNumberOfTasks;
    5096:	80 91 29 06 	lds	r24, 0x0629
    509a:	81 50       	subi	r24, 0x01	; 1
    509c:	80 93 29 06 	sts	0x0629, r24
					--uxTasksDeleted;
    50a0:	80 91 28 06 	lds	r24, 0x0628
    50a4:	81 50       	subi	r24, 0x01	; 1
    50a6:	80 93 28 06 	sts	0x0628, r24
				}
				taskEXIT_CRITICAL();
    50aa:	0f 90       	pop	r0
    50ac:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    50ae:	89 81       	ldd	r24, Y+1	; 0x01
    50b0:	9a 81       	ldd	r25, Y+2	; 0x02
    50b2:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    50b6:	0f 90       	pop	r0
    50b8:	0f 90       	pop	r0
    50ba:	0f 90       	pop	r0
    50bc:	cf 91       	pop	r28
    50be:	df 91       	pop	r29
    50c0:	08 95       	ret

000050c2 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    50c2:	df 93       	push	r29
    50c4:	cf 93       	push	r28
    50c6:	00 d0       	rcall	.+0      	; 0x50c8 <prvAddCurrentTaskToDelayedList+0x6>
    50c8:	cd b7       	in	r28, 0x3d	; 61
    50ca:	de b7       	in	r29, 0x3e	; 62
    50cc:	9a 83       	std	Y+2, r25	; 0x02
    50ce:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    50d0:	e0 91 26 06 	lds	r30, 0x0626
    50d4:	f0 91 27 06 	lds	r31, 0x0627
    50d8:	89 81       	ldd	r24, Y+1	; 0x01
    50da:	9a 81       	ldd	r25, Y+2	; 0x02
    50dc:	93 83       	std	Z+3, r25	; 0x03
    50de:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    50e0:	20 91 2a 06 	lds	r18, 0x062A
    50e4:	30 91 2b 06 	lds	r19, 0x062B
    50e8:	89 81       	ldd	r24, Y+1	; 0x01
    50ea:	9a 81       	ldd	r25, Y+2	; 0x02
    50ec:	82 17       	cp	r24, r18
    50ee:	93 07       	cpc	r25, r19
    50f0:	70 f4       	brcc	.+28     	; 0x510e <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    50f2:	80 91 75 06 	lds	r24, 0x0675
    50f6:	90 91 76 06 	lds	r25, 0x0676
    50fa:	20 91 26 06 	lds	r18, 0x0626
    50fe:	30 91 27 06 	lds	r19, 0x0627
    5102:	2e 5f       	subi	r18, 0xFE	; 254
    5104:	3f 4f       	sbci	r19, 0xFF	; 255
    5106:	b9 01       	movw	r22, r18
    5108:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <vListInsert>
    510c:	1e c0       	rjmp	.+60     	; 0x514a <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    510e:	40 91 73 06 	lds	r20, 0x0673
    5112:	50 91 74 06 	lds	r21, 0x0674
    5116:	80 91 26 06 	lds	r24, 0x0626
    511a:	90 91 27 06 	lds	r25, 0x0627
    511e:	9c 01       	movw	r18, r24
    5120:	2e 5f       	subi	r18, 0xFE	; 254
    5122:	3f 4f       	sbci	r19, 0xFF	; 255
    5124:	ca 01       	movw	r24, r20
    5126:	b9 01       	movw	r22, r18
    5128:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    512c:	20 91 25 01 	lds	r18, 0x0125
    5130:	30 91 26 01 	lds	r19, 0x0126
    5134:	89 81       	ldd	r24, Y+1	; 0x01
    5136:	9a 81       	ldd	r25, Y+2	; 0x02
    5138:	82 17       	cp	r24, r18
    513a:	93 07       	cpc	r25, r19
    513c:	30 f4       	brcc	.+12     	; 0x514a <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    513e:	89 81       	ldd	r24, Y+1	; 0x01
    5140:	9a 81       	ldd	r25, Y+2	; 0x02
    5142:	90 93 26 01 	sts	0x0126, r25
    5146:	80 93 25 01 	sts	0x0125, r24
		}
	}
}
    514a:	0f 90       	pop	r0
    514c:	0f 90       	pop	r0
    514e:	cf 91       	pop	r28
    5150:	df 91       	pop	r29
    5152:	08 95       	ret

00005154 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    5154:	df 93       	push	r29
    5156:	cf 93       	push	r28
    5158:	cd b7       	in	r28, 0x3d	; 61
    515a:	de b7       	in	r29, 0x3e	; 62
    515c:	28 97       	sbiw	r28, 0x08	; 8
    515e:	0f b6       	in	r0, 0x3f	; 63
    5160:	f8 94       	cli
    5162:	de bf       	out	0x3e, r29	; 62
    5164:	0f be       	out	0x3f, r0	; 63
    5166:	cd bf       	out	0x3d, r28	; 61
    5168:	9c 83       	std	Y+4, r25	; 0x04
    516a:	8b 83       	std	Y+3, r24	; 0x03
    516c:	7e 83       	std	Y+6, r23	; 0x06
    516e:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    5170:	81 e2       	ldi	r24, 0x21	; 33
    5172:	90 e0       	ldi	r25, 0x00	; 0
    5174:	0e 94 99 14 	call	0x2932	; 0x2932 <pvPortMalloc>
    5178:	9a 83       	std	Y+2, r25	; 0x02
    517a:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    517c:	89 81       	ldd	r24, Y+1	; 0x01
    517e:	9a 81       	ldd	r25, Y+2	; 0x02
    5180:	00 97       	sbiw	r24, 0x00	; 0
    5182:	69 f1       	breq	.+90     	; 0x51de <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    5184:	8d 81       	ldd	r24, Y+5	; 0x05
    5186:	9e 81       	ldd	r25, Y+6	; 0x06
    5188:	00 97       	sbiw	r24, 0x00	; 0
    518a:	39 f4       	brne	.+14     	; 0x519a <prvAllocateTCBAndStack+0x46>
    518c:	8b 81       	ldd	r24, Y+3	; 0x03
    518e:	9c 81       	ldd	r25, Y+4	; 0x04
    5190:	0e 94 99 14 	call	0x2932	; 0x2932 <pvPortMalloc>
    5194:	98 87       	std	Y+8, r25	; 0x08
    5196:	8f 83       	std	Y+7, r24	; 0x07
    5198:	04 c0       	rjmp	.+8      	; 0x51a2 <prvAllocateTCBAndStack+0x4e>
    519a:	8d 81       	ldd	r24, Y+5	; 0x05
    519c:	9e 81       	ldd	r25, Y+6	; 0x06
    519e:	98 87       	std	Y+8, r25	; 0x08
    51a0:	8f 83       	std	Y+7, r24	; 0x07
    51a2:	e9 81       	ldd	r30, Y+1	; 0x01
    51a4:	fa 81       	ldd	r31, Y+2	; 0x02
    51a6:	8f 81       	ldd	r24, Y+7	; 0x07
    51a8:	98 85       	ldd	r25, Y+8	; 0x08
    51aa:	90 8f       	std	Z+24, r25	; 0x18
    51ac:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    51ae:	e9 81       	ldd	r30, Y+1	; 0x01
    51b0:	fa 81       	ldd	r31, Y+2	; 0x02
    51b2:	87 89       	ldd	r24, Z+23	; 0x17
    51b4:	90 8d       	ldd	r25, Z+24	; 0x18
    51b6:	00 97       	sbiw	r24, 0x00	; 0
    51b8:	39 f4       	brne	.+14     	; 0x51c8 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    51ba:	89 81       	ldd	r24, Y+1	; 0x01
    51bc:	9a 81       	ldd	r25, Y+2	; 0x02
    51be:	0e 94 df 14 	call	0x29be	; 0x29be <vPortFree>
			pxNewTCB = NULL;
    51c2:	1a 82       	std	Y+2, r1	; 0x02
    51c4:	19 82       	std	Y+1, r1	; 0x01
    51c6:	0b c0       	rjmp	.+22     	; 0x51de <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    51c8:	e9 81       	ldd	r30, Y+1	; 0x01
    51ca:	fa 81       	ldd	r31, Y+2	; 0x02
    51cc:	87 89       	ldd	r24, Z+23	; 0x17
    51ce:	90 8d       	ldd	r25, Z+24	; 0x18
    51d0:	2b 81       	ldd	r18, Y+3	; 0x03
    51d2:	3c 81       	ldd	r19, Y+4	; 0x04
    51d4:	65 ea       	ldi	r22, 0xA5	; 165
    51d6:	70 e0       	ldi	r23, 0x00	; 0
    51d8:	a9 01       	movw	r20, r18
    51da:	0e 94 50 29 	call	0x52a0	; 0x52a0 <memset>
		}
	}

	return pxNewTCB;
    51de:	89 81       	ldd	r24, Y+1	; 0x01
    51e0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    51e2:	28 96       	adiw	r28, 0x08	; 8
    51e4:	0f b6       	in	r0, 0x3f	; 63
    51e6:	f8 94       	cli
    51e8:	de bf       	out	0x3e, r29	; 62
    51ea:	0f be       	out	0x3f, r0	; 63
    51ec:	cd bf       	out	0x3d, r28	; 61
    51ee:	cf 91       	pop	r28
    51f0:	df 91       	pop	r29
    51f2:	08 95       	ret

000051f4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    51f4:	df 93       	push	r29
    51f6:	cf 93       	push	r28
    51f8:	00 d0       	rcall	.+0      	; 0x51fa <prvDeleteTCB+0x6>
    51fa:	cd b7       	in	r28, 0x3d	; 61
    51fc:	de b7       	in	r29, 0x3e	; 62
    51fe:	9a 83       	std	Y+2, r25	; 0x02
    5200:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    5202:	e9 81       	ldd	r30, Y+1	; 0x01
    5204:	fa 81       	ldd	r31, Y+2	; 0x02
    5206:	87 89       	ldd	r24, Z+23	; 0x17
    5208:	90 8d       	ldd	r25, Z+24	; 0x18
    520a:	0e 94 df 14 	call	0x29be	; 0x29be <vPortFree>
		vPortFree( pxTCB );
    520e:	89 81       	ldd	r24, Y+1	; 0x01
    5210:	9a 81       	ldd	r25, Y+2	; 0x02
    5212:	0e 94 df 14 	call	0x29be	; 0x29be <vPortFree>
	}
    5216:	0f 90       	pop	r0
    5218:	0f 90       	pop	r0
    521a:	cf 91       	pop	r28
    521c:	df 91       	pop	r29
    521e:	08 95       	ret

00005220 <__prologue_saves__>:
    5220:	2f 92       	push	r2
    5222:	3f 92       	push	r3
    5224:	4f 92       	push	r4
    5226:	5f 92       	push	r5
    5228:	6f 92       	push	r6
    522a:	7f 92       	push	r7
    522c:	8f 92       	push	r8
    522e:	9f 92       	push	r9
    5230:	af 92       	push	r10
    5232:	bf 92       	push	r11
    5234:	cf 92       	push	r12
    5236:	df 92       	push	r13
    5238:	ef 92       	push	r14
    523a:	ff 92       	push	r15
    523c:	0f 93       	push	r16
    523e:	1f 93       	push	r17
    5240:	cf 93       	push	r28
    5242:	df 93       	push	r29
    5244:	cd b7       	in	r28, 0x3d	; 61
    5246:	de b7       	in	r29, 0x3e	; 62
    5248:	ca 1b       	sub	r28, r26
    524a:	db 0b       	sbc	r29, r27
    524c:	0f b6       	in	r0, 0x3f	; 63
    524e:	f8 94       	cli
    5250:	de bf       	out	0x3e, r29	; 62
    5252:	0f be       	out	0x3f, r0	; 63
    5254:	cd bf       	out	0x3d, r28	; 61
    5256:	09 94       	ijmp

00005258 <__epilogue_restores__>:
    5258:	2a 88       	ldd	r2, Y+18	; 0x12
    525a:	39 88       	ldd	r3, Y+17	; 0x11
    525c:	48 88       	ldd	r4, Y+16	; 0x10
    525e:	5f 84       	ldd	r5, Y+15	; 0x0f
    5260:	6e 84       	ldd	r6, Y+14	; 0x0e
    5262:	7d 84       	ldd	r7, Y+13	; 0x0d
    5264:	8c 84       	ldd	r8, Y+12	; 0x0c
    5266:	9b 84       	ldd	r9, Y+11	; 0x0b
    5268:	aa 84       	ldd	r10, Y+10	; 0x0a
    526a:	b9 84       	ldd	r11, Y+9	; 0x09
    526c:	c8 84       	ldd	r12, Y+8	; 0x08
    526e:	df 80       	ldd	r13, Y+7	; 0x07
    5270:	ee 80       	ldd	r14, Y+6	; 0x06
    5272:	fd 80       	ldd	r15, Y+5	; 0x05
    5274:	0c 81       	ldd	r16, Y+4	; 0x04
    5276:	1b 81       	ldd	r17, Y+3	; 0x03
    5278:	aa 81       	ldd	r26, Y+2	; 0x02
    527a:	b9 81       	ldd	r27, Y+1	; 0x01
    527c:	ce 0f       	add	r28, r30
    527e:	d1 1d       	adc	r29, r1
    5280:	0f b6       	in	r0, 0x3f	; 63
    5282:	f8 94       	cli
    5284:	de bf       	out	0x3e, r29	; 62
    5286:	0f be       	out	0x3f, r0	; 63
    5288:	cd bf       	out	0x3d, r28	; 61
    528a:	ed 01       	movw	r28, r26
    528c:	08 95       	ret

0000528e <memcpy>:
    528e:	fb 01       	movw	r30, r22
    5290:	dc 01       	movw	r26, r24
    5292:	02 c0       	rjmp	.+4      	; 0x5298 <memcpy+0xa>
    5294:	01 90       	ld	r0, Z+
    5296:	0d 92       	st	X+, r0
    5298:	41 50       	subi	r20, 0x01	; 1
    529a:	50 40       	sbci	r21, 0x00	; 0
    529c:	d8 f7       	brcc	.-10     	; 0x5294 <memcpy+0x6>
    529e:	08 95       	ret

000052a0 <memset>:
    52a0:	dc 01       	movw	r26, r24
    52a2:	01 c0       	rjmp	.+2      	; 0x52a6 <memset+0x6>
    52a4:	6d 93       	st	X+, r22
    52a6:	41 50       	subi	r20, 0x01	; 1
    52a8:	50 40       	sbci	r21, 0x00	; 0
    52aa:	e0 f7       	brcc	.-8      	; 0x52a4 <memset+0x4>
    52ac:	08 95       	ret

000052ae <strncpy>:
    52ae:	fb 01       	movw	r30, r22
    52b0:	dc 01       	movw	r26, r24
    52b2:	41 50       	subi	r20, 0x01	; 1
    52b4:	50 40       	sbci	r21, 0x00	; 0
    52b6:	48 f0       	brcs	.+18     	; 0x52ca <strncpy+0x1c>
    52b8:	01 90       	ld	r0, Z+
    52ba:	0d 92       	st	X+, r0
    52bc:	00 20       	and	r0, r0
    52be:	c9 f7       	brne	.-14     	; 0x52b2 <strncpy+0x4>
    52c0:	01 c0       	rjmp	.+2      	; 0x52c4 <strncpy+0x16>
    52c2:	1d 92       	st	X+, r1
    52c4:	41 50       	subi	r20, 0x01	; 1
    52c6:	50 40       	sbci	r21, 0x00	; 0
    52c8:	e0 f7       	brcc	.-8      	; 0x52c2 <strncpy+0x14>
    52ca:	08 95       	ret

000052cc <_exit>:
    52cc:	f8 94       	cli

000052ce <__stop_program>:
    52ce:	ff cf       	rjmp	.-2      	; 0x52ce <__stop_program>
